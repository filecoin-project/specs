#+TITLE: Stacked DRG Commitments

#+HUGO_SECTION: algorithms/porep/porep_commitments/sdr_commitments
#+HUGO_BASE_DIR: ../../../..
#+OPTIONS: author:nil creator:nil timestamp:nil

#+begin_src lisp :exports none
  (ql:quickload :orient)
#+end_src

#+RESULTS:
| :ORIENT |

This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in [[https://www.overleaf.com/read/kcdhnxwptxbc][Tight PoS - ZigZag]].

* Graph
#+NAME: init-graph
#+BEGIN_SRC lisp :package "filecoin.theory" :exports none :results verbatim
  (defparameter *layers* 4)
  (defparameter *nodes* 8)

  (defparameter *regenerate-sdr-graph* nil)

  (defparameter *dumped-sdr-graph* '(:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION
                                     (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION
                                     (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH))

  (defparameter *sdr-graph*  (if *regenerate-sdr-graph*
                                 (make-sdr-graph *nodes* *layers*)
                                 (load-from-plist *dumped-sdr-graph*)))

  (let ((lg (first (sdr-graph-layer-graphs *sdr-graph*))))
    (defparameter *comm-d-graph* (make-comm-d-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph*))
    (defparameter *replica-graph* (make-replica-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph* :layers *layers*)))

  (dump *sdr-graph*)
#+END_SRC

#+RESULTS: init-graph
: (:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION
:  (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION
:  (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)



#+NAME: legend
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none
(emit-legend nil)
#+END_SRC

In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only
to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships
function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent
selection algorithm.

The following graphs illustrate the positions of challenges, DRG parents, and expander parents between layers. Only a
single DRG parent and a single expander parent are shown. The immediate predecessor parent is shown for graph topology,
but it is not tracked in the tables below.

In order to have a compact and concrete example, we use a graph containing only src_lisp[:package fct]{*nodes*} {{{results(=8=)}}} nodes replicated in src_lisp[:package fct]{*layers*} {{{results(=4=)}}} layers.
** Legend
#+BEGIN_SRC dot :file legend.png :var input=legend :exports results
$input
#+END_SRC

#+RESULTS:
[[file:legend.png]]

** Data Layer: $Comm_D$ Tree
#+NAME: data-layer
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none
(emit-comm-d-layer-graph *comm-d-graph*)
#+END_SRC

#+BEGIN_SRC dot :file data-layer.png :var input=data-layer :exports results
$input
#+END_SRC

#+RESULTS:
[[file:data-layer.png]]

** Replica Column Layers: $Comm_C$ Tree

#+NAME: layer-1
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
(emit-layer-graph (nth 0 (sdr-graph-layer-graphs *sdr-graph*)))
#+end_src

#+BEGIN_SRC dot :file layer-1.png :var input=layer-1 :exports results
$input
#+END_SRC

#+RESULTS:
[[file:layer-1.png]]

#+NAME: layer-2
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
(emit-layer-graph (nth 1 (sdr-graph-layer-graphs *sdr-graph*)))
#+END_SRC

#+BEGIN_SRC dot :file layer-2.png :var input=layer-2 :exports results
$input
#+END_SRC

#+RESULTS:
[[file:layer-2.png]]

#+NAME: layer-3
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
(emit-layer-graph (nth 2 (sdr-graph-layer-graphs *sdr-graph*)))
#+END_SRC

#+BEGIN_SRC dot :file layer-3.png :var input=layer-3 :exports results
$input
#+END_SRC

#+RESULTS:
[[file:layer-3.png]]

#+NAME: layer-4
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
(emit-layer-graph (nth 3 (sdr-graph-layer-graphs *sdr-graph*)))
#+END_SRC

#+BEGIN_SRC dot :file layer-4.png :var input=layer-4 :exports results
$input
#+END_SRC

#+RESULTS:
[[file:layer-4.png]]

# #+NAME: layer-5
# #+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
# (emit-layer-graph (nth 4 (sdr-graph-layer-graphs *sdr-graph*)))
# #+END_SRC

# #+BEGIN_SRC dot :file layer-5.png :var input=layer-5 :exports results
# $input
# #+END_SRC

# #+RESULTS:
# [[file:layer-4.png]]

# #+NAME: layer-6
# #+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none 
# (emit-layer-graph (nth 5 (sdr-graph-layer-graphs *sdr-graph*)))
# #+END_SRC

# #+BEGIN_SRC dot :file layer-6.png :var input=layer-6 :exports results
# $input
# #+END_SRC

# #+RESULTS:

** Final Layer: $Comm_{R_{LAST}}$ Tree
#+NAME: replica-layer
#+BEGIN_SRC lisp :package "filecoin.theory" :results output silent :exports none
(emit-replica-layer-graph *replica-graph*)
#+END_SRC

#+BEGIN_SRC dot :file replica-layer.png :var input=replica-layer :exports results
$input
#+END_SRC

#+RESULTS:
[[file:replica-layer.png]]

* Commitment Algorithm
**  Goal
We will generate two commitments $Comm_R, Comm_D$ to be placed on chain.

$Comm_D$ is the merkle root of the original data.

$Comm_R = H(Comm_C || Comm_{R_{LAST}})$.

Their construction is described below.

** Definitions and Notation
We will perform $L$ layers of SDR key generation over $N$ labeled nodes.

In the running example, $L$ is src_lisp[:package fct]{*layers*} {{{results(=4=)}}} and $N$ is src_lisp[:package fct]{*nodes*} {{{results(=8=)}}}.

Merkle roots (commitments) are generated with the vector-commitment function $VC(…)$.

Hashes are produced with a hash function $H(…)$, which is not necessarily that used by $VC(…)$.

$Comm = VC(l_1||…||l_N)$, where the $l_i$ are the data (labels or hashes) to be committed.

Generated trees are retained until the proving phase, when merkle proofs of a given label's inclusion in $Comm$ will be
created. We will designate such proofs $l_i \rightarrow Comm$.

We use the notation $e{_i}^{(l)}$, correlated in the table below with the $(l, i)$ notation used in the graphs above,
where $l$ indexes layers, and $i$ indexes labels or columns.

#+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(notation-row *sdr-graph* 1)
#+END_SRC

#+RESULTS:
| Graph    | $(1, 1)$    | $(1, 2)$    | $(1, 3)$    | $(1, 4)$    | $(1, 5)$    | $(1, 6)$    | $(1, 7)$    | $(1, 8)$    |
| Notation | $e_1^{(1)}$ | $e_2^{(1)}$ | $e_3^{(1)}$ | $e_4^{(1)}$ | $e_5^{(1)}$ | $e_6^{(1)}$ | $e_7^{(1)}$ | $e_8^{(1)}$ |

#+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(notation-row *sdr-graph* 2)
#+END_SRC
#+RESULTS:
| Graph    | $(2, 1)$    | $(2, 2)$    | $(2, 3)$    | $(2, 4)$    | $(2, 5)$    | $(2, 6)$    | $(2, 7)$    | $(2, 8)$    |
| Notation | $e_1^{(2)}$ | $e_2^{(2)}$ | $e_3^{(2)}$ | $e_4^{(2)}$ | $e_5^{(2)}$ | $e_6^{(2)}$ | $e_7^{(2)}$ | $e_8^{(2)}$ |
…

#+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(notation-row *sdr-graph* 4)
#+END_SRC

#+RESULTS:
| Graph    | $(4, 1)$    | $(4, 2)$    | $(4, 3)$    | $(4, 4)$    | $(4, 5)$    | $(4, 6)$    | $(4, 7)$    | $(4, 8)$    |
| Notation | $e_1^{(4)}$ | $e_2^{(4)}$ | $e_3^{(4)}$ | $e_4^{(4)}$ | $e_5^{(4)}$ | $e_6^{(4)}$ | $e_7^{(4)}$ | $e_8^{(4)}$ |

** Initial Data Layer
 #+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(initial-layer *comm-d-graph*)
#+END_SRC

 #+RESULTS:
 | ~~~~~~   | ~~~~~~   | ~~~~~~   | Challenge | ~~~~~~   | ~~~~~~   | ~~~~~~   | ~~~~~~   |
 | $(0, 1)$ | $(0, 2)$ | $(0, 3)$ | $(0, 4)$  | $(0, 5)$ | $(0, 6)$ | $(0, 7)$ | $(0, 8)$ |

*** Vector Commitment
Generate Merkle root for data leaves.

$Comm_D = VC(D_1 || D_2 || … || D_N)$, where $D_i = e_i^{(0)}$.

This example: $Comm_D = VC(e_1^{(0)}, e_2^{(0)}, e_3^{(0)}, e_4^{(0)}, e_5^{(0)}, e_6^{(0)}, e_7^{(0)}, e_8^{(0)})$.

*** Opening
To open $D_i$, provide a merkle proof $D_i \rightarrow Comm_D$.

** SDR Replica Columns
*** Columns

#+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(columns *sdr-graph*)
#+END_SRC

#+RESULTS:
| DRG Parents | Expander Parents | ~~~~~~   | Challenges | ~~~~~~   | ~~~~~~   | ~~~~~~   | ~~~~~~   |
| $(1, 1)$    | $(1, 2)^{*}$     | $(1, 3)$ | $(1, 4)$   | $(1, 5)$ | $(1, 6)$ | $(1, 7)$ | $(1, 8)$ |
| $(2, 1)$    | $(2, 2)$         | $(2, 3)$ | $(2, 4)$   | $(2, 5)$ | $(2, 6)$ | $(2, 7)$ | $(2, 8)$ |
| $(3, 1)$    | $(3, 2)$         | $(3, 3)$ | $(3, 4)$   | $(3, 5)$ | $(3, 6)$ | $(3, 7)$ | $(3, 8)$ |
| $(4, 1)$    | $(4, 2)$         | $(4, 3)$ | $(4, 4)$   | $(4, 5)$ | $(4, 6)$ | $(4, 7)$ | $(4, 8)$ |


$^{*}$ Indicates labels which must be hashed for column commitments but need not be opened for label checks.


Concatenate and hash rows of column $i$ to construct $O_i$.

Column hash $C_i = H(e_i^{(1)} || e_i^{(2)} || … || e_i^{(L)})$.

*** Vector Commitment

Generate Merkle tree for column leaves, $C_i$:

$Comm_C = VC(C_1 || C_2 || … || C_N)$.

*** Opening
**** To open labels for column $i$:
- Reveal all labels and prove they hash to $C_i$ as above. ($L$ hash proofs).
- Provide a merkle proof $C_i \rightarrow Comm_C$.

**** Then once, reusable for all columns,
- Reveal $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.

** Final Replica Layer
 #+BEGIN_SRC lisp :package "filecoin.theory" :exports results
(final-layer *sdr-graph*)
#+END_SRC

 #+RESULTS:
 | ~~~~~~   | ~~~~~~   | ~~~~~~   | Challenge | ~~~~~~   | ~~~~~~   | ~~~~~~   | ~~~~~~   |
 | $(5, 1)$ | $(5, 2)$ | $(5, 3)$ | $(5, 4)$  | $(5, 5)$ | $(5, 6)$ | $(5, 7)$ | $(5, 8)$ |

*** Vector Commitment
Generate Merkle tree for replica leaves.

$R_{LAST_i} = e_i^{(L+1)}$.

$Comm_{R_{LAST}} = VC(R_{LAST_1} || R_{LAST_2} || … || R_{LAST_N})$.

*** Opening
**** To open $R_{LAST_i}$,
- Provide a merkle proof $R_{LAST_i} \rightarrow Comm_{R_{LAST}}$.

**** Then once (shared with Replica Columns — see above):
- Reveal $Comm_C$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_pR$.

** Replica Commitment
*** Commitment
- Produce $Comm_R$ from its constituents.

- $Comm_R = H(Comm_C || Comm_{R_{LAST}})$.
*** Opening (performed once per PoRep)
- Reveal $Comm_C$ and $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.
* Challenge Selection
For each challenge $\chi$, we challenge each node $e_{\chi}^{(l)}$ for $l = 1, 2, .. L$.

* Opening Commitments for Offline Proof
For use in all challenge proofs, reveal $Comm_C$ and $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) =
Comm_R$.

To prove encoding for a challenged label $\chi$:
- Initial data layer openings
  - Open label for challenged data node $e_\chi^{(0)} — using Comm_D$.
- SDR replica column openings
  - Open all labels in $C_\chi$ containing challenged label's 'replica node', ($C_\chi$) — using $Comm_C$.
  - Open all labels in the columns containing challenged label's DRG parents — using $Comm_C$.
  - Open all labels in the columns containing challenged label's expander parents — using $Comm_C$.
- Final replica layer openings
  - Open all challenged labels ($e_{\chi}^{(L+1)}$) using $Comm_{R_{LAST}}$.
 
- Prove labeling for all challenged labels $e{_\chi}^{(l))} for $l = 1, 2, .. L$.
- Prove encoding for all challenged nodes $e{_\chi}^{(L+1))}$.

* Opening Commitments for Online Proof
To prove encoding for a challenged label $C$ in the replica:
- Reveal $Comm_C$ (which must have been stored along with the replica).
- Open $Comm_{R_{LAST}}$ from provided $Comm_R$ by proving that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.
- Provide a merkle proof $e_C^{(L)} \rightarrow Comm_{R_{LAST}}$.
