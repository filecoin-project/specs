<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <title>Filecoin Spec</title>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in §N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .assertion  for assertions                    (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/******************************************************************************/
/*                                   Body                                     */
/******************************************************************************/

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;               /* limit line length to 50em for readability   */
		margin: 0 auto;                /* center text within page                     */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag     */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		/* Colors */
		color: black;
		background: white top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		color: white;
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		border-color: #c00;
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 2;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
			color: black;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			background: white;
			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;
			background: white;
		}
		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		#toc-nav > a:hover,
		#toc-nav > a:focus {
			background: #f8f8f8;
		}
		#toc-nav > a:not(:hover):not(:focus) {
			color: #707070;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}

		#toc-toggle-inline {
			vertical-align: 0.05em;
			font-size: 80%;
			color: gray;
			color: hsla(203,20%,40%,.7);
			border-style: none;
			background: transparent;
			position: relative;
		}
		#toc-toggle-inline:hover:not(:active),
		#toc-toggle-inline:focus:not(:active) {
			text-shadow: 1px 1px silver;
			top: -1px;
			left: -1px;
		}

		#toc-nav :active {
			color: #C00;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;    /* Inherit the font family. */
		line-height: 1.2;        /* Keep wrapped headings compact */
		hyphens: manual;         /* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		background: transparent;
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#subtitle {
		/* #subtitle is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	 border-left: 0.5em solid #DEF;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	  padding: .5em;
	  border: thin solid #ddd; border-radius: .5em;
	  margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	  margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	  margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	 margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	 margin-left: -2em;
	}
	dl.switch {
	 padding-left: 2em;
	}
	dl.switch > dt {
	 text-indent: -1.5em;
	 margin-top: 1em;
	}
	dl.switch > dt + dt {
	 margin-top: 0;
	}
	dl.switch > dt::before {
	 content: '\21AA';
	 padding: 0 0.5em 0 0;
	 display: inline-block;
	 width: 1em;
	 text-align: right;
	 line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: medium;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del { color: red;  text-decoration: line-through; }
	ins { color: #080; text-decoration: underline;    }

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		page-break-inside: avoid;
		hyphens: none;
		text-transform: none;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

  /* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		text-decoration: none;
		border-bottom: 1px solid #707070;
		/* Need a bit of extending for it to look okay */
		padding: 0 1px 0;
		margin: 0 -1px 0;
	}
	a:visited {
		border-bottom-color: #BBB;
	}

	/* Use distinguishing colors when user is interacting with the link */
	a[href]:focus,
	a[href]:hover {
		background: #f8f8f8;
		background: rgba(75%, 75%, 75%, .25);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	a[href]:active {
		color: #C00;
		border-color: #C00;
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	/* For autogen numbers, add
	   .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,    .sidefigure img,    figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote {
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	.issue,
	.note,
	.example,
	.advisement,
	.assertion,
	blockquote {
		margin: 1em auto;
	}
	.note  > p:first-child,
	.issue > p:first-child,
	blockquote > :first-child {
		margin-top: 0;
	}
	blockquote > :last-child {
		margin-bottom: 0;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #E05252;
		background: #FBE9E9;
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		text-transform: uppercase;
		color: #AE1E1E;
		padding-right: 1em;
		text-transform: uppercase;
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	   or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #E0CB52;
		background: #FCFAEE;
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		text-transform: uppercase;
		color: #827017;
		min-width: 7.5em;
		display: block;
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	   or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52E052;
		background: #E9FBE9;
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary::before,
	details.note > summary > .marker {
		text-transform: uppercase;
		display: block;
		color: hsl(120, 70%, 30%);
	}
	/* Add .note::before { content: "Note"; } for autogen label,
	   or use class="marker" to mark up the label in source. */

	details.note > summary {
		display: block;
		color: hsl(120, 70%, 30%);
	}
	details.note[open] > summary {
		border-bottom: 1px silver solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		background: #EEE;
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-style: none solid;
		background: #FFEECC;
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement > .marker {
		color: #B35F00;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: #fdd;
		color: red;
		font-weight: bold;
		padding: .75em 1em;
		border: thick red;
		border-style: solid;
		border-radius: 1em;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 1em;
		right: 1em;
		bottom: 1em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #DEF;
		margin: 1.2em 0;
		border-left: 0.5em solid #8CCBF2;
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def           td.footnote {
		padding-top: 0.6em;
	}
	table.def           td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		 <table class="data"> highlights structural relationships in a table
		 when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		 Use class="complex data" for particularly complicated tables --
		 (This will draw more lines: busier, but clearer.)

		 Use class="long" on table cells with paragraph-like contents
		 (This will adjust text alignment accordingly.)
		 Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
	 vertical-align: baseline;
	 text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding-top: 0.1rem;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Reverse color scheme */
		color: black;
		border-color: #3980B5;
		border-bottom-width: 3px !important;
		margin-bottom: 0px !important;
	}
	.toc a:visited {
		border-color: #054572;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
		line-height: 1.1rem; /* consistent spacing */
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li             { font-weight: bold;   }
	.toc > li li          { font-weight: normal; }
	.toc > li li li       { font-size:   95%;    }
	.toc > li li li li    { font-size:   90%;    }
	.toc > li li li li .secno { font-size: 85%; }
	.toc > li li li li li { font-size:   85%;    }
	.toc > li li li li li .secno { font-size: 100%; }

	/* @supports not (display:grid) { */
		.toc > li             { margin: 1.5rem 0;    }
		.toc > li li          { margin: 0.3rem 0;    }
		.toc > li li li       { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}

		.toc li {
			clear: both;
		}

		:not(li) > .toc              { margin-left:  5rem; }
		.toc .secno                  { margin-left: -5rem; }
		.toc > li li li .secno       { margin-left: -7rem; }
		.toc > li li li li .secno    { margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc              { margin-left:  4rem; }
			.toc .secno                  { margin-left: -4rem; }
			.toc > li li li              { margin-left:  1rem; }
			.toc > li li li .secno       { margin-left: -5rem; }
			.toc > li li li li .secno    { margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
	/* } */

	@supports (display:grid) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			   comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
		}
		#toc .content:hover {
			background: rgba(75%, 75%, 75%, .25);
			border-bottom: 3px solid #054572;
			margin-bottom: -3px;
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index       { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li    { margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em }
	ul.index dl    { margin-top: 0; }
	ul.index dt    { margin: .2em 0 .2em 20px;}
	ul.index dd    { margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		background: #f7f8f9;
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}

/******************************************************************************/
/*                                    Legacy                                  */
/******************************************************************************/

	/* This rule is inherited from past style sheets. No idea what it's for. */
	.hide { display: none }



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-left: calc(13px + 26.5rem - 50vw);
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-left: calc(40em - 50vw) !important;
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-left: 0 !important;
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			 * http://lea.verou.me/2012/04/background-attachment-local/
			 *
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
			            top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
			            top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
  <meta content="Bikeshed version 26b7f85c77076bbd6f3130b147cbf6aec50bb06d" name="generator">
  <link href="https://github.com/filecoin-project/spec" rel="canonical">
  <meta content="2494f819e362d6df4e0fc1c8c929f1054caa03ff" name="document-revision">
<style>/* style-md-lists */

/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}</style>
<style>/* style-counters */

body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}</style>
<style>/* style-syntax-highlighting */

.highlight:not(.idl) { background: hsl(24, 20%, 95%); }
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */
</style>
<style>/* style-selflinks */

.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: gray;
    color: white;
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: black;
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }</style>
<style>/* style-autolinks */

.css.css, .property.property, .descriptor.descriptor {
    color: #005a9c;
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">Filecoin Spec</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="subtitle"><span class="content">Living Standard, <time class="dt-updated" datetime="2019-03-18">18 March 2019</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>This version:
     <dd><a class="u-url" href="https://github.com/filecoin-project/spec">https://github.com/filecoin-project/spec</a>
     <dt>Issue Tracking:
     <dd><a href="https://github.com/filecoin-project/spec/issues/">GitHub</a>
     <dt class="editor">Editor:
     <dd class="editor p-author h-card vcard"><span class="p-name fn">Filecoin Team</span>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <p class="copyright" data-fill-with="copyright"><a href="http://creativecommons.org/publicdomain/zero/1.0/" rel="license"><img alt="CC0" src="https://licensebuttons.net/p/zero/1.0/80x15.png"></a> To the extent possible under law, the editors have waived all copyright
and related or neighboring rights to this work.
In addition, as of 18 March 2019,
the editors have made this specification available under the <a href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0" rel="license">Open Web Foundation Agreement Version 1.0</a>,
which is available at http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.
Parts of this work may be from another specification document.  If so, those parts are instead covered by the license of that specification document. </p>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>Filecoin is a distributed storage network, with shared state persisted to a blockchain.</p>
  </div>
  <div data-fill-with="at-risk"></div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li>
     <a href="#intro"><span class="secno">1</span> <span class="content">Intro</span></a>
     <ol class="toc">
      <li><a href="#style"><span class="secno">1.1</span> <span class="content">Style</span></a>
      <li><a href="#overview"><span class="secno">1.2</span> <span class="content">Overview</span></a>
      <li><a href="#message-transport"><span class="secno">1.3</span> <span class="content">Message Transport</span></a>
     </ol>
    <li>
     <a href="#spec-process-v0"><span class="secno">2</span> <span class="content">Spec Process (v0)</span></a>
     <ol class="toc">
      <li><a href="#catch-up-mode"><span class="secno">2.1</span> <span class="content">'Catch Up' Mode</span></a>
      <li>
       <a href="#proposals---drafts---spec"><span class="secno">2.2</span> <span class="content">Proposals -> Drafts -> Spec</span></a>
       <ol class="toc">
        <li><a href="#on-merging"><span class="secno">2.2.1</span> <span class="content">On merging</span></a>
        <li><a href="#issues"><span class="secno">2.2.2</span> <span class="content">Issues</span></a>
       </ol>
     </ol>
    <li>
     <a href="#node-operation"><span class="secno">3</span> <span class="content">Node Operation</span></a>
     <ol class="toc">
      <li><a href="#chain-validation"><span class="secno">3.1</span> <span class="content">Chain Validation</span></a>
      <li><a href="#mempool-maintenance"><span class="secno">3.2</span> <span class="content">MemPool Maintenance</span></a>
      <li><a href="#handshaking"><span class="secno">3.3</span> <span class="content">Handshaking</span></a>
      <li><a href="#dht-for-peer-routing"><span class="secno">3.4</span> <span class="content">DHT for Peer Routing</span></a>
      <li><a href="#bitswap-for-data-requests"><span class="secno">3.5</span> <span class="content">Bitswap for data requests</span></a>
      <li>
       <a href="#mining"><span class="secno">3.6</span> <span class="content">Mining</span></a>
       <ol class="toc">
        <li>
         <a href="#storage"><span class="secno">3.6.1</span> <span class="content">Storage</span></a>
         <ol class="toc">
          <li><a href="#accept-deals"><span class="secno">3.6.1.1</span> <span class="content">Accept Deals</span></a>
          <li><a href="#prove-storage"><span class="secno">3.6.1.2</span> <span class="content">Prove Storage</span></a>
          <li><a href="#extend-the-blockchain"><span class="secno">3.6.1.3</span> <span class="content">Extend the Blockchain</span></a>
         </ol>
        <li><a href="#retrieval"><span class="secno">3.6.2</span> <span class="content">Retrieval</span></a>
       </ol>
     </ol>
    <li>
     <a href="#chain-syncing"><span class="secno">4</span> <span class="content">Chain Syncing</span></a>
     <ol class="toc">
      <li><a href="#what-is-chain-syncing-in-filecoin"><span class="secno">4.1</span> <span class="content">What is chain syncing in Filecoin?</span></a>
      <li><a href="#interface"><span class="secno">4.2</span> <span class="content">Interface</span></a>
      <li><a href="#syncing-mode"><span class="secno">4.3</span> <span class="content">Syncing Mode</span></a>
      <li><a href="#caught-up-mode"><span class="secno">4.4</span> <span class="content">Caught Up Mode</span></a>
      <li><a href="#dependencies"><span class="secno">4.5</span> <span class="content">Dependencies</span></a>
      <li><a href="#open-questions"><span class="secno">4.6</span> <span class="content">Open Questions</span></a>
      <li><a href="#chain-validation①"><span class="secno">4.7</span> <span class="content">Chain Validation</span></a>
     </ol>
    <li>
     <a href="#storage-market"><span class="secno">5</span> <span class="content">Storage Market</span></a>
     <ol class="toc">
      <li>
       <a href="#what-is-the-filecoin-storage-market"><span class="secno">5.1</span> <span class="content">What is the Filecoin Storage Market</span></a>
       <ol class="toc">
        <li><a href="#visualization-of-the-filecoin-storage-market"><span class="secno">5.1.1</span> <span class="content">Visualization of the Filecoin Storage Market</span></a>
       </ol>
      <li><a href="#the-market-interface"><span class="secno">5.2</span> <span class="content">The Market Interface</span></a>
      <li>
       <a href="#the-filecoin-storage-market-operation"><span class="secno">5.3</span> <span class="content">The Filecoin Storage Market Operation</span></a>
       <ol class="toc">
        <li><a href="#market-datastructures"><span class="secno">5.3.1</span> <span class="content">Market Datastructures</span></a>
       </ol>
      <li>
       <a href="#market-flow"><span class="secno">5.4</span> <span class="content">Market Flow</span></a>
       <ol class="toc">
        <li><a href="#before-deal"><span class="secno">5.4.1</span> <span class="content">Before Deal</span></a>
        <li><a href="#deal"><span class="secno">5.4.2</span> <span class="content">Deal</span></a>
       </ol>
      <li>
       <a href="#the-power-table"><span class="secno">5.5</span> <span class="content">The Power Table</span></a>
       <ol class="toc">
        <li><a href="#power-updates"><span class="secno">5.5.1</span> <span class="content">Power Updates</span></a>
       </ol>
      <li><a href="#payments"><span class="secno">5.6</span> <span class="content">Payments</span></a>
      <li><a href="#future-protocol-improvements"><span class="secno">5.7</span> <span class="content">Future Protocol Improvements</span></a>
      <li><a href="#open-questions①"><span class="secno">5.8</span> <span class="content">Open questions</span></a>
     </ol>
    <li>
     <a href="#retrieval-market-v0"><span class="secno">6</span> <span class="content"><code>Retrieval Market</code> V0</span></a>
     <ol class="toc">
      <li><a href="#what-is-the-retrieval-market"><span class="secno">6.1</span> <span class="content">What is the <code>Retrieval Market</code></span></a>
      <li><a href="#what-the-retrieval-market-affects"><span class="secno">6.2</span> <span class="content">What the <code>Retrieval Market</code> affects</span></a>
      <li><a href="#dependencies①"><span class="secno">6.3</span> <span class="content">Dependencies</span></a>
      <li><a href="#components"><span class="secno">6.4</span> <span class="content">Components</span></a>
      <li><a href="#retrieval-v0-libp2p-services"><span class="secno">6.5</span> <span class="content">Retrieval V0 <code>libp2p</code> Services</span></a>
      <li><a href="#chain-based-content-routing"><span class="secno">6.6</span> <span class="content">Chain Based Content Routing</span></a>
      <li><a href="#retrieval-market-commands"><span class="secno">6.7</span> <span class="content">Retrieval Market Commands</span></a>
     </ol>
    <li>
     <a href="#payments①"><span class="secno">7</span> <span class="content">Payments</span></a>
     <ol class="toc">
      <li><a href="#what-are-payments"><span class="secno">7.1</span> <span class="content">What are payments</span></a>
      <li><a href="#what-payments-affect"><span class="secno">7.2</span> <span class="content">What payments affect</span></a>
      <li><a href="#dependencies②"><span class="secno">7.3</span> <span class="content">Dependencies</span></a>
      <li><a href="#miners-claiming-earnings"><span class="secno">7.4</span> <span class="content">Miners Claiming Earnings</span></a>
      <li>
       <a href="#payment-channels"><span class="secno">7.5</span> <span class="content">Payment Channels</span></a>
       <ol class="toc">
        <li><a href="#simple-payment-channel-actor"><span class="secno">7.5.1</span> <span class="content">Simple Payment Channel Actor</span></a>
        <li><a href="#multi-lane-payment-channel-wip"><span class="secno">7.5.2</span> <span class="content">Multi-Lane Payment Channel (WIP)</span></a>
        <li><a href="#payment-channel-reconciliation"><span class="secno">7.5.3</span> <span class="content">Payment Channel Reconciliation</span></a>
       </ol>
     </ol>
    <li>
     <a href="#payment-reconciliation"><span class="secno">8</span> <span class="content">Payment Reconciliation</span></a>
     <ol class="toc">
      <li><a href="#storage-miner-payments"><span class="secno">8.1</span> <span class="content">Storage Miner Payments</span></a>
     </ol>
    <li>
     <a href="#mining①"><span class="secno">9</span> <span class="content">Mining</span></a>
     <ol class="toc">
      <li><a href="#what-is-the-filecoin-mining-process"><span class="secno">9.1</span> <span class="content">What is the Filecoin Mining Process</span></a>
      <li>
       <a href="#the-miner-actor"><span class="secno">9.2</span> <span class="content">The Miner Actor</span></a>
       <ol class="toc">
        <li><a href="#owner-worker-distinction"><span class="secno">9.2.1</span> <span class="content">Owner Worker distinction</span></a>
        <li>
         <a href="#storage-mining-cycle"><span class="secno">9.2.2</span> <span class="content">Storage Mining Cycle</span></a>
         <ol class="toc">
          <li><a href="#step-0-registration"><span class="secno">9.2.2.1</span> <span class="content">Step 0: Registration</span></a>
          <li><a href="#step-1-commit"><span class="secno">9.2.2.2</span> <span class="content">Step 1: Commit</span></a>
          <li><a href="#step-2-proving-storage-post-creation"><span class="secno">9.2.2.3</span> <span class="content">Step 2: Proving Storage (PoSt creation)</span></a>
          <li><a href="#step-3-post-submission"><span class="secno">9.2.2.4</span> <span class="content">Step 3: PoSt Submission</span></a>
         </ol>
        <li><a href="#stop-mining"><span class="secno">9.2.3</span> <span class="content">Stop Mining</span></a>
        <li><a href="#faults"><span class="secno">9.2.4</span> <span class="content">Faults</span></a>
        <li><a href="#on-being-slashed-wip-needs-discussion"><span class="secno">9.2.5</span> <span class="content">On Being Slashed (WIP, needs discussion)</span></a>
       </ol>
      <li>
       <a href="#mining-blocks"><span class="secno">9.3</span> <span class="content">Mining Blocks</span></a>
       <ol class="toc">
        <li><a href="#receiving-blocks"><span class="secno">9.3.1</span> <span class="content">Receiving Blocks</span></a>
        <li><a href="#block-validation"><span class="secno">9.3.2</span> <span class="content">Block Validation</span></a>
        <li><a href="#ticket-generation"><span class="secno">9.3.3</span> <span class="content">Ticket Generation</span></a>
        <li><a href="#scratching-a-losing-ticket"><span class="secno">9.3.4</span> <span class="content">Scratching a losing ticket</span></a>
        <li>
         <a href="#block-creation"><span class="secno">9.3.5</span> <span class="content">Block Creation</span></a>
         <ol class="toc">
          <li><a href="#block-broadcast"><span class="secno">9.3.5.1</span> <span class="content">Block Broadcast</span></a>
         </ol>
        <li><a href="#block-rewards"><span class="secno">9.3.6</span> <span class="content">Block Rewards</span></a>
       </ol>
      <li><a href="#open-questions②"><span class="secno">9.4</span> <span class="content">Open Questions</span></a>
      <li><a href="#future-work"><span class="secno">9.5</span> <span class="content">Future Work</span></a>
     </ol>
    <li>
     <a href="#expected-consensus"><span class="secno">10</span> <span class="content">Expected Consensus</span></a>
     <ol class="toc">
      <li>
       <a href="#secret-leader-election"><span class="secno">10.1</span> <span class="content">Secret Leader Election</span></a>
       <ol class="toc">
        <li>
         <a href="#tickets"><span class="secno">10.1.1</span> <span class="content">Tickets</span></a>
         <ol class="toc">
          <li><a href="#ticket-generation①"><span class="secno">10.1.1.1</span> <span class="content">Ticket generation</span></a>
          <li><a href="#checking-election-results"><span class="secno">10.1.1.2</span> <span class="content">Checking election results</span></a>
         </ol>
        <li><a href="#losing-tickets"><span class="secno">10.1.2</span> <span class="content">Losing Tickets</span></a>
        <li><a href="#block-generation"><span class="secno">10.1.3</span> <span class="content">Block Generation</span></a>
       </ol>
      <li>
       <a href="#chain-selection"><span class="secno">10.2</span> <span class="content">Chain Selection</span></a>
       <ol class="toc">
        <li><a href="#tipsets"><span class="secno">10.2.1</span> <span class="content">Tipsets</span></a>
        <li><a href="#chain-weighting"><span class="secno">10.2.2</span> <span class="content">Chain Weighting</span></a>
        <li><a href="#slashing"><span class="secno">10.2.3</span> <span class="content">Slashing</span></a>
       </ol>
      <li><a href="#implementation-notes"><span class="secno">10.3</span> <span class="content">Implementation Notes</span></a>
      <li><a href="#open-questions③"><span class="secno">10.4</span> <span class="content">Open Questions</span></a>
     </ol>
    <li>
     <a href="#state-machine"><span class="secno">11</span> <span class="content">State Machine</span></a>
     <ol class="toc">
      <li><a href="#method-invocation"><span class="secno">11.1</span> <span class="content">Method Invocation</span></a>
      <li><a href="#state-representation"><span class="secno">11.2</span> <span class="content">State Representation</span></a>
      <li>
       <a href="#execution-calling-a-method-on-an-actor"><span class="secno">11.3</span> <span class="content">Execution (Calling a method on an Actor)</span></a>
       <ol class="toc">
        <li><a href="#receipts"><span class="secno">11.3.1</span> <span class="content">Receipts</span></a>
        <li><a href="#storage①"><span class="secno">11.3.2</span> <span class="content">Storage</span></a>
       </ol>
     </ol>
    <li>
     <a href="#state-machine-actors"><span class="secno">12</span> <span class="content">State Machine Actors</span></a>
     <ol class="toc">
      <li>
       <a href="#storage-market-actor"><span class="secno">12.1</span> <span class="content">Storage Market Actor</span></a>
       <ol class="toc">
        <li><a href="#createstorageminer"><span class="secno">12.1.1</span> <span class="content">CreateStorageMiner</span></a>
        <li><a href="#slashconsensusfault"><span class="secno">12.1.2</span> <span class="content">SlashConsensusFault</span></a>
        <li><a href="#updatestorage"><span class="secno">12.1.3</span> <span class="content">UpdateStorage</span></a>
        <li><a href="#gettotalstorage"><span class="secno">12.1.4</span> <span class="content">GetTotalStorage</span></a>
       </ol>
      <li>
       <a href="#storage-miner-actor"><span class="secno">12.2</span> <span class="content">Storage Miner Actor</span></a>
       <ol class="toc">
        <li><a href="#constructor"><span class="secno">12.2.1</span> <span class="content">Constructor</span></a>
        <li><a href="#addask"><span class="secno">12.2.2</span> <span class="content">AddAsk</span></a>
        <li><a href="#commitsector"><span class="secno">12.2.3</span> <span class="content">CommitSector</span></a>
        <li><a href="#submitpost"><span class="secno">12.2.4</span> <span class="content">SubmitPoSt</span></a>
        <li><a href="#increasepledge"><span class="secno">12.2.5</span> <span class="content">IncreasePledge</span></a>
        <li><a href="#slashstoragefault"><span class="secno">12.2.6</span> <span class="content">SlashStorageFault</span></a>
        <li><a href="#getcurrentprovingset"><span class="secno">12.2.7</span> <span class="content">GetCurrentProvingSet</span></a>
        <li><a href="#arbitratedeal"><span class="secno">12.2.8</span> <span class="content">ArbitrateDeal</span></a>
        <li><a href="#depledge"><span class="secno">12.2.9</span> <span class="content">DePledge</span></a>
        <li><a href="#getowner"><span class="secno">12.2.10</span> <span class="content">GetOwner</span></a>
        <li><a href="#getworkeraddr"><span class="secno">12.2.11</span> <span class="content">GetWorkerAddr</span></a>
        <li><a href="#getpower"><span class="secno">12.2.12</span> <span class="content">GetPower</span></a>
        <li><a href="#getkey"><span class="secno">12.2.13</span> <span class="content">GetKey</span></a>
        <li><a href="#getpeerid"><span class="secno">12.2.14</span> <span class="content">GetPeerID</span></a>
        <li><a href="#updatepeerid"><span class="secno">12.2.15</span> <span class="content">UpdatePeerID</span></a>
       </ol>
      <li><a href="#payment-channel-broker-actor"><span class="secno">12.3</span> <span class="content">Payment Channel Broker Actor</span></a>
     </ol>
    <li>
     <a href="#faults①"><span class="secno">13</span> <span class="content">Faults</span></a>
     <ol class="toc">
      <li>
       <a href="#fault-list"><span class="secno">13.1</span> <span class="content">Fault List</span></a>
       <ol class="toc">
        <li><a href="#consensus-faults"><span class="secno">13.1.1</span> <span class="content">Consensus Faults</span></a>
        <li><a href="#market-faults"><span class="secno">13.1.2</span> <span class="content">Market Faults</span></a>
       </ol>
     </ol>
    <li>
     <a href="#signatures"><span class="secno">14</span> <span class="content">Signatures</span></a>
     <ol class="toc">
      <li><a href="#what-are-signatures-in-filecoin"><span class="secno">14.1</span> <span class="content">What are signatures in Filecoin</span></a>
      <li><a href="#what-signatures-affect"><span class="secno">14.2</span> <span class="content">What signatures affect</span></a>
      <li><a href="#dependencies③"><span class="secno">14.3</span> <span class="content">Dependencies</span></a>
      <li><a href="#non-dependencies"><span class="secno">14.4</span> <span class="content">Non-Dependencies</span></a>
      <li><a href="#interface①"><span class="secno">14.5</span> <span class="content">Interface</span></a>
      <li>
       <a href="#selected-signature-scheme"><span class="secno">14.6</span> <span class="content">Selected Signature Scheme</span></a>
       <ol class="toc">
        <li><a href="#wire-format"><span class="secno">14.6.1</span> <span class="content">Wire Format</span></a>
        <li><a href="#github"><span class="secno">14.6.2</span> <span class="content">Github</span></a>
        <li><a href="#external-references"><span class="secno">14.6.3</span> <span class="content">External References</span></a>
        <li><a href="#references"><span class="secno">14.6.4</span> <span class="content">References</span></a>
        <li><a href="#inspiration"><span class="secno">14.6.5</span> <span class="content">Inspiration</span></a>
       </ol>
     </ol>
    <li>
     <a href="#proofs"><span class="secno">15</span> <span class="content">Proofs</span></a>
     <ol class="toc">
      <li><a href="#proof-of-replication"><span class="secno">15.1</span> <span class="content">Proof of Replication</span></a>
      <li>
       <a href="#seal"><span class="secno">15.2</span> <span class="content">Seal</span></a>
       <ol class="toc">
        <li><a href="#verifyseal"><span class="secno">15.2.1</span> <span class="content">VerifySeal</span></a>
        <li><a href="#unseal"><span class="secno">15.2.2</span> <span class="content">Unseal</span></a>
        <li>
         <a href="#security-notes"><span class="secno">15.2.3</span> <span class="content">Security Notes</span></a>
         <ol class="toc">
          <li><a href="#guaranteeing-sector-uniqueness"><span class="secno">15.2.3.1</span> <span class="content">Guaranteeing sector uniqueness</span></a>
         </ol>
       </ol>
      <li>
       <a href="#proof-of-space-time"><span class="secno">15.3</span> <span class="content">Proof of Space-Time</span></a>
       <ol class="toc">
        <li><a href="#generatepost"><span class="secno">15.3.1</span> <span class="content">GeneratePost</span></a>
        <li><a href="#verifypost"><span class="secno">15.3.2</span> <span class="content">VerifyPoSt</span></a>
       </ol>
      <li>
       <a href="#piece-inclusion-proof"><span class="secno">15.4</span> <span class="content">Piece Inclusion Proof</span></a>
       <ol class="toc">
        <li><a href="#pieceinclusionproof"><span class="secno">15.4.1</span> <span class="content">PieceInclusionProof</span></a>
        <li><a href="#generatepieceinclusionproofs"><span class="secno">15.4.2</span> <span class="content">GeneratePieceInclusionProofs</span></a>
       </ol>
     </ol>
    <li>
     <a href="#filecoin-network-protocols"><span class="secno">16</span> <span class="content">Filecoin Network Protocols</span></a>
     <ol class="toc">
      <li><a href="#cbor-rpc"><span class="secno">16.1</span> <span class="content">CBOR RPC</span></a>
      <li><a href="#hello-handshake"><span class="secno">16.2</span> <span class="content">Hello Handshake</span></a>
      <li>
       <a href="#storage-deal"><span class="secno">16.3</span> <span class="content">Storage Deal</span></a>
       <ol class="toc">
        <li><a href="#deal-state-values"><span class="secno">16.3.1</span> <span class="content">Deal State Values</span></a>
       </ol>
      <li><a href="#query"><span class="secno">16.4</span> <span class="content">Query</span></a>
      <li><a href="#retrieve-piece-for-free"><span class="secno">16.5</span> <span class="content">Retrieve Piece for Free</span></a>
      <li><a href="#blocksync"><span class="secno">16.6</span> <span class="content">BlockSync</span></a>
     </ol>
    <li>
     <a href="#filecoin-data-propagation"><span class="secno">17</span> <span class="content">Filecoin Data Propagation</span></a>
     <ol class="toc">
      <li><a href="#links"><span class="secno">17.1</span> <span class="content">Links</span></a>
      <li><a href="#block-propagation"><span class="secno">17.2</span> <span class="content">Block Propagation</span></a>
      <li><a href="#message-propagation"><span class="secno">17.3</span> <span class="content">Message Propagation</span></a>
     </ol>
    <li>
     <a href="#data-structures"><span class="secno">18</span> <span class="content">Data Structures</span></a>
     <ol class="toc">
      <li><a href="#address"><span class="secno">18.1</span> <span class="content">Address</span></a>
      <li><a href="#cid"><span class="secno">18.2</span> <span class="content">CID</span></a>
      <li>
       <a href="#block"><span class="secno">18.3</span> <span class="content">Block</span></a>
       <ol class="toc">
        <li><a href="#serialization"><span class="secno">18.3.1</span> <span class="content">Serialization</span></a>
       </ol>
      <li>
       <a href="#message"><span class="secno">18.4</span> <span class="content">Message</span></a>
       <ol class="toc">
        <li><a href="#parameter-encoding"><span class="secno">18.4.1</span> <span class="content">Parameter Encoding</span></a>
        <li><a href="#signing"><span class="secno">18.4.2</span> <span class="content">Signing</span></a>
        <li><a href="#serialization①"><span class="secno">18.4.3</span> <span class="content">Serialization</span></a>
       </ol>
      <li>
       <a href="#message-receipt"><span class="secno">18.5</span> <span class="content">Message Receipt</span></a>
       <ol class="toc">
        <li><a href="#serialization②"><span class="secno">18.5.1</span> <span class="content">Serialization</span></a>
       </ol>
      <li>
       <a href="#actor"><span class="secno">18.6</span> <span class="content">Actor</span></a>
       <ol class="toc">
        <li><a href="#serialization③"><span class="secno">18.6.1</span> <span class="content">Serialization</span></a>
       </ol>
      <li><a href="#state-tree"><span class="secno">18.7</span> <span class="content">State Tree</span></a>
      <li><a href="#hamt"><span class="secno">18.8</span> <span class="content">HAMT</span></a>
      <li>
       <a href="#basic-type-encodings"><span class="secno">18.9</span> <span class="content">Basic Type Encodings</span></a>
       <ol class="toc">
        <li><a href="#publickey"><span class="secno">18.9.1</span> <span class="content"><code>PublicKey</code></span></a>
        <li><a href="#bytesamount"><span class="secno">18.9.2</span> <span class="content"><code>BytesAmount</code></span></a>
        <li><a href="#peerid"><span class="secno">18.9.3</span> <span class="content"><code>PeerID</code></span></a>
        <li><a href="#integer"><span class="secno">18.9.4</span> <span class="content"><code>Integer</code></span></a>
        <li><a href="#bitfield"><span class="secno">18.9.5</span> <span class="content"><code>BitField</code></span></a>
        <li><a href="#sectorset"><span class="secno">18.9.6</span> <span class="content"><code>SectorSet</code></span></a>
        <li><a href="#faultset"><span class="secno">18.9.7</span> <span class="content"><code>FaultSet</code></span></a>
        <li><a href="#blockheader"><span class="secno">18.9.8</span> <span class="content"><code>BlockHeader</code></span></a>
        <li><a href="#sealproof"><span class="secno">18.9.9</span> <span class="content"><code>SealProof</code></span></a>
        <li><a href="#tokenamount"><span class="secno">18.9.10</span> <span class="content"><code>TokenAmount</code></span></a>
       </ol>
      <li>
       <a href="#leb128-encoding-reference"><span class="secno">18.10</span> <span class="content">LEB128 Encoding Reference</span></a>
       <ol class="toc">
        <li><a href="#encode-unsigned-leb128"><span class="secno">18.10.1</span> <span class="content">Encode unsigned LEB128</span></a>
        <li><a href="#encode-signed-leb128"><span class="secno">18.10.2</span> <span class="content">Encode signed LEB128</span></a>
        <li><a href="#decode-unsigned-leb128"><span class="secno">18.10.3</span> <span class="content">Decode unsigned LEB128</span></a>
        <li><a href="#decode-signed-leb128"><span class="secno">18.10.4</span> <span class="content">Decode signed LEB128</span></a>
       </ol>
     </ol>
    <li>
     <a href="#filecoin-node-local-storage"><span class="secno">19</span> <span class="content">Filecoin Node Local Storage</span></a>
     <ol class="toc">
      <li><a href="#chain-data"><span class="secno">19.1</span> <span class="content">Chain Data</span></a>
      <li><a href="#private-keys"><span class="secno">19.2</span> <span class="content">Private Keys</span></a>
      <li><a href="#sectors"><span class="secno">19.3</span> <span class="content">Sectors</span></a>
      <li><a href="#storage-deals"><span class="secno">19.4</span> <span class="content">Storage Deals</span></a>
     </ol>
    <li>
     <a href="#glossary"><span class="secno">20</span> <span class="content">Glossary</span></a>
     <ol class="toc">
      <li><a href="#updates-to-definitions"><span class="secno">20.1</span> <span class="content">Updates to definitions</span></a>
      <li><a href="#notes"><span class="secno">20.2</span> <span class="content">Notes</span></a>
      <li>
       <a href="#definitions"><span class="secno">20.3</span> <span class="content">Definitions</span></a>
       <ol class="toc">
        <li><a href="#actor①"><span class="secno">20.3.1</span> <span class="content">Actor</span></a>
        <li><a href="#address①"><span class="secno">20.3.2</span> <span class="content">Address</span></a>
        <li><a href="#ask"><span class="secno">20.3.3</span> <span class="content">Ask</span></a>
        <li><a href="#bid"><span class="secno">20.3.4</span> <span class="content">Bid</span></a>
        <li><a href="#block①"><span class="secno">20.3.5</span> <span class="content">Block</span></a>
        <li><a href="#bootstrapping"><span class="secno">20.3.6</span> <span class="content">Bootstrapping</span></a>
        <li><a href="#chain-weight"><span class="secno">20.3.7</span> <span class="content">Chain weight</span></a>
        <li><a href="#challenge-sampling"><span class="secno">20.3.8</span> <span class="content">Challenge sampling</span></a>
        <li><a href="#cid①"><span class="secno">20.3.9</span> <span class="content">Cid</span></a>
        <li><a href="#client"><span class="secno">20.3.10</span> <span class="content">Client</span></a>
        <li><a href="#collateral"><span class="secno">20.3.11</span> <span class="content">Collateral</span></a>
        <li><a href="#commitment"><span class="secno">20.3.12</span> <span class="content">Commitment</span></a>
        <li><a href="#confirmation"><span class="secno">20.3.13</span> <span class="content">Confirmation</span></a>
        <li><a href="#consensus"><span class="secno">20.3.14</span> <span class="content">Consensus</span></a>
        <li><a href="#deal①"><span class="secno">20.3.15</span> <span class="content">Deal</span></a>
        <li><a href="#erasure-coding"><span class="secno">20.3.16</span> <span class="content">Erasure coding</span></a>
        <li><a href="#epoch"><span class="secno">20.3.17</span> <span class="content">Epoch</span></a>
        <li><a href="#fault"><span class="secno">20.3.18</span> <span class="content">Fault</span></a>
        <li><a href="#fair"><span class="secno">20.3.19</span> <span class="content">Fair</span></a>
        <li><a href="#file"><span class="secno">20.3.20</span> <span class="content">File</span></a>
        <li><a href="#finality"><span class="secno">20.3.21</span> <span class="content">Finality</span></a>
        <li><a href="#piece-inclusion-proof①"><span class="secno">20.3.22</span> <span class="content">Piece Inclusion Proof</span></a>
        <li><a href="#gas-fees-prices"><span class="secno">20.3.23</span> <span class="content">Gas, Fees, Prices</span></a>
        <li><a href="#ghost"><span class="secno">20.3.24</span> <span class="content">GHOST</span></a>
        <li><a href="#leader"><span class="secno">20.3.25</span> <span class="content">Leader</span></a>
        <li><a href="#leader-election"><span class="secno">20.3.26</span> <span class="content">Leader election</span></a>
        <li><a href="#message①"><span class="secno">20.3.27</span> <span class="content">Message</span></a>
        <li><a href="#miner"><span class="secno">20.3.28</span> <span class="content">Miner</span></a>
        <li><a href="#node"><span class="secno">20.3.29</span> <span class="content">Node</span></a>
        <li><a href="#null-blocks"><span class="secno">20.3.30</span> <span class="content">Null Blocks</span></a>
        <li><a href="#on-chain-off-chain"><span class="secno">20.3.31</span> <span class="content">On-chain/off-chain</span></a>
        <li><a href="#online-offline"><span class="secno">20.3.32</span> <span class="content">Online/offline</span></a>
        <li><a href="#payment-channel"><span class="secno">20.3.33</span> <span class="content">Payment Channel</span></a>
        <li><a href="#piece"><span class="secno">20.3.34</span> <span class="content">Piece</span></a>
        <li><a href="#pledge"><span class="secno">20.3.35</span> <span class="content">Pledge</span></a>
        <li><a href="#power-table"><span class="secno">20.3.36</span> <span class="content">Power table</span></a>
        <li><a href="#protocol"><span class="secno">20.3.37</span> <span class="content">Protocol</span></a>
        <li><a href="#proving-period"><span class="secno">20.3.38</span> <span class="content">Proving Period</span></a>
        <li><a href="#proving-set"><span class="secno">20.3.39</span> <span class="content">Proving Set</span></a>
        <li><a href="#proof-of-replication①"><span class="secno">20.3.40</span> <span class="content">Proof of Replication</span></a>
        <li><a href="#proof-of-spacetime"><span class="secno">20.3.41</span> <span class="content">Proof of Spacetime</span></a>
        <li><a href="#random-ness"><span class="secno">20.3.42</span> <span class="content">Random(ness)</span></a>
        <li><a href="#repair"><span class="secno">20.3.43</span> <span class="content">Repair</span></a>
        <li><a href="#round"><span class="secno">20.3.44</span> <span class="content">Round</span></a>
        <li><a href="#seal-unseal"><span class="secno">20.3.45</span> <span class="content">SEAL/UNSEAL</span></a>
        <li><a href="#sector"><span class="secno">20.3.46</span> <span class="content">Sector</span></a>
        <li><a href="#slashing①"><span class="secno">20.3.47</span> <span class="content">Slashing</span></a>
        <li><a href="#smart-contracts"><span class="secno">20.3.48</span> <span class="content">Smart contracts</span></a>
        <li><a href="#storage②"><span class="secno">20.3.49</span> <span class="content">Storage</span></a>
        <li><a href="#state"><span class="secno">20.3.50</span> <span class="content">State</span></a>
        <li><a href="#ticket"><span class="secno">20.3.51</span> <span class="content">Ticket</span></a>
        <li><a href="#tip-set"><span class="secno">20.3.52</span> <span class="content">Tip Set</span></a>
        <li><a href="#verifiable"><span class="secno">20.3.53</span> <span class="content">Verifiable</span></a>
        <li><a href="#vm"><span class="secno">20.3.54</span> <span class="content">VM</span></a>
        <li><a href="#voucher"><span class="secno">20.3.55</span> <span class="content">Voucher</span></a>
        <li><a href="#zksnark"><span class="secno">20.3.56</span> <span class="content">zkSNARK</span></a>
       </ol>
     </ol>
    <li><a href="#conformance"><span class="secno"></span> <span class="content"> Conformance</span></a>
    <li>
     <a href="#references①"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#normative"><span class="secno"></span> <span class="content">Normative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Intro</span><a class="self-link" href="#intro"></a></h2>
   <p>This is the official Filecoin protocol specification. It is a work in progress. While reading, if you notice any discrepancies, or issues, please open an issue on the <a href="https://github.com/filecoin-project/specs">specs repo</a>.</p>
   <p>This collection of pages specify the protocols comprising the Filecoin network. The goal of these specs is to provide sufficient detail that another implementation, written using only this document as reference, can be fully compatible with <code>go-filecoin</code> peers, but this is still a work in progress.</p>
   <h3 class="heading settled" data-level="1.1" id="style"><span class="secno">1.1. </span><span class="content">Style</span><a class="self-link" href="#style"></a></h3>
    Any content that is written with <code>code ticks</code> has a specific definition to Filecoin and is defined in the <a href="#glossary">§20 Glossary</a>. 
   <p>Many sections of the spec use go type notation to describe the functionality of certain components. This is entirely a style preference by the authors and does not imply in any way that one must use go to implement Filecoin.</p>
   <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p>
   <h3 class="heading settled" data-level="1.2" id="overview"><span class="secno">1.2. </span><span class="content">Overview</span><a class="self-link" href="#overview"></a></h3>
   <p>Filecoin is a distributed storage network, with shared state persisted to a blockchain.</p>
   <p>The network maintains consensus over the current state of a replicated <a href="#state-machine">§11 State Machine</a> through <a href="#expected-consensus">§10 Expected Consensus</a>. This replicated state machine is used to run <a href="#storage-market">§5 Storage Market</a>. This market provides a place to buy and sell storage within the distributed network of filecoin miners. The market also provides the needed mechanisms to ensure that the data stored by the network is actually being stored as promised, without requiring client interaction.</p>
   <p>Clients interact with the system by <a href="data-propagation.md#message-propagation">sending messages</a> to the network. These messages are gathered up and included by miners in blocks. Each of these messages defines a state transition in the state machine. The simplest messages say something like "move Filecoin from <em>this</em> account under my control to <em>this</em> other account", but more complex ones describe storage sector commitments, storage deals struck, and proofs of storage.</p>
   <p>The Filecoin protocol itself is really a suite of protocols, including:</p>
   <ul>
    <li data-md>
     <p>the chain protocol for propagating the data that constitutes the blockchain</p>
    <li data-md>
     <p>the <a href="mining.md">block mining</a> protocol for producing new blocks</p>
    <li data-md>
     <p>the <a href="expected-consensus.md">consensus mechanism</a> and <a href="validation.md">rules</a> for agreeing on canonical blockchain state</p>
    <li data-md>
     <p>the <a href="storage-market.md">storage market</a> protocol for <code>storage miners</code> to sell storage and clients to purchase it</p>
    <li data-md>
     <p>the <a href="retrieval-market.md">retrieval market</a> protocol for retrieving files</p>
    <li data-md>
     <p>the <a href="payments.md">payment channel</a> channel protocol for transferring FIL tokens between actors</p>
   </ul>
   <h3 class="heading settled" data-level="1.3" id="message-transport"><span class="secno">1.3. </span><span class="content">Message Transport</span><a class="self-link" href="#message-transport"></a></h3>
   <p>Filecoin uses <a href="https://libp2p.io">libp2p</a> for all network communications. libp2p provides transport-agnostic services for peer discovery, naming, routing, pubsub channels and a distributed record store, and there are full or partial <a href="https://libp2p.io/implementations/">implementations</a> in a number of languages. This spec assumes the use of libp2p and its services and does not specify transport-level details. For more details on the exact wire protocol of libp2p, refer to the <a href="https://github.com/libp2p/specs">libp2p specs</a>.</p>
   <p>Filecoin uses <a href="https://ipld.io">IPLD</a> for the representation and serialization of the majority of the data in the system. IPLD provides a canonical model for content-addressed data structures, providing a representation of basic data objects and links between them.</p>
   <h2 class="heading settled" data-level="2" id="spec-process-v0"><span class="secno">2. </span><span class="content">Spec Process (v0)</span><a class="self-link" href="#spec-process-v0"></a></h2>
   <h3 class="heading settled" data-level="2.1" id="catch-up-mode"><span class="secno">2.1. </span><span class="content">'Catch Up' Mode</span><a class="self-link" href="#catch-up-mode"></a></h3>
   <p>Until we get to 'spec parity' where our current level of understanding of the protocol and the spec are in sync, changes will be made to the spec by a simple PR process. If something is missing, PR it in, if something is wrong, PR a fix, if something needs to be elaborated, PR in updates. What is in the top level of this repo, in master, is the spec.</p>
   <h3 class="heading settled" data-level="2.2" id="proposals---drafts---spec"><span class="secno">2.2. </span><span class="content">Proposals -> Drafts -> Spec</span><a class="self-link" href="#proposals---drafts---spec"></a></h3>
   <p>For anything that is not 'catching up' (like 'repair', for example) the process we will use is to first discuss the problem in an issue (or several issues, if the space is large and multithreaded enough). Then when someone feels like a solution is near, they will write it up as a document, and submit a PR to put it into the 'drafts' folder in the repo.</p>
   <p>'Drafts' are not canonical spec, and should not be considered for implementation. It is acceptable for a PR for a draft to stay open for quite a while, as thought and discussion on the topic happens. At some point (ideally, in two weeks or less), if the reviewers and the author feel that the current state of the draft is stable enough (though not 'done') then it should be merged into the repo. Further changes to the draft are additional PRs, which may generate more discussion. Comments on these drafts are welcome from anyone, but if you wish to be involved in the actual research process, you will need to devote very considerable time and energy to the process.</p>
   <p>Once there is agreement that the draft should be implemented, it should then get moved from the drafts folder, into the top level along with other spec documents. This process should just be a simple renaming, and should not generate any discussion. Along with the moving of that document, any interested parties in the development teams should be explicitly tagged.</p>
   <h4 class="heading settled" data-level="2.2.1" id="on-merging"><span class="secno">2.2.1. </span><span class="content">On merging</span><a class="self-link" href="#on-merging"></a></h4>
   <p>For anything in the drafts or notes folder, merge yourself after a review from a relevant person. For anything in the top level (canonical spec), @whyrusleeping will merge after proper review.</p>
   <h4 class="heading settled" data-level="2.2.2" id="issues"><span class="secno">2.2.2. </span><span class="content">Issues</span><a class="self-link" href="#issues"></a></h4>
   <p>Issues in the specs repo will be high signal, they will either be proposals, or issues directly relating to problems in the spec. More speculative research questions and discussion will happen in the research repo.</p>
   <h2 class="heading settled" data-level="3" id="node-operation"><span class="secno">3. </span><span class="content">Node Operation</span><a class="self-link" href="#node-operation"></a></h2>
   <p>Running a Filecoin <code>full node</code> requires running many different processes and protocols simultaneously. This section describes the set of things you need to do in order to run a fully validating Filecoin node.</p>
   <p>(TODO: elaborate on all this, obviously)</p>
   <h3 class="heading settled" data-level="3.1" id="chain-validation"><span class="secno">3.1. </span><span class="content">Chain Validation</span><a class="self-link" href="#chain-validation"></a></h3>
   <p><a href="validation.md">Chain validation</a> is the process by which a node stays up to date with the current state of the blockchain. This Involves:</p>
   <ul>
    <li data-md>
     <p>Listening for new blocks on the blocks pubsub channel (See <a href="data-propagation.md#block-propagation">block propagation</a>)</p>
    <li data-md>
     <p>As new blocks come in, run through the block validation process</p>
     <ul>
      <li data-md>
       <p>Keep track of valid blocks, keep track of the current 'best' block (according to EC rules)</p>
     </ul>
    <li data-md>
     <p>Rebroadcast valid blocks</p>
     <ul>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> the actual rebroadcasting is handled by the underlying gossipsub library. We simply need to signal to that library which blocks should be rebroadcast.</p>
     </ul>
   </ul>
   <h3 class="heading settled" data-level="3.2" id="mempool-maintenance"><span class="secno">3.2. </span><span class="content">MemPool Maintenance</span><a class="self-link" href="#mempool-maintenance"></a></h3>
   <p>Listen for messages on the messages pubsub channel (See <a href="data-propagation.md#message-propagation">message propagation</a>). Validate each message, rebroadcast valid ones.</p>
   <h3 class="heading settled" data-level="3.3" id="handshaking"><span class="secno">3.3. </span><span class="content">Handshaking</span><a class="self-link" href="#handshaking"></a></h3>
   <ul>
    <li data-md>
     <p>For each node you connect to, run the <a href="network-protocols.md#hello-handshake">'hello' protocol</a> with them</p>
    <li data-md>
     <p>If response shows that you and the other node have different genesis blocks, disconnect from them.</p>
    <li data-md>
     <p>If the other node gives a valid chain head that is farther ahead than you, 'sync' the chain and maybe switch to it if it’s <a href="expected-consensus.md#chain-weighing">'heavier'</a>.</p>
   </ul>
   <h3 class="heading settled" data-level="3.4" id="dht-for-peer-routing"><span class="secno">3.4. </span><span class="content">DHT for Peer Routing</span><a class="self-link" href="#dht-for-peer-routing"></a></h3>
   <ul>
    <li data-md>
     <p>Run the DHT protocol for aiding node discovery</p>
    <li data-md>
     <p>libp2p-kad-dht, with just 'find node' RPCs enabled.</p>
   </ul>
   <h3 class="heading settled" data-level="3.5" id="bitswap-for-data-requests"><span class="secno">3.5. </span><span class="content">Bitswap for data requests</span><a class="self-link" href="#bitswap-for-data-requests"></a></h3>
   <p>Run bitswap to fetch and serve data (such as messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p>
   <p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p>
   <h3 class="heading settled" data-level="3.6" id="mining"><span class="secno">3.6. </span><span class="content">Mining</span><a class="self-link" href="#mining"></a></h3>
   <h4 class="heading settled" data-level="3.6.1" id="storage"><span class="secno">3.6.1. </span><span class="content">Storage</span><a class="self-link" href="#storage"></a></h4>
   <p>To be a Filecoin storage miner means run several processes in addition to running a 'Full Node'.</p>
   <h5 class="heading settled" data-level="3.6.1.1" id="accept-deals"><span class="secno">3.6.1.1. </span><span class="content">Accept Deals</span><a class="self-link" href="#accept-deals"></a></h5>
   <p>A Filecoin storage miner should listen for, decide upon, and accept storage deals from clients. The data being stored for each of these deals should be placed into a sector, and sealed up once that sector is full. Sealed sectors are then submitted to the chain via <code>CommitSector</code>. This logic is generally abstracted away by the 'Sector Sealing Subsystem'.</p>
   <p>To accept deals, miners should run the <a href="network-protocols.md#storage-deal">'storage deal'</a> service.</p>
   <h5 class="heading settled" data-level="3.6.1.2" id="prove-storage"><span class="secno">3.6.1.2. </span><span class="content">Prove Storage</span><a class="self-link" href="#prove-storage"></a></h5>
   <p>Once miners have submitted sealed sectors to the chain, they will be on the hook for proving the data over time. Every <code>proving period</code>, miners should take their current <code>proving set</code> and call <code>post.GeneratePost</code> on it. This process will take a fairly long amount of time (TODO: either put specific parameters here, or link to them) and result in a compact Proof of SpaceTime, which must then be submitted to the chain via <code>SubmitPoSt</code></p>
   <h5 class="heading settled" data-level="3.6.1.3" id="extend-the-blockchain"><span class="secno">3.6.1.3. </span><span class="content">Extend the Blockchain</span><a class="self-link" href="#extend-the-blockchain"></a></h5>
   <p>A storage miner is also responsible for producing blocks to extend the blockchain. At every round, storage miners check to see if they are the leader, and if they are, they submit a new block to the network, earning a reward for doing so.</p>
   <p>The responsibilities of storage miners are documented in more detail in the <a href="mining.md">mining document</a></p>
   <h4 class="heading settled" data-level="3.6.2" id="retrieval"><span class="secno">3.6.2. </span><span class="content">Retrieval</span><a class="self-link" href="#retrieval"></a></h4>
   <p>To be a filecoin retrieval miner: (todo)</p>
   <h2 class="heading settled" data-level="4" id="chain-syncing"><span class="secno">4. </span><span class="content">Chain Syncing</span><a class="self-link" href="#chain-syncing"></a></h2>
   <h3 class="heading settled" data-level="4.1" id="what-is-chain-syncing-in-filecoin"><span class="secno">4.1. </span><span class="content">What is chain syncing in Filecoin?</span><a class="self-link" href="#what-is-chain-syncing-in-filecoin"></a></h3>
   <p>Chain syncing is the process a filecoin node runs to sync its internal chain state with new blocks from the network and new blocks it itself has mined.  A node syncs in two distinct modes: <code>syncing</code> and <code>caught up</code>.  Chain syncing updates both local storage of chain data and the head of the current heaviest observed chain.</p>
   <p>'Syncing' mode and 'Caught up' mode are two distinct processes. 'Syncing' mode, or 'the initial sync' is a process that is triggered when a node is far enough behind the rest of the network. This process terminates once the nodes 'head' is    sufficiently far ahead. Once 'syncing' is complete, the 'caught up' sync process begins. This process keeps the node up to date with the rest of the network, and terminates only when the node is shut down.</p>
   <h3 class="heading settled" data-level="4.2" id="interface"><span class="secno">4.2. </span><span class="content">Interface</span><a class="self-link" href="#interface"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> Syncer <c- a>struct</c-> <c- p>{</c->
	<c- c1>// The heaviest known tipset in the network.</c->
	head TipSet

	<c- c1>// The interface for accessing and putting tipsets into local storage</c->
	store ChainStore

	<c- c1>// The known genesis tipset</c->
	genesis TipSet

    <c- c1>// the current mode the syncer is in</c->
    syncMode SyncMode

	<c- c1>// TipSets known to be invalid</c->
	bad BadTipSetCache

    <c- c1>// handle to the block sync service</c->
    bsync BlockSync

    <c- c1>// peer heads</c->
    <c- c1>// Note: clear cache on disconnects</c->
    peerHeads <c- a>map</c-><c- p>[</c->PeerID<c- p>]</c->Cid
<c- p>}</c->

<c- a>const</c-> BootstrapPeerThreshold <c- p>=</c-> <c- mi>5</c->

<c- c1>// InformNewHead informs the syncer about a new potential tipset</c->
<c- c1>// This should be called when connecting to new peers, and additionally</c->
<c- c1>// when receiving new blocks from the network</c->
<c- a>func</c-> <c- p>(</c->syncer <c- o>*</c->Syncer<c- p>)</c-> InformNewHead<c- p>(</c->from PeerID<c- p>,</c-> head TipSet<c- p>)</c-> <c- p>{</c->
    <c- k>switch</c-> syncer<c- p>.</c->syncMode <c- p>{</c->
    <c- k>case</c-> Bootstrap<c- p>:</c->
        <c- k>go</c-> SyncBootstrap<c- p>(</c->from<c- p>,</c-> head<c- p>)</c->
    <c- k>case</c-> CaughtUp<c- p>:</c->
        <c- k>go</c-> syncer<c- p>.</c->SyncCaughtUp<c- p>(</c->blk<c- p>)</c->
    <c- p>}</c->
<c- p>}</c->

<c- c1>// SyncBootstrap is used to synchronise your chain when first joining</c->
<c- c1>// the network, or when rejoining after significant downtime.</c->
<c- a>func</c-> <c- p>(</c->syncer <c- o>*</c->Syncer<c- p>)</c-> SyncBootstrap<c- p>()</c-> <c- p>{</c->
    syncer<c- p>.</c->syncLock<c- p>.</c->Lock<c- p>()</c->
    <c- k>defer</c-> syncer<c- p>.</c->syncLock<c- p>.</c->Unlock<c- p>()</c->
    syncer<c- p>.</c->peerHeads<c- p>[</c->from<c- p>]</c-> <c- p>=</c-> head
    <c- k>if</c-> len<c- p>(</c->syncer<c- p>.</c->peerHeads<c- p>)</c-> <c- p>&lt;</c-> BootstrapPeerThreshold <c- p>{</c->
        <c- c1>// not enough peers to sync yet...</c->
        <c- k>return</c->
    <c- p>}</c->

    selectedHead <c- o>:=</c-> selectHead<c- p>(</c->syncer<c- p>.</c->peerHeads<c- p>)</c->

    cur <c- o>:=</c-> selectedHead
    <c- a>var</c-> blockSet BlockSet
    <c- k>for</c-> head<c- p>.</c->Height<c- p>()</c-> <c- p>></c-> <c- mi>0</c-> <c- p>{</c->
        <c- c1>// NB: GetBlocks validates that the blocks are in-fact the ones we</c->
        <c- c1>// requested, and that they are correctly linked to eachother. It does</c->
        <c- c1>// not validate any state transitions</c->
        blks <c- o>:=</c-> syncer<c- p>.</c->bsync<c- p>.</c->GetBlocks<c- p>(</c->head<c- p>,</c-> RequestWidth<c- p>)</c->
        blockSet<c- p>.</c->Insert<c- p>(</c->blks<c- p>)</c->

        head <c- p>=</c-> blks<c- p>.</c->Last<c- p>().</c->Parents<c- p>()</c->
    <c- p>}</c->

    genesis <c- o>:=</c-> blockSet<c- p>.</c->GetByHeight<c- p>(</c-><c- mi>0</c-><c- p>)</c->
    <c- k>if</c-> genesis <c- o>!=</c-> syncer<c- p>.</c->genesis <c- p>{</c->
        <c- c1>// TODO: handle this...</c->
        Error<c- p>(</c-><c- s>"We synced to the wrong chain!"</c-><c- p>)</c->
        <c- k>return</c->
    <c- p>}</c->

    <c- c1>// Fetch all the messages for all the blocks in this chain</c->
    <c- c1>// There are many ways to make this more efficient. For now, do the dumb thing</c->
    blockSet<c- p>.</c->ForEach<c- p>(</c-><c- a>func</c-><c- p>(</c->b Block<c- p>)</c-> <c- p>{</c->
        <c- c1>// FetchMessages should use bitswap to fetch any messages we don’t have locally</c->
        FetchMessages<c- p>(</c->b<c- p>)</c->
    <c- p>})</c->

    <c- c1>// Now, to validate some state transitions</c->
    base <c- o>:=</c-> genesis
    <c- k>for</c-> i <c- o>:=</c-> <c- mi>1</c-><c- p>;</c-> i <c- p>&lt;</c-> selectedHead<c- p>.</c->Height<c- p>();</c-> i<c- o>++</c-> <c- p>{</c->
        next <c- o>:=</c-> blockSet<c- p>.</c->GetByHeight<c- p>(</c->i<c- p>)</c->
        <c- k>if</c-> <c- p>!</c->ValidateTransition<c- p>(</c->base<c- p>,</c-> next<c- p>)</c-> <c- p>{</c->
            <c- c1>// TODO: do something productive here...</c->
            Error<c- p>(</c-><c- s>"invalid state transition"</c-><c- p>)</c->
            <c- k>return</c->
        <c- p>}</c->
    <c- p>}</c->

    blockSet<c- p>.</c->PersistTo<c- p>(</c->syncer<c- p>.</c->store<c- p>)</c->
    syncer<c- p>.</c->head <c- p>=</c-> bset<c- p>.</c->Head<c- p>()</c->
    syncer<c- p>.</c->syncMode <c- p>=</c-> CaughtUp
<c- p>}</c->

<c- a>func</c-> selectHead<c- p>(</c->heads <c- a>map</c-><c- p>[</c->PeerID<c- p>]</c->TipSet<c- p>)</c-> TipSet <c- p>{</c->
    headsArr <c- o>:=</c-> toArray<c- p>(</c->heads<c- p>)</c->
    sel <c- o>:=</c-> headsArr<c- p>[</c-><c- mi>0</c-><c- p>]</c->
    <c- k>for</c-> i <c- o>:=</c-> <c- mi>1</c-><c- p>;</c-> i <c- p>&lt;</c-> len<c- p>(</c->headsArr<c- p>);</c-> i<c- o>++</c-> <c- p>{</c->
        cur <c- o>:=</c-> headsArr<c- p>[</c->i<c- p>]</c->

        <c- k>if</c-> cur<c- p>.</c->IsAncestorOf<c- p>(</c->sel<c- p>)</c-> <c- p>{</c->
            <c- k>continue</c->
        <c- p>}</c->
        <c- k>if</c-> sel<c- p>.</c->IsAncestorOf<c- p>(</c->cur<c- p>)</c-> <c- p>{</c->
            sel <c- p>=</c-> cur
            <c- k>continue</c->
        <c- p>}</c->

        nca <c- o>:=</c-> NearestCommonAncestor<c- p>(</c->cur<c- p>,</c-> sel<c- p>)</c->
        <c- k>if</c-> sel<c- p>.</c->Height<c- p>()</c-> <c- o>-</c-> nca<c- p>.</c->Height<c- p>()</c-> <c- p>></c-> ForkLengthThreshold <c- p>{</c->
        	<c- c1>// TODO: handle this better than refusing to sync</c->
        	Fatal<c- p>(</c-><c- s>"Conflict exists in heads set"</c-><c- p>)</c->
        <c- p>}</c->

        <c- k>if</c-> cur<c- p>.</c->Weight<c- p>()</c-> <c- p>></c-> sel<c- p>.</c->Weight<c- p>()</c-> <c- p>{</c->
            sel <c- p>=</c-> cur
        <c- p>}</c->
    <c- p>}</c->
    <c- k>return</c-> sel
<c- p>}</c->

<c- c1>// SyncCaughtUp is used to stay in sync once caught up to</c->
<c- c1>// the rest of the network.</c->
<c- a>func</c-> <c- p>(</c->syncer <c- o>*</c->Syncer<c- p>)</c-> SyncCaughtUp<c- p>(</c->maybeHead TipSet<c- p>)</c-> <c- b>error</c-> <c- p>{</c->
	chain<c- p>,</c-> err <c- o>:=</c-> syncer<c- p>.</c->collectChainCaughtUp<c- p>(</c->maybeHead<c- p>)</c->
	<c- k>if</c-> err <c- o>!=</c-> <c- kc>nil</c-> <c- p>{</c->
		<c- k>return</c-> err
	<c- p>}</c->

	<c- c1>// possibleTs enumerates possible tipsets that are the union</c->
    <c- c1>// of tipsets from the chain and the store</c->
	<c- k>for</c-> _<c- p>,</c-> ts <c- o>:=</c-> <c- k>range</c-> possibleTs<c- p>(</c->chain<c- p>[</c-><c- mi>1</c-><c- p>:])</c-> <c- p>{</c->
		<c- k>if</c-> err <c- o>:=</c-> consensus<c- p>.</c->Validate<c- p>(</c->ts<c- p>,</c-> store<c- p>);</c-> err <c- o>!=</c-> <c- kc>nil</c-> <c- p>{</c->
			<c- k>return</c-> err
		<c- p>}</c->
		syncer<c- p>.</c->store<c- p>.</c->PutTipSet<c- p>(</c->ts<c- p>)</c->
		<c- k>if</c-> consenus<c- p>.</c->Weight<c- p>(</c->ts<c- p>)</c-> <c- p>></c-> consensus<c- p>.</c->Weight<c- p>(</c->head<c- p>)</c-> <c- p>{</c->
			syncer<c- p>.</c->head <c- p>=</c-> ts
		<c- p>}</c->
	<c- p>}</c->
	<c- k>return</c-> <c- kc>nil</c->
<c- p>}</c->


<c- a>func</c-> <c- p>(</c->syncer <c- o>*</c->Syncer<c- p>)</c-> collectChainCaughtUp<c- p>(</c->maybeHead TipSet<c- p>)</c-> <c- p>(</c->Chain<c- p>,</c-> <c- b>error</c-><c- p>)</c-> <c- p>{</c->
	<c- c1>// fetch tipset and messages via bitswap</c->
	ts <c- o>:=</c-> tipsetFromCidOverNet<c- p>(</c->newHead<c- p>)</c->

	<c- a>var</c-> chain Chain
	<c- k>for</c-> <c- p>{</c->
		<c- k>if</c-> <c- p>!</c->consensus<c- p>.</c->Punctual<c- p>(</c->ts<c- p>)</c-> <c- p>{</c->
			syncer<c- p>.</c->bad<c- p>.</c->InvalidateChain<c- p>(</c->chain<c- p>)</c->
			syncer<c- p>.</c->bad<c- p>.</c->InvalidateTipSet<c- p>(</c->ts<c- p>)</c->
			<c- k>return</c-> <c- kc>nil</c-><c- p>,</c-> errors<c- p>.</c->New<c- p>(</c-><c- s>"tipset forks too far back from head"</c-><c- p>)</c->
		<c- p>}</c->

		chain<c- p>.</c->InsertFront<c- p>(</c->ts<c- p>)</c->

		<c- k>if</c-> syncer<c- p>.</c->store<c- p>.</c->Contains<c- p>(</c->ts<c- p>)</c-> <c- p>{</c->
			<c- c1>// Store has record of this tipset.</c->
			<c- k>return</c-> chain<c- p>,</c-> <c- kc>nil</c->
		<c- p>}</c->
		parent <c- o>:=</c-> ts<c- p>.</c->ParentCid<c- p>()</c->
		ts<c- p>,</c-> err <c- p>=</c-> tipsetFromCidOverNet<c- p>(</c->parent<c- p>)</c->
		<c- k>if</c-> err <c- o>!=</c-> <c- kc>nil</c-> <c- p>{</c->
			<c- k>return</c-> <c- kc>nil</c-><c- p>,</c-> err
		<c- p>}</c->
	<c- p>}</c->
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="4.3" id="syncing-mode"><span class="secno">4.3. </span><span class="content">Syncing Mode</span><a class="self-link" href="#syncing-mode"></a></h3>
    A filecoin node syncs in <code>syncing</code> mode when entering the network for the first time, or after being separated for a sufficiently long period of time.  The exact period of time comes from the consensus protocol (TODO specify more concretely, for example how does this relate to the consensus.Punctual method?). 
   <p>During <code>syncing</code> mode a node learns about the newest head of the blockchain through the secure bootstrapping protocol. The syncing protocol then syncs the block headers for that entire chain, and validates their linking. It then fetches all the messages for the chain, and checks all the state transitions between the blocks and that the blocks were correctly created.  If validation passes the node’s head is updated to the head tipset received from bootstrapping.</p>
   <p>In this mode of operation a filecoin node should not mine or send messages as it will not be able to successfully generate heaviest blocks or reference the correct state of the chain to verify that messages will execute as expected.</p>
   <p>(TODO: should include discussion of a <code>Load()</code> call to make use of existing chain data on a node during "re-awakening" case of <code>syncing</code> mode.)</p>
   <h3 class="heading settled" data-level="4.4" id="caught-up-mode"><span class="secno">4.4. </span><span class="content">Caught Up Mode</span><a class="self-link" href="#caught-up-mode"></a></h3>
    A filecoin node syncs in <code>caught up</code> mode after completing <code>syncing</code> mode. A node stays in this mode until they are shutdown. New block cids are gossiped from the network through the hello protocol or the network’s <a href="data-propagation.md#block-propagation">block pubsub protocol</a>. A node also obtains new block cids coming from its own successfully mined blocks.  These cids are input to the <code>caught up</code> syncing protocol.  If these cids belong to a tipset already in the store then they are already synced and the syncing protocol finishes.  If not the syncing protocol resolves the tipset corresponding to the input cids.  It checks that this tipset is not in its badTipSet cache, and that this tipset is not too far back in the chain using the consensus <code>Punctual</code> method.  It then resolves the parent tipset by reading off the parent cids in the header of any block of the tipset.  The above procedure repeats until either an error is found or the store contains the next tipset.  In the case of an error bad tipsets and their children not already in the bad tipset cache are added to the cache before the call to <code>collectTipSetCaughtUp</code> returns. 
   <p>After collecting a chain up to an ancestor tipset that was previously synced to the store the syncing protocol checks each tipset of the new chain for validity one by one.  When the filecoin network runs Expected Consensus, or any other multiple parents consensus protocol, the syncing protocol must consider not only the tipsets in the new chain but also possible new-heaviest tipsets that are the union of tipsets in the new chain and tipsets already in the store.  In the case of Expected Consensus there is at most one such tipset: the tipset made up of the union of the first new tipset in the new chain being synced and the largest tipset with the same parents kept in the store.</p>
   <p>To sync new tipsets the <code>caught up</code> syncing protocol first runs a consensus validation check on the tipset.  If any tipset is invalid the syncing protocol finishes.  If a tipset is valid the syncer adds the tipset to the chain store.  The syncing protocol then checks whether the tipset is heavier than the current head using the consensus weighting rules.  If it is heavier the chain updates the state of the node to account for the new heaviest tipset.</p>
   <h3 class="heading settled" data-level="4.5" id="dependencies"><span class="secno">4.5. </span><span class="content">Dependencies</span><a class="self-link" href="#dependencies"></a></h3>
    Things that affect the chain syncing protocol. 
   <p><strong>Consensus protocol</strong></p>
   <ul>
    <li data-md>
     <p>The consensus protocol should define a punctual function: <code>func Punctual([]TipSet chain) bool</code>. <code>Punctual(chain) == true</code> when a provided chain does not fork from the node’s view of the current best chain 'too far in the past', and false otherwise.</p>
    <li data-md>
     <p>The fork selection rule.  This includes the weighting function.  As part of this in the context of EC the syncer must consider tipsets that are the union of independently propagated tipsets.</p>
   </ul>
   <p><strong>Chain storage</strong></p>
   <ul>
    <li data-md>
     <p>The current chain syncing protocol requires that the chain store never stores an invalid tipset.</p>
   </ul>
   <h3 class="heading settled" data-level="4.6" id="open-questions"><span class="secno">4.6. </span><span class="content">Open Questions</span><a class="self-link" href="#open-questions"></a></h3>
   <ul>
    <li data-md>
     <p>Secure bootstrapping in <code>syncing</code> mode</p>
    <li data-md>
     <p>How do we handle the lag between the initial head bootstrapped in <code>syncing</code> mode and the network head once the first <code>SyncBootstrap</code> call is complete?  Likely we’ll need multiple <code>SyncBootstrap</code> calls.  Should they be parallelized?</p>
    <li data-md>
     <p>The properties of the chain store implementation have significant impact on the design of the syncing protocol and the syncing protocol’s resistance to Denial Of Service (DOS) attacks.  For example if the chain store naively keeps all blocks in storage nodes are more vulnerable to running out of space.  As another example the syncer assumes that the store always contains a punctual ancestor of the heaviest chain. Should the spec grow to include properties of chain storage so that the syncing protocol can guarantee a level of DOS resistance?  Should chain storage be completely up to the implementation?  Should the chain storage spec be a part of the syncing protocol?</p>
   </ul>
   <h3 class="heading settled" data-level="4.7" id="chain-validation①"><span class="secno">4.7. </span><span class="content">Chain Validation</span><a class="self-link" href="#chain-validation①"></a></h3>
   <p>Every filecoin full node must receive and process blocks from the network to ensure that they always know the correct latest state of the chain. How blocks get propagated through the network is discussed in the <a href="data-propagation.md">Data Propagation</a> document.</p>
   <p>Every block that comes in over the network must first be validated structurally. This starts with making sure it unmarshals correctly (see <a href="data-structures.md#block">block</a>), making sure that all the fields contain legal values, and that the signature over the block is correct. Then, the consensus rules for the block must be validated. These include:</p>
   <ul>
    <li data-md>
     <p>The blocks parent tipset is valid, meaning that each parent:</p>
    <li data-md>
     <p>Is a valid block</p>
    <li data-md>
     <p>Is the same height as the others</p>
    <li data-md>
     <p>Has the same parent tipset as the others</p>
    <li data-md>
     <p>The block’s ticket is correctly generated:</p>
    <li data-md>
     <p>Is generated from the smallest ticket in the parent tipset</p>
    <li data-md>
     <p>If it includes intermediary failed tickets (i.e. null blocks) in the ticket array, that each ticket correctly generates the next in the array</p>
    <li data-md>
     <p>That all tickets in the ticket array were generated by the same miner</p>
    <li data-md>
     <p>The ticket is a winning ticket</p>
    <li data-md>
     <p>The state transitions are done correctly:</p>
    <li data-md>
     <p>All messages are valid</p>
    <li data-md>
     <p>Each message executes correctly and produces a receipt matching the corresponding one in the receipt set</p>
     <ul>
      <li data-md>
       <p>For more information on message execution, see <a href="state-machine.md">the state machine spec</a>.</p>
     </ul>
    <li data-md>
     <p>After all messages are applied, the resultant state root matches the one in the block</p>
   </ul>
   <p>Once the block passes validation, it should be added to the local datastore, even in the case where we don’t accept it right now. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching. Blocks a certain distance from the current chain height may be dropped (exact number TBD, but blocks that havent been included after several days may be purged).</p>
   <p>To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.</p>
   <h2 class="heading settled" data-level="5" id="storage-market"><span class="secno">5. </span><span class="content">Storage Market</span><a class="self-link" href="#storage-market"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="what-is-the-filecoin-storage-market"><span class="secno">5.1. </span><span class="content">What is the Filecoin Storage Market</span><a class="self-link" href="#what-is-the-filecoin-storage-market"></a></h3>
   <p>The Filecoin <code>storage market</code> is the underlying system used to discover, negotiate and form <code>storage contracts</code> between clients and storage providers called <code>storage miners</code> in a Filecoin network. The <code>storage market</code> itself is an <code>actor</code> that helps to mediate certain operations in the market, including adding new miners, and punishing faulty ones, it does not directly mediate any actual storage deals. The <code>storage contracts</code> between clients and miners specify that a given <code>piece</code> will be stored for a given time duration. It is assumed that the <code>client</code>, or some delegate of the client, remains online to monitor the <code>storage miner</code> and <code>slash</code> it in the case that the agreed upon data is removed from the miners proving set before the deal is finished.</p>
   <p>The creation of such a storage market is motivated by the need to provide a fast, reliable and inexpensive solution to data generated worldwide. The cost and difficulty involved in starting datacenters around the world make a decentralized solution attractive here, enabling clients and miners to interact directly, forming agreements for storage ad-hoc around the world. Geography is only one such aspect in which a decentralized market can be made competitive. You can read more about the underlying motivations for building a storage market <a href="https://www.youtube.com/watch?v=EClPAFPeXIQ">here</a>.</p>
   <p>In the current design of the <code>storage market</code>, <code>storage miners</code> post <code>asks</code> indicating the price they are willing to accepts, and <code>clients</code> select (either manually, or via some locally run algorithm) a set of storage miners to store their data with. They then contact the <code>storage miners</code> who programmatically either accept or deny their <code>deal proposals</code>. In the future, we may allow miners to search for clients and propose deals to them, but for now, for simplicity, we stick with the model described above.</p>
   <h4 class="heading settled" data-level="5.1.1" id="visualization-of-the-filecoin-storage-market"><span class="secno">5.1.1. </span><span class="content">Visualization of the Filecoin Storage Market</span><a class="self-link" href="#visualization-of-the-filecoin-storage-market"></a></h4>
   <p>TODO: This is a high level overview of how the storage market interacts with components</p>
   <h3 class="heading settled" data-level="5.2" id="the-market-interface"><span class="secno">5.2. </span><span class="content">The Market Interface</span><a class="self-link" href="#the-market-interface"></a></h3>
   <p>This interface, written using Go type notation, defines the set of methods that are callable on the storage market actor. The storage market actor is a built-in network actor. For more information about Actors, see TODO.</p>
<pre class="language-go highlight"><c- a>type</c-> StorageMarket <c- a>interface</c-> <c- p>{</c->
    <c- c1>// CreateStorageMiner registers a new storage miner with the given public key and a</c->
    <c- c1>// pledge of the given size. The miners collateral is set by the value in the message.</c->
    <c- c1>// The public key must match the private key used to sign off on blocks created</c->
    <c- c1>// by this miner. This key is the 'worker' key for the miner.</c->
    <c- c1>// The libp2p peer ID specified should reference the libp2p identity that the</c->
    <c- c1>// miner is operating. This is the ID that clients will connect to to propose deals</c->
    <c- c1>// TODO: maybe rename to 'RegisterStorageMiner'?</c->
    CreateStorageMiner<c- p>(</c->pubk PublicKey<c- p>,</c-> pledge BytesAmount<c- p>,</c-> pid libp2p<c- p>.</c->PeerID<c- p>)</c-> Address

    <c- c1>// SlashConsensusFault is used to slash a misbehaving miner who submitted two different</c->
    <c- c1>// blocks at the same block height. The signatures on each block are validated</c->
    <c- c1>// and the offending miner has their entire collateral slashed, including the</c->
    <c- c1>// invalidation of any any all storage they are providing. The caller is rewarded</c->
    <c- c1>// a small amount to compensate for gas fees (TODO: maybe it should be more?)</c->
    SlashConsensusFault<c- p>(</c->blk1<c- p>,</c-> blk2 BlockHeader<c- p>)</c->

    <c- c1>// SlashStorageFault slashes a storage miner for not submitting their PoSTs within</c->
    <c- c1>// the correct [time window](#TODO-link-to-faulty-submission). This may be called by anyone who detects the faulty behavior.</c->
    <c- c1>// The slashed miner then loses all of their staked collateral, and also loses all</c->
    <c- c1>// of their power, and as a result, is no longer a candidate leader for extending the chain.</c->
    SlashStorageFault<c- p>(</c->miner Address<c- p>)</c->

    <c- c1>// UpdateStorage is called by a miner to adjust the storage market actors</c->
    <c- c1>// accounting of the total storage in the storage market.</c->
    UpdateStorage<c- p>(</c->delta BytesAmount<c- p>)</c->

    <c- c1>// GetTotalStorage returns the total committed storage in the system. This number is</c->
    <c- c1>// also used as the 'total power' in the system for the purposes of the power table</c->
    GetTotalStorage<c- p>()</c-> BytesAmount
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="5.3" id="the-filecoin-storage-market-operation"><span class="secno">5.3. </span><span class="content">The Filecoin Storage Market Operation</span><a class="self-link" href="#the-filecoin-storage-market-operation"></a></h3>
   <p>The Filecoin storage market operates as follows. Miners providing storage submit ask orders, asking for a certain price for their available storage space, and clients with files to store look through the asks and select a miner they wish to use. Clients negotiate directly with the storage miner that owns that ask, off-chain. Storage is priced in terms of Filecoin per byte per block (note: we may change the units here).</p>
   <h4 class="heading settled" data-level="5.3.1" id="market-datastructures"><span class="secno">5.3.1. </span><span class="content">Market Datastructures</span><a class="self-link" href="#market-datastructures"></a></h4>
   <p>TODO: This storage-market.md doc should try to describe the high level interfaces of the storage market, details about storage and specific method behavior should go in a separate place where we talk about individual system actors.</p>
   <p>The storage market contains the following data:</p>
   <ul>
    <li data-md>
     <p>StorageMiners - The storage market keeps track of the set of the addresses of all storage miners in the storage market. All miners referenced here were created by the storage market via the <code>CreateMiner</code> method.</p>
    <li data-md>
     <p>TotalComittedStorage - This is a tally of all the committed storage in the network. This is both a nice metric to see how much data is being stored by the filecoin network, and a critical piece of information used by mining routine to compute each miners storage ratio.</p>
   </ul>
   <h3 class="heading settled" data-level="5.4" id="market-flow"><span class="secno">5.4. </span><span class="content">Market Flow</span><a class="self-link" href="#market-flow"></a></h3>
   <p>This section describes the flow required to store a single piece with a single storage miner. Most use-cases will involve performing this process for multiple pieces, with different miners.</p>
   <h4 class="heading settled" data-level="5.4.1" id="before-deal"><span class="secno">5.4.1. </span><span class="content">Before Deal</span><a class="self-link" href="#before-deal"></a></h4>
   <ol>
    <li data-md>
     <p><strong>Merkle Translation:</strong> The client runs a 'Local Merkle Translation' to generate the storage market hash for the data.</p>
     <ul>
      <li data-md>
       <p>Storage miners reference data by its storage market hash, and not by its standard hash. This step is needed for the client to be able to trust their data was correctly included in the miners sector. See <a href="definitions.md#piece-confirmation">Piece Confirmation</a></p>
     </ul>
    <li data-md>
     <p><strong>Miner Selection:</strong> The client looks at asks on the network, and then selects a storage miner to store their data with.</p>
     <ul>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> this is currently a manual process.</p>
     </ul>
    <li data-md>
     <p><strong>Payment Channel Setup:</strong> The client calls [<code>Payment.Setup</code>](#payments) with the piece and the funds they are going to pay the miner with. All payments between clients and storage providers use payment channels.</p>
   </ol>
   <h4 class="heading settled" data-level="5.4.2" id="deal"><span class="secno">5.4.2. </span><span class="content">Deal</span><a class="self-link" href="#deal"></a></h4>
   <p class="note" role="note"><span>Note:</span> The details of this protocol including formats, datastructures, and algorithms, can be found <a href="network-protocols.md#storage-deal">here</a>.</p>
   <ol>
    <li data-md>
     <p><strong>Storage Deal Staging:</strong> The client now runs the <a href="network-protocols.md#storage-deal">'make storage deal'</a> protocol, as follows:</p>
     <ul>
      <li data-md>
       <p>The client sends a <code>StorageDealProposal</code> for the piece in question</p>
       <ul>
        <li data-md>
         <p>This contains updates for the payment channel that the client may close at any time, unless the piece gets confirmed (see next section), in which case the miner is able to extend the channel.</p>
       </ul>
      <li data-md>
       <p>The miner decides whether or not to accept the deal and sends back a <code>StorageDealResponse</code></p>
       <ul>
        <li data-md>
         <p class="note" role="note"><span>Note:</span> Different implementations may come up with different ways of making a decision on a given deal.</p>
       </ul>
      <li data-md>
       <p>If the miner accepts, the client now sends the data to the miner</p>
      <li data-md>
       <p>Once the miner receives the data:</p>
       <ul>
        <li data-md>
         <p>They validate that the data matches the storage market hash claimed by the client</p>
        <li data-md>
         <p>They stage it into a sector and set the deal state to <code>Staged</code></p>
       </ul>
     </ul>
    <li data-md>
     <p><strong>Storage Deal Start</strong>: Clients makes sure data is in a <a href="definitions.md#sector">sector</a></p>
     <ul>
      <li data-md>
       <p><strong>PieceConfirmation:</strong> Once the miner seals the sector, they update the PieceConfirmation in the deal state, which the client then gets the next time they query that state.</p>
       <ul>
        <li data-md>
         <p>The PieceConfirmation proves that the piece in the deal is contained in a sector whose commitment is on chain. The 'Merkle Translation' hash from earlier is used here. See <a href="proofs.md#piece-inclusion-proof">piece inclusion proof for more details</a></p>
       </ul>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> a client that is not interested in staying online to wait for PieceConfirmation can leave immediately, however, they run the risk that their files don’t actually get stored (but if their data is not stored, the miner will not be able to claim payment for it).</p>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> In order to provide the piece confirmation, the miner needs to fill the sector. This may take some time. So there is a wait between the time the data is transferred to the miner, and when the piece confirmation becomes available.</p>
      <li data-md>
       <p><strong>Mining</strong>: Miner posts <code>seal commitment</code> and associated proof on chain by calling <code>CommitSector</code> and starts running <code>proofs of spacetime</code>. See <a href="mining.md#storage-mining-cycle">storage mining cycle</a> for more details.</p>
     </ul>
    <li data-md>
     <p><strong>Storage Deal Abort:</strong> If the miner doesn’t provide the PieceConfirmation, the client can invalidate the payment channel.</p>
     <ul>
      <li data-md>
       <p>This is done by invoking the 'close' method on the channel on-chain. This process starts a timer that, on finishing, will release the funds to the client.</p>
      <li data-md>
       <p>If a client attempts to abort a deal that they have actually made with a miner, the miner can submit a payment channel update to force the channel to stay open for the length of the agreement.</p>
     </ul>
    <li data-md>
     <p><strong>Storage Deal Complete:</strong> The client periodically queries the miner for the deals status until the deal is 'complete', at which point the client knows that the data is properly replicated.</p>
     <ul>
      <li data-md>
       <p>The client should store the returned 'PieceConfirmation' for later validation.</p>
     </ul>
    <li data-md>
     <p><strong>Income Withdrawal</strong>: When the miner wishes to withdraw funds, they call [<code>Payment.RedeemVoucher</code>](#payments).</p>
   </ol>
   <blockquote>
    <p>TODO: 'complete' isnt really the right word here, as it implies that the deal is over.</p>
   </blockquote>
   <h3 class="heading settled" data-level="5.5" id="the-power-table"><span class="secno">5.5. </span><span class="content">The Power Table</span><a class="self-link" href="#the-power-table"></a></h3>
   <p>The <code>power table</code> is exported by the storage market for use by consensus. There isn’t actually a concrete object that is the power table, instead, there is a 'total power' exported by the storage market actor, and each individual miner reports its power through their actor.</p>
   <p>TODO: rephrase the above to make it clear that power is updated only on PoSt submission and when slashed.</p>
   <h4 class="heading settled" data-level="5.5.1" id="power-updates"><span class="secno">5.5.1. </span><span class="content">Power Updates</span><a class="self-link" href="#power-updates"></a></h4>
   <p>A miners power is updated only when they submit a valid PoSt to the chain, or if they are slashed.</p>
   <p>TODO: link to methods for post submission and slashing.</p>
   <p>Power is deducted when miners remove sectors by reporting the sector 'missing' or 'done' in a PoSt.</p>
   <h3 class="heading settled" data-level="5.6" id="payments"><span class="secno">5.6. </span><span class="content">Payments</span><a class="self-link" href="#payments"></a></h3>
   <p>The storage market expects a payments system to allow clients to pay miners for storage. Any payments system that has the following capabilities may be used:</p>
<pre class="language-go highlight"><c- a>type</c-> Payments <c- a>interface</c-> <c- p>{</c->
    <c- c1>// Setup sets up a payment from the caller to the target address. The payment</c->
    <c- c1>// MUST be contingent on the miner being able to prove that they have the data</c->
    <c- c1>// referenced by 'piece'. The total amount of Filecoin that may be transfered by</c->
    <c- c1>// this payment is specified by 'value'</c->
    Setup<c- p>(</c->target Address<c- p>,</c-> piece Cid<c- p>,</c-> value TokenAmount<c- p>)</c-> ID

    <c- c1>// MakeVouchers creates a set of vouchers redeemable by the target of the</c->
    <c- c1>// previously created payment. It creates 'count' vouchers, each of which is</c->
    <c- c1>// redeemable only after an certain block height, evenly spaced out between</c->
    <c- c1>// start and end. Each voucher should be redeemable for proportionally more</c->
    <c- c1>// Filecoin, up to the total amount specified during the payment setup.</c->
    MakeVouchers<c- p>(</c->id ID<c- p>,</c-> start<c- p>,</c-> end BlockHeight<c- p>,</c-> count <c- b>int</c-><c- p>)</c-> <c- p>[]</c->Voucher

    <c- c1>// Redeem voucher is called by the target of a given payment to claim the</c->
    <c- c1>// funds represented by it. The voucher can only be redeemed after the block</c->
    <c- c1>// height that is attributed to the voucher, and also only if the proof given</c->
    <c- c1>// proves that the target is correctly storing the piece referenced in the</c->
    <c- c1>// payment setup.</c->
    RedeemVoucher<c- p>(</c->v Voucher<c- p>,</c-> proof Proof<c- p>)</c->
<c- p>}</c->
</pre>
   <p>For details on the implementation of the payments system, see <a href="payments.md">the payments doc</a>.</p>
   <h3 class="heading settled" data-level="5.7" id="future-protocol-improvements"><span class="secno">5.7. </span><span class="content">Future Protocol Improvements</span><a class="self-link" href="#future-protocol-improvements"></a></h3>
   <ul>
    <li data-md>
     <p>Slashable Commitments</p>
    <li data-md>
     <p>When miners initially receive the data for a deal with a client, that signed response statement can be used to slash the miner in the event that they never include that data in a sector.</p>
   </ul>
   <h3 class="heading settled" data-level="5.8" id="open-questions①"><span class="secno">5.8. </span><span class="content">Open questions</span><a class="self-link" href="#open-questions①"></a></h3>
   <ul>
    <li data-md>
     <p>Storage time should likely be designated in terms of proving period. Where a proving period is the number of blocks in which every miner must submit a proof for their sectors. Not doing this makes accounting hard: "when exactly did this sector fail?"</p>
   </ul>
   <h2 class="heading settled" data-level="6" id="retrieval-market-v0"><span class="secno">6. </span><span class="content"><code>Retrieval Market</code> V0</span><a class="self-link" href="#retrieval-market-v0"></a></h2>
   <h3 class="heading settled" data-level="6.1" id="what-is-the-retrieval-market"><span class="secno">6.1. </span><span class="content">What is the <code>Retrieval Market</code></span><a class="self-link" href="#what-is-the-retrieval-market"></a></h3>
   <h3 class="heading settled" data-level="6.2" id="what-the-retrieval-market-affects"><span class="secno">6.2. </span><span class="content">What the <code>Retrieval Market</code> affects</span><a class="self-link" href="#what-the-retrieval-market-affects"></a></h3>
   <h3 class="heading settled" data-level="6.3" id="dependencies①"><span class="secno">6.3. </span><span class="content">Dependencies</span><a class="self-link" href="#dependencies①"></a></h3>
   <h3 class="heading settled" data-level="6.4" id="components"><span class="secno">6.4. </span><span class="content">Components</span><a class="self-link" href="#components"></a></h3>
   <p>Version 0 of the <code>retrieval market</code> protocol is what we (tentatively) will launch the filecoin network with. It is version zero because it will only be good enough to fit the bill as a way to pay another node for a file.</p>
   <p>The main components are as follows:</p>
   <ul>
    <li data-md>
     <p>A payment channel actor (See <a href="payment-channels.md">payment channels</a> for details)</p>
    <li data-md>
     <p>'retrieval-v0' <code>libp2p</code> services</p>
    <li data-md>
     <p>A chain-based content routing interface</p>
    <li data-md>
     <p>A set of commands to interact with the above</p>
   </ul>
   <h3 class="heading settled" data-level="6.5" id="retrieval-v0-libp2p-services"><span class="secno">6.5. </span><span class="content">Retrieval V0 <code>libp2p</code> Services</span><a class="self-link" href="#retrieval-v0-libp2p-services"></a></h3>
   <p>The v0 <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services. It will be request response based, where the client who is requesting a file sends a <code>retrieval deal proposal</code> to the miner. The miner chooses whether or not to accept it, sends their response which (if they accept the proposal) includes a <code>signed retrieval deal</code>, followed by the actual requested content, streamed as a series of bitswap block messages, using a pre-order traversal of the dag. Each block should use the <a href="https://github.com/ipfs/go-ipfs/blob/master/exchange/bitswap/message/message.go#L216">bitswap block message format</a>. This way, the client should be able to verify the data incrementally as it receives it. Once the client has received all the data, it should then send a payment channel SpendVoucher of the proposed amount to the miner. This protocol may be easily extended to include payments from the client to the miner every N blocks, but for now we omit that feature.</p>
<pre class="language-go highlight"><c- a>type</c-> RetDealProposal <c- a>struct</c-> <c- p>{</c->
    <c- c1>// Ref is the cid of the data to be retrieved</c->
    Ref Cid

    <c- c1>// Price is the total amount that the client is willing to pay for the</c->
    <c- c1>// retrieval of the data</c->
    Price TokenAmount

    <c- c1>// Payment is a payment info from the client to the retrieval miner for the data</c->
    Payment PaymentInfo
<c- p>}</c->

<c- a>type</c-> ResponseStatus <c- b>uint</c->

<c- a>const</c-> <c- p>(</c->
    Unset <c- p>=</c-> ResponseStatus<c- p>(</c-><c- kc>iota</c-><c- p>)</c->
    Accepted
    Rejected
    Error
<c- p>)</c->

<c- a>type</c-> RetDealResponse <c- a>struct</c-> <c- p>{</c->
    Status ResponseStatus
    Message <c- b>string</c->
<c- p>}</c->

<c- a>type</c-> Block <c- a>struct</c-> <c- p>{</c->
    <c- c1>// Prefix is the cid prefix parameters for this block. It describes how to</c->
    <c- c1>// hash the block to verify it matches the expected value.</c->
    Prefix CidPrefix
    Data <c- p>[]</c-><c- b>byte</c->
<c- p>}</c->
</pre>
   <p><code>Retrieval miners</code> should also support a query service that allows clients to request pricing information from a miner.</p>
   <p>The query should include the CID of the piece that the client is interested in retrieving. The response contains whether or not the miner will serve that data, the price they will accept for it.</p>
<pre class="language-go highlight"><c- a>type</c-> RetQuery <c- a>struct</c-> <c- p>{</c->
    Piece Cid
<c- p>}</c->

<c- a>type</c-> RetQueryResponse <c- a>struct</c-> <c- p>{</c->
    Status RetQueryStatus
    MinPrice TokenAmount
<c- p>}</c->

<c- a>type</c-> RetQueryStatus <c- b>uint</c->

<c- a>const</c-> <c- p>(</c->
    Unset <c- p>=</c-> RetQueryStatus<c- p>(</c-><c- kc>iota</c-><c- p>)</c->
    OK
    PieceUnavailable
<c- p>)</c->
</pre>
   <h3 class="heading settled" data-level="6.6" id="chain-based-content-routing"><span class="secno">6.6. </span><span class="content">Chain Based Content Routing</span><a class="self-link" href="#chain-based-content-routing"></a></h3>
   <p>For the version 0 protocol. We should implement a small helper service that looks up which miners have a given piece based on deals made in the blockchain. The service should first look the content up in the blockchain (or in some client index) to find the chain address of the miner, then use the lookup service to map that to a <code>libp2p</code> <code>peerID</code> and <code>multiaddr</code>.</p>
   <p>The interface should match the exist libp2p content routing interface:</p>
<pre class="language-go highlight"><c- a>type</c-> ChainContentRouting <c- a>interface</c-> <c- p>{</c->
	FindProvidersAsync<c- p>(</c->ref Cid<c- p>,</c-> count <c- b>int</c-><c- p>)</c-> <c- o>&lt;-</c-><c- a>chan</c-> pstore<c- p>.</c->PeerInfo
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="6.7" id="retrieval-market-commands"><span class="secno">6.7. </span><span class="content">Retrieval Market Commands</span><a class="self-link" href="#retrieval-market-commands"></a></h3>
   <p>We will need to add a few commands to allow the user to interact with the <code>retrieval market</code>, and for developers to be able to script higher level applications on top of it.</p>
   <p>The command names here are not final, and are definitely subject to change later on once we are able to sit and think through proper UX.</p>
<pre class="language-text highlight">USAGE
  filecoin retr get &lt;piece-cid> - Retrieve a piece from a miner.

SYNOPSIS
  filecoin retr get [--price=&lt;amt>] [--miner=&lt;peerID>] [--] &lt;piece-cid>

ARGUMENTS

  &lt;piece-cid> - Content ID of piece to retrieve.

OPTIONS

  --price                string - Amount of filecoin to offer for this data.
  --miner                string - Optional Peer ID of miner to connect to. (If unspecified, the chain routing service will be used)
</pre>
<pre class="language-text highlight">USAGE
  filecoin retr lookup &lt;piece-cid> - Print a list of miners who have the given piece.

SYNOPSIS
  filecoin retr lookup [--sort=&lt;sorttype>] [--] &lt;piece-cid>

ARGUMENTS

  &lt;piece-cid>... - Content ID of piece to find.

OPTIONS

  --sort                string - Output sorting scheme.
</pre>
<pre class="language-text highlight">USAGE
  filecoin retr query &lt;minerID> [&lt;piece-cid>] - Query the given retrieval miner.

SYNOPSIS
  filecoin retr query [--] &lt;miner-id> [&lt;piece-cid>]

ARGUMENTS

  &lt;miner-id>  - ID of miner to query.
  [&lt;piece-cid>] - Optional cid of piece to query for.
</pre>
   <h2 class="heading settled" data-level="7" id="payments①"><span class="secno">7. </span><span class="content">Payments</span><a class="self-link" href="#payments①"></a></h2>
   <h3 class="heading settled" data-level="7.1" id="what-are-payments"><span class="secno">7.1. </span><span class="content">What are payments</span><a class="self-link" href="#what-are-payments"></a></h3>
   <h3 class="heading settled" data-level="7.2" id="what-payments-affect"><span class="secno">7.2. </span><span class="content">What payments affect</span><a class="self-link" href="#what-payments-affect"></a></h3>
   <h3 class="heading settled" data-level="7.3" id="dependencies②"><span class="secno">7.3. </span><span class="content">Dependencies</span><a class="self-link" href="#dependencies②"></a></h3>
   <h3 class="heading settled" data-level="7.4" id="miners-claiming-earnings"><span class="secno">7.4. </span><span class="content">Miners Claiming Earnings</span><a class="self-link" href="#miners-claiming-earnings"></a></h3>
   <p>Storage miners get paid entirely through payment channels. Payment from a client to a storage miner comes in the form of a set of channel updates that get created when proposing the deal. These updates are each time-locked, and can only be cashed out if the storage miner has not been slashed for the storage that is being paid for. (TODO: working on a multi-lane payment channel construction that should make this all pretty easy, only requiring a single on-chain channel construction between each client and storage miner).</p>
   <h3 class="heading settled" data-level="7.5" id="payment-channels"><span class="secno">7.5. </span><span class="content">Payment Channels</span><a class="self-link" href="#payment-channels"></a></h3>
   <p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p>
   <p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says "this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period". Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p>
   <p>For example:</p>
   <ul>
    <li data-md>
     <p>User A locks up 10 FIL to B</p>
    <li data-md>
     <p>User B does something for A</p>
    <li data-md>
     <p>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</p>
    <li data-md>
     <p>User B does something for user A</p>
    <li data-md>
     <p>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</p>
   </ul>
   <p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p>
   <h4 class="heading settled" data-level="7.5.1" id="simple-payment-channel-actor"><span class="secno">7.5.1. </span><span class="content">Simple Payment Channel Actor</span><a class="self-link" href="#simple-payment-channel-actor"></a></h4>
   <p>We need to implement an actor to allow the creation of payment channels between users. The interface for that should look something like this:</p>
<pre class="language-go highlight"><c- a>type</c-> ChannelID <c- o>*</c->big<c- p>.</c->Int
<c- a>type</c-> BlockHeight <c- o>*</c->big<c- p>.</c->Int
<c- a>type</c-> Signature <c- p>[]</c-><c- b>byte</c->

<c- a>type</c-> SpendVoucher <c- a>struct</c-> <c- p>{</c->
    Channel ChannelID
    Amount <c- o>*</c->TokenAmount
    Sig Signature
<c- p>}</c->

<c- a>type</c-> PaymentBroker <c- a>interface</c-> <c- p>{</c->
    <c- c1>// CreateChannel creates a new payment channel from the caller to the target.</c->
    <c- c1>// The value attached to the invocation is used as the deposit, and the channel</c->
    <c- c1>// will expire and return all of its money to the owner after the given block height.</c->
    CreateChannel<c- p>(</c->target Address<c- p>,</c-> eol BlockHeight<c- p>)</c-> ChannelID

    <c- c1>// Update updates the payment channel with the given amounts, and sends the current</c->
    <c- c1>// committed amount to the target. This is useful when you want to checkpoint the</c->
    <c- c1>// value in a payment, but continue to use the channel afterwards.</c->
    Update<c- p>(</c->channel ChannelID<c- p>,</c-> amt <c- o>*</c->TokenAmount<c- p>,</c-> sig Signature<c- p>)</c->

    <c- c1>// Close is called by the target of a payment channel to cash out and close out</c->
    <c- c1>// the payment channel. This is really a courtesy call, as the channel will</c->
    <c- c1>// eventually time out and close on its own.</c->
    Close<c- p>(</c->channel ChannelID<c- p>,</c-> amt <c- o>*</c->TokenAmount<c- p>,</c-> sig Signature<c- p>)</c->

    <c- c1>// Extend can be used by the owner of a channel to add more funds to it and</c->
    <c- c1>// extend the channels lifespan.</c->
    Extend<c- p>(</c->target Address<c- p>,</c-> channel ChannelID<c- p>,</c-> eol BlockHeight<c- p>)</c->

    <c- c1>// Reclaim is used by the owner of a channel to reclaim unspent funds in timed</c->
    <c- c1>// out payment channels they own.</c->
    Reclaim<c- p>(</c->target Address<c- p>,</c-> channel ChannelID<c- p>)</c->
<c- p>}</c->

<c- c1>// MakeSpendVoucher is used by the owner of a channel to create an offline payment</c->
<c- c1>// for the target. Note that any amount may be given, but the target gets to select</c->
<c- c1>// which of the vouchers you give them to cash out, and therefore any rational actor</c->
<c- c1>// will only ever keep the one with the largest amount. After calling this function,</c->
<c- c1>// you should send the returned SpendVoucher to the target out of band.</c->
<c- a>func</c-> MakeSpendVoucher<c- p>(</c->ch ChannelID<c- p>,</c-> amt <c- o>*</c->TokenAmount<c- p>,</c-> sk PrivateKey<c- p>)</c-> <c- o>*</c->SpendVoucher <c- p>{</c->
    data <c- o>:=</c-> concatBytes<c- p>(</c->ch<c- p>,</c-> amt<c- p>)</c->
    sig <c- o>:=</c-> sk<c- p>.</c->Sign<c- p>(</c->data<c- p>)</c->
    <c- k>return</c-> <c- o>&amp;</c->SpendVoucher<c- p>{</c->
        Channel<c- p>:</c-> ch<c- p>,</c->
        Amount<c- p>:</c-> amt<c- p>,</c->
        Sig<c- p>:</c-> sig<c- p>,</c->
    <c- p>}</c->
<c- p>}</c->
</pre>
   <p>Channel IDs should be memory efficient and generated is such a way that reordering does not change the channelID. This may be solved by first indexing by the target address internally and then using the nonce of the message that invoked the create channel method.</p>
   <h4 class="heading settled" data-level="7.5.2" id="multi-lane-payment-channel-wip"><span class="secno">7.5.2. </span><span class="content">Multi-Lane Payment Channel (WIP)</span><a class="self-link" href="#multi-lane-payment-channel-wip"></a></h4>
   <p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction 'lane', meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p>
   <p>Let’s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on 'lane 1', for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on 'lane 2'. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to 'reconcile' the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p>
   <p>Lane state can be easily tracked on-chain with a compact bitfield.</p>
<pre class="language-go highlight"><c- a>type</c-> SpendVoucher <c- a>struct</c-> <c- p>{</c->
    <c- c1>// ID is the channel ID for this payment channel</c->
    ID ChannelID

    <c- c1>// Amount is the amount of FIL that this voucher can be redeemed for</c->
    Amount <c- o>*</c->TokenAmount

    <c- c1>// Nonce is a number that sets the ordering of vouchers. If you try to redeem</c->
    <c- c1>// a voucher with an equal or lower nonce, the operation will fail. Nonces are</c->
    <c- c1>// per lane.</c->
    Nonce <c- b>uint64</c->

    <c- c1>// Lane specifies which 'lane' of the payment channel this voucher is for.</c->
    <c- c1>// Lanes may be either open or closed, a voucher for a closed lane may not be redeemed</c->
    Lane <c- b>uint64</c->

    <c- c1>// Merges specifies a list of lane-nonce pairs that this voucher will close.</c->
    <c- c1>// This voucher may not be redeemed if any of the lanes specified here are already</c->
    <c- c1>// closed, or their nonce specified here is lower than the nonce on-chain.</c->
    Merges <c- p>[]</c->Pair<c- p>&lt;</c-><c- b>uint64</c-><c- p>,</c-> <c- b>uint64</c-><c- p>></c->

    Sig Signature
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="7.5.3" id="payment-channel-reconciliation"><span class="secno">7.5.3. </span><span class="content">Payment Channel Reconciliation</span><a class="self-link" href="#payment-channel-reconciliation"></a></h4>
   <p>In a situation where peers A and B  have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p>
   <h2 class="heading settled" data-level="8" id="payment-reconciliation"><span class="secno">8. </span><span class="content">Payment Reconciliation</span><a class="self-link" href="#payment-reconciliation"></a></h2>
    The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off-chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on-chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off-chain communication and end up with the miner submitting only a single message to the chain. 
   <p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p>
   <p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p>
<pre class="language-go highlight"><c- a>type</c-> ReconcileRequest <c- a>struct</c-> <c- p>{</c->
  Vouchers <c- p>[]</c->Vouchers

  ReqVal TokenAmount
<c- p>}</c->
</pre>
   <p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p>
   <p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set).  Then, he sends back a response which either contains the requested voucher, or an error status and message.</p>
<pre class="language-go highlight"><c- a>type</c-> ReconcileResponse <c- a>struct</c-> <c- p>{</c->
  Combined Voucher

  Status StatusCode
  Message <c- b>string</c->
<c- p>}</c->
</pre>
   <p>Open Questions:</p>
   <ul>
    <li data-md>
     <p>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</p>
    <li data-md>
     <p>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</p>
   </ul>
   <h3 class="heading settled" data-level="8.1" id="storage-miner-payments"><span class="secno">8.1. </span><span class="content">Storage Miner Payments</span><a class="self-link" href="#storage-miner-payments"></a></h3>
   <p>TODO: these bits were pulled out of a different doc, and describe strategies by which client payments to a miner might happen. We need to organize 'clients paying miners' better, unclear if it should be the same doc that talks about payment channel constructions.</p>
   <ol>
    <li data-md>
     <p><strong>Updates Contingent on Inclusion Proof</strong></p>
     <ul>
      <li data-md>
       <p>In this case, the miner must provide an inclusion proof that shows the client data is contained in one of the miners sectors on chain, and submit that along with the payment channel update.</p>
      <li data-md>
       <p>This can be pretty expensive for smaller files, and ideally, we make it to one of the latter two options</p>
      <li data-md>
       <p>This option does however allow clients to upload their files and leave.</p>
     </ul>
    <li data-md>
     <p><strong>Update Contingent on CommD Existence</strong></p>
     <ul>
      <li data-md>
       <p>For this, the client needs to wait around until the miner finishes packing a sector, and computing its commD. The client then signs a set of payment channel updates that are contingent on the given commD existing on chain.</p>
      <li data-md>
       <p>This route makes it difficult for miners to re-seal smaller files (really, small files just suck)</p>
     </ul>
    <li data-md>
     <p><strong>Reconciled Payment</strong></p>
     <ul>
      <li data-md>
       <p>In either of the above cases, the miner may go back to the client and say "Look, these payment channel updates you gave me are able to be cashed in right now, could you take them all and give me back a single update for a slightly smaller amount?".</p>
      <li data-md>
       <p>The slightly smaller amount could be the difference in transaction fees, meaning the client saves money, and the miner gets the same amount.</p>
     </ul>
   </ol>
   <h2 class="heading settled" data-level="9" id="mining①"><span class="secno">9. </span><span class="content">Mining</span><a class="self-link" href="#mining①"></a></h2>
   <h3 class="heading settled" data-level="9.1" id="what-is-the-filecoin-mining-process"><span class="secno">9.1. </span><span class="content">What is the Filecoin Mining Process</span><a class="self-link" href="#what-is-the-filecoin-mining-process"></a></h3>
   <p>An active participant in the filecoin consensus process is a storage miner and expected consensus block proposer. They are responsible for storing data for the filecoin network and also for driving the filecoin consensus process. Miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block for each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p>
   <p>Any block proposer must be a storage miner, but storage miners can avoid performing the block proposer tasks, however in this way, they will be losing out on block rewards and transaction fees.</p>
   <h3 class="heading settled" data-level="9.2" id="the-miner-actor"><span class="secno">9.2. </span><span class="content">The Miner Actor</span><a class="self-link" href="#the-miner-actor"></a></h3>
   <p>After successfully calling <code>CreateMiner</code>, a miner actor will be created on-chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p>
   <p>For details on the methods on the miner actor, see its entry in the <a href="actors.md#storage-miner-actor">actors spec</a>.</p>
   <h4 class="heading settled" data-level="9.2.1" id="owner-worker-distinction"><span class="secno">9.2.1. </span><span class="content">Owner Worker distinction</span><a class="self-link" href="#owner-worker-distinction"></a></h4>
   <p>The miner actor has two distinct 'controller' addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a 'hot wallet' key.</p>
   <h4 class="heading settled" data-level="9.2.2" id="storage-mining-cycle"><span class="secno">9.2.2. </span><span class="content">Storage Mining Cycle</span><a class="self-link" href="#storage-mining-cycle"></a></h4>
   <p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner’s entire storage.</p>
   <h5 class="heading settled" data-level="9.2.2.1" id="step-0-registration"><span class="secno">9.2.2.1. </span><span class="content">Step 0: Registration</span><a class="self-link" href="#step-0-registration"></a></h5>
   <p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage market actor’s [<code>CreateMiner</code>](actors.md#createminer) method. The call will then create a new miner actor instance and return its address.</p>
   <p>The next step is to place one or more storage market asks on the market. This is done through the storage markets [<code>AddAsk</code>](actors.md#addask) method. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>
   <p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the section on <a href="storage-market.md#deal-flow">deal flow</a>.</p>
   <p>When they have a full sector, they should seal it. This is done by invoking [<code>PoRep.Seal</code>](proofs.md#seal) on the sector.</p>
   <h5 class="heading settled" data-level="9.2.2.2" id="step-1-commit"><span class="secno">9.2.2.2. </span><span class="content">Step 1: Commit</span><a class="self-link" href="#step-1-commit"></a></h5>
   <p>When the miner has completed their first seal, they should post it on-chain using <a href="actors.md#commit-sector">CommitSector</a>. If the miner had zero committed sectors prior to this call, this begins their proving period.</p>
   <p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p>
   <p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.</p>
   <p>TODO: sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on-chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</p>
   <h5 class="heading settled" data-level="9.2.2.3" id="step-2-proving-storage-post-creation"><span class="secno">9.2.2.3. </span><span class="content">Step 2: Proving Storage (PoSt creation)</span><a class="self-link" href="#step-2-proving-storage-post-creation"></a></h5>
   <p>At the beginning of their proving period, miners collect the proving set (the set of all live sealed sectors on the chain at this point), and then call <code>ProveStorage</code>. This process will take the entire proving period to complete.</p>
<pre class="language-go highlight"><c- a>func</c-> ProveStorage<c- p>(</c->sectors <c- p>[]</c->commR<c- p>,</c-> startTime BlockHeight<c- p>)</c-> <c- p>(</c->PoSTProof<c- p>,</c-> <c- p>[]</c->Fault<c- p>)</c-> <c- p>{</c->
    proofs <c- p>[]</c->Proofs
    seeds <c- p>[]</c->Seed
    faults <c- p>[]</c->Fault
    <c- k>for</c-> t <c- o>:=</c-> <c- mi>0</c-><c- p>;</c-> t <c- p>&lt;</c-> ProvingPeriod<c- p>;</c-> t <c- o>+=</c-> ReseedPeriod <c- p>{</c->
        seeds <c- p>=</c-> append<c- p>(</c->seeds<c- p>,</c-> GetSeedFromBlock<c- p>(</c->startTime <c- o>+</c-> t<c- p>))</c->
        proof<c- p>,</c-> fault <c- o>:=</c-> GenPost<c- p>(</c->sectors<c- p>,</c-> seeds<c- p>[</c->t<c- p>],</c-> vdfParams<c- p>)</c->
        proofs <c- p>=</c-> append<c- p>(</c->proofs<c- p>,</c-> proof<c- p>)</c->
        faults <c- p>=</c-> append<c- p>(</c->faults<c- p>,</c-> fault<c- p>)</c->
    <c- p>}</c->
    <c- k>return</c-> GenPostSnark<c- p>(</c->sectors<c- p>,</c-> seeds<c- p>,</c-> proofs<c- p>),</c-> faults
<c- p>}</c->
</pre>
   <p class="note" role="note"><span>Note:</span> See <a href="proofs.md#proof-of-space-time">'Proof of Space Time'</a> for more details.</p>
   <p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p>
   <h5 class="heading settled" data-level="9.2.2.4" id="step-3-post-submission"><span class="secno">9.2.2.4. </span><span class="content">Step 3: PoSt Submission</span><a class="self-link" href="#step-3-post-submission"></a></h5>
   <p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="actors.md#submit-post">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p>
   <ol>
    <li data-md>
     <p><strong>Standard Submission</strong>: A standard submission is one that makes it on-chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</p>
    <li data-md>
     <p><strong>Penalized Submission</strong>: A penalized submission is one that makes it on-chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See '<a href="../faults.md">Faults</a>' for more information)</p>
   </ol>
   <blockquote>
    <p class="note" role="note"><span>Note:</span> In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</p>
   </blockquote>
   <p>Along with the PoSt submission, miners may also subit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the 'done' bitfield passed to <code>SubmitPoSt</code>.</p>
   <h4 class="heading settled" data-level="9.2.3" id="stop-mining"><span class="secno">9.2.3. </span><span class="content">Stop Mining</span><a class="self-link" href="#stop-mining"></a></h4>
   <p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call [<code>DePledge()</code>](actors.md#depledge) to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p>
   <h4 class="heading settled" data-level="9.2.4" id="faults"><span class="secno">9.2.4. </span><span class="content">Faults</span><a class="self-link" href="#faults"></a></h4>
   <p>Faults are described in the <a href="../faults.md">faults document</a>.</p>
   <h4 class="heading settled" data-level="9.2.5" id="on-being-slashed-wip-needs-discussion"><span class="secno">9.2.5. </span><span class="content">On Being Slashed (WIP, needs discussion)</span><a class="self-link" href="#on-being-slashed-wip-needs-discussion"></a></h4>
   <p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miners clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with 'refilling' their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p>
   <p>TODO: disambiguate the two collaterals across the entire spec</p>
   <p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p>
   <h3 class="heading settled" data-level="9.3" id="mining-blocks"><span class="secno">9.3. </span><span class="content">Mining Blocks</span><a class="self-link" href="#mining-blocks"></a></h3>
   <p>Having registered as a miner, it’s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest <a href="./expected-consensus.md#tipsets">TipSets</a> seen on the network.</p>
   <p>For additional details around how consensus works in Filecoin, see the <a href="./expected-consensus.md">expected consensus spec</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how "Tickets" should be validated during block validation.</p>
   <h4 class="heading settled" data-level="9.3.1" id="receiving-blocks"><span class="secno">9.3.1. </span><span class="content">Receiving Blocks</span><a class="self-link" href="#receiving-blocks"></a></h4>
   <p>When receiving blocks from the network (via <a href="data-propagation.md">block propagation</a>), a miner must do the following:</p>
   <ol>
    <li data-md>
     <p>Check their validity (see <a href="#block-validation">below</a>).</p>
    <li data-md>
     <p>Assemble a TipSet with all valid blocks with common parents and the same number of tickets in their <code>Tickets</code> array.</p>
   </ol>
   <p>A miner may sometimes receive blocks belonging to different TipSets (i.e. whose parents are not the same). In that case, they must choose which TipSet to mine on.</p>
   <p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier TipSet rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="./expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p>
   <h4 class="heading settled" data-level="9.3.2" id="block-validation"><span class="secno">9.3.2. </span><span class="content">Block Validation</span><a class="self-link" href="#block-validation"></a></h4>
   <p>The block structure and serialization is detailed in <a href="data-structures.md#block">the datastructures spec</a>. Check there for details on fields and types.</p>
   <p>In order to validate a block coming in from the network at round <code>N</code> was well mined a miner must do the following:</p>
<pre class="language-go highlight"><c- a>func</c-> VerifyBlock<c- p>(</c->blk Block<c- p>)</c-> <c- p>{</c->
    <c- c1>// 1. Verify Signature</c->
    pubk <c- o>:=</c-> GetPublicKey<c- p>(</c->blk<c- p>.</c->Miner<c- p>)</c->
    <c- k>if</c-> <c- p>!</c->ValidateSignature<c- p>(</c->blk<c- p>.</c->Signature<c- p>,</c-> pubk<c- p>,</c-> blk<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"invalid block signature"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// 2. Verify ParentWeight</c->
    <c- k>if</c-> blk<c- p>.</c->ParentWeight <c- o>!=</c-> ComputeWeight<c- p>(</c->blk<c- p>.</c->Parents<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"invalid parent weight"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// 3. Verify Tickets</c->
    <c- k>if</c-> <c- p>!</c->VerifyTickets<c- p>(</c->blk<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"tickets were invalid"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// 4. Verify ElectionProof</c->
    randomnessLookbackTipset <c- o>:=</c-> RandomnessLookback<c- p>(</c->blk<c- p>)</c->
    lookbackTicket <c- o>:=</c-> minTicket<c- p>(</c->randomnessLookbackTipset<c- p>)</c->
    challenge <c- o>:=</c-> sha256<c- p>.</c->Sum<c- p>(</c->lookbackTicket<c- p>)</c->

    <c- k>if</c-> <c- p>!</c->ValidateSignature<c- p>(</c->blk<c- p>.</c->ElectionProof<c- p>,</c-> pubk<c- p>,</c-> challenge<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"election proof was not a valid signature of the last ticket"</c-><c- p>)</c->
    <c- p>}</c->

    powerLookbackTipset <c- o>:=</c-> PowerLookback<c- p>(</c->blk<c- p>)</c->
    minerPower <c- o>:=</c-> GetPower<c- p>(</c->powerLookbackTipset<c- p>.</c->state<c- p>,</c-> blk<c- p>.</c->Miner<c- p>)</c->
    totalPower <c- o>:=</c-> GetTotalPower<c- p>(</c->powerLookbackTipset<c- p>.</c->state<c- p>)</c->
    <c- k>if</c-> <c- p>!</c->IsProofAWinner<c- p>(</c->blk<c- p>.</c->ElectionProof<c- p>,</c-> minerPower<c- p>,</c-> totalPower<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"election proof was not a winner"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// 5. Verify StateRoot</c->
    state <c- o>:=</c-> GetParentState<c- p>(</c->blk<c- p>.</c->Parents<c- p>)</c->
    <c- k>for</c-> i<c- p>,</c-> msg <c- o>:=</c-> <c- k>range</c-> blk<c- p>.</c->Messages <c- p>{</c->
        receipt <c- o>:=</c-> ApplyMessage<c- p>(</c->state<c- p>,</c-> msg<c- p>)</c->
        <c- k>if</c-> receipt <c- o>!=</c-> blk<c- p>.</c->MessageReceipts<c- p>[</c->i<c- p>]</c-> <c- p>{</c->
            Fatal<c- p>(</c-><c- s>"message receipt mismatch"</c-><c- p>)</c->
        <c- p>}</c->
    <c- p>}</c->
    <c- k>if</c-> state<c- p>.</c->Cid<c- p>()</c-> <c- o>!=</c-> blk<c- p>.</c->StateRoot <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"state roots mismatch"</c-><c- p>)</c->
    <c- p>}</c->
<c- p>}</c->
</pre>
   <p>Ticket validation is detailed as follows:</p>
<pre class="language-go highlight"><c- a>func</c-> RandomnessLookback<c- p>(</c->blk Block<c- p>)</c-> TipSet <c- p>{</c->
    <c- k>return</c-> chain<c- p>.</c->GetAncestorTipset<c- p>(</c->blk<c- p>,</c-> K<c- p>)</c->
<c- p>}</c->

<c- a>func</c-> PowerLookback<c- p>(</c->blk Block<c- p>)</c-> TipSet <c- p>{</c->
    <c- k>return</c-> chain<c- p>.</c->GetAncestorTipset<c- p>(</c->blk<c- p>,</c-> L<c- p>)</c->
<c- p>}</c->

<c- a>func</c-> IsProofAWinner<c- p>(</c->p ElectionProof<c- p>,</c-> minersPower<c- p>,</c-> totalPower Integer<c- p>)</c-> <c- b>bool</c-> <c- p>{</c->
    <c- k>return</c-> Integer<c- p>.</c->FromBytes<c- p>(</c->sha256<c- p>.</c->Sum<c- p>(</c->p<c- p>))</c-> <c- o>*</c-> totalPower <c- p>&lt;</c-> minersPower <c- o>*</c-> <c- mi>2</c-><c- p>^</c-><c- mi>32</c->
<c- p>}</c->

<c- a>func</c-> VerifyTickets<c- p>(</c->b Block<c- p>)</c-> <c- b>error</c-> <c- p>{</c->
    <c- c1>// Start with the &lt;code data-opaque bs-autolink-syntax='`Tickets`'>Tickets&lt;/code> array</c->
    <c- c1>// get the smallest ticket from the blocks parent tipset</c->
    parTicket <c- o>:=</c-> GetSmallestTicket<c- p>(</c->b<c- p>.</c->Parents<c- p>)</c->

    <c- c1>// Verify each ticket in the chain of tickets. There will be one ticket</c->
    <c- c1>// plus one ticket for each failed election attempt.</c->
    <c- k>for</c-> _<c- p>,</c-> ticket <c- o>:=</c-> <c- k>range</c-> b<c- p>.</c->Tickets <c- p>{</c->
    	challenge <c- o>:=</c-> sha256<c- p>.</c->Sum<c- p>(</c->parTicket<c- p>.</c->Signature<c- p>)</c->

        <c- c1>// Check VDF</c->
        <c- k>if</c-> <c- p>!</c->VerifyVDF<c- p>(</c->ticket<c- p>.</c->VDFProof<c- p>,</c-> ticket<c- p>.</c->VDFResult<c- p>,</c-> challenge<c- p>)</c-> <c- p>{</c->
            <c- k>return</c-> <c- s>"VDF was not run properly"</c->
        <c- p>}</c->

        <c- c1>// Check VRF</c->
    	pubk <c- o>:=</c-> getPublicKeyForMiner<c- p>(</c->b<c- p>.</c->Miner<c- p>)</c->
    	<c- k>if</c-> <c- p>!</c->VerifySignature<c- p>(</c->ticket<c- p>.</c->Signature<c- p>,</c-> pubk<c- p>,</c-> ticket<c- p>.</c->VDFResult<c- p>)</c-> <c- p>{</c->
        	<c- k>return</c-> <c- s>"Ticket was not a valid signature over the parent ticket"</c->
    	<c- p>}</c->
        <c- c1>// in case mining this block generated multiple tickets</c->
        parTicket <c- p>=</c-> ticket
    <c- p>}</c->

    <c- k>return</c-> <c- kc>nil</c->
<c- p>}</c->
</pre>
   <p>If all of this lines up, the block is valid. The miner repeats this for all blocks in a TipSet, and for all TipSets formed from incoming blocks.</p>
   <p>Once they’ve ensured all blocks in the heaviest TipSet received were properly mined, they can mine on top of it. If they weren’t, the miner may need to ensure the next heaviest <code>Tipset</code> was properly mined. This might mean the same <code>Tipset</code> with invalid blocks removed, or an altogether different one.</p>
   <p>If no valid blocks are received, a miner may mine atop the same <code>TipSet</code> running leader election again using the next ticket in the ticket chain, and also generating a <a href="./expected-consensus.md#losing-tickets">new ticket</a> in the process (see the <a href="./expected-consensus.md#losing-tickets">expected consensus spec</a> for more).</p>
   <h4 class="heading settled" data-level="9.3.3" id="ticket-generation"><span class="secno">9.3.3. </span><span class="content">Ticket Generation</span><a class="self-link" href="#ticket-generation"></a></h4>
   <p>For details of ticket generation, see the <a href="./expected-consensus#ticket-generation">expected consensus spec</a>.</p>
   <p>Ticket generation is the twin process of leader election (i.e. generating <code>ElectionProof</code>s). Every ticket scratch (i.e. round of leader election) has the miner generate a new ticket to include in the <code>Tickets</code> array of their block.</p>
   <p>New tickets are generated using the smallest ticket from the parent TipSet at height <code>H</code> and added to the <code>Tickets</code> array. Generating a new ticket will take some amount of time (as imposed by the VDF in Expected Consensus).</p>
   <p>Because of this, on expectation, as it is produced, the miner will hear about other blocks being mined on the network. By the time they have generated their new ticket, they can check whether they themselves are eligible to mine a new block.</p>
   <p>If the lookback ticket yields a valid <code>ElectionProof</code>, the miner publishes their block (see <a href="block-generation">block generation</a>) including the new ticket and earns a block reward. They then assemble a new TipSet using any valid blocks they heard about while generating the ticket  (likely of height <code>H+1</code>) and mine atop the smallest ticket in that new TipSet.</p>
   <h4 class="heading settled" data-level="9.3.4" id="scratching-a-losing-ticket"><span class="secno">9.3.4. </span><span class="content">Scratching a losing ticket</span><a class="self-link" href="#scratching-a-losing-ticket"></a></h4>
   <p>If a miner fails to generate a valid <code>ElectionProof</code> using their lookback ticket, they may not yet publish a new block at height <code>H+1</code>. The miner will likely hear about other blocks being mined on the network at height <code>H+1</code> and can thus assemble a new TipSet to mine off of with these blocks (as above).</p>
   <p>If the miner hears of no new blocks, they must instead draw a new ticket to scratch in order to try leader election again (as other miners will). In order to do so, they must generate a new ticket once more.</p>
   <p>Now, rather than generating this new ticket from the smallest ticket from the parent TipSet (as above), the miner will instead use their ticket from the last round, now in the <code>Tickets</code> array.</p>
   <p>This process is repeated until either a winning ticket is found (and block published) or a new valid TipSet comes in from the network. If a new TipSet comes in from the network, and it is heavier chain than the miner’s own, they should abandon their process to mine atop this new block. Due to the way chain selection works in filecoin, a chain with more blocks will be preferred (see the <a href="./expected-consensus.md#chain-selection">Expected Consensus spec</a> for more details).</p>
   <p>The <code>Tickets</code> array in the block to be published grows with each round (and a new ticket generated).</p>
   <h4 class="heading settled" data-level="9.3.5" id="block-creation"><span class="secno">9.3.5. </span><span class="content">Block Creation</span><a class="self-link" href="#block-creation"></a></h4>
   <p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p>
   <p>To create a block, the eligible miner must compute a few fields:</p>
   <ul>
    <li data-md>
     <p><code>Tickets</code> - An array containing a new ticket, and, if applicable, any intermediary tickets generated to prove appropriate delay for any failed election attempts. See <a href="./expected-consensus.md#ticket-generation">ticket generation</a>.</p>
    <li data-md>
     <p><code>ElectionProof</code> - A signature over the final ticket from the <code>Tickets</code> array proving. See <a href="./expected-consensus.md#ticket-generation">ticket generation</a>.</p>
    <li data-md>
     <p><code>ParentWeight</code> - As described in <a href="./expected-consensus.md#chain-weighting">Chain Weighting</a>.</p>
    <li data-md>
     <p><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:</p>
    <li data-md>
     <p>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</p>
    <li data-md>
     <p>For each block in the parent set, ordered by their tickets:</p>
     <ul>
      <li data-md>
       <p>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</p>
      <li data-md>
       <p>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</p>
      <li data-md>
       <p>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error.  Regardless of conflicts all messages are applied to the state.</p>
      <li data-md>
       <p>TODO: define message conflicts in the state-machine doc, and link to it from here</p>
     </ul>
    <li data-md>
     <p><code>MsgRoot</code> - To compute this:</p>
    <li data-md>
     <p>Select a set of messages from the mempool to include in the block.</p>
    <li data-md>
     <p>Insert them into a Merkle Tree and take its root.</p>
    <li data-md>
     <p><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.</p>
    <li data-md>
     <p><code>ReceiptsRoot</code> - To compute this:</p>
    <li data-md>
     <p>Apply the set of messages selected above to the parent state, collecting invocation receipts as this happens.</p>
    <li data-md>
     <p>Insert them into a Merkle Tree and take its root.</p>
    <li data-md>
     <p><code>BlockSig</code> - A signature with the miner’s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</p>
   </ul>
   <p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p>
   <p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks' parent TipSet, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re-applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipsets 'virtual block'. For more details on message execution and state transitions, see the <a href="state-machine.md">Filecoin state machine</a> document.</p>
   <p>Once the miner has the aggregate <code>ParentState</code>, they must apply the mining reward. This is done by adding the correct amount to the miner owner’s account balance in the state tree. See <a href="#block-rewards">block reward</a> for details.</p>
   <p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender’s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p>
   <p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value (see <a href="data-structures#message-receipt">receipt</a> for more details). Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p>
   <p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block’s <code>StateRoot</code>.</p>
   <p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p>
   <p>Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</p>
   <p>Now the block is complete, all that’s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p>
   <h5 class="heading settled" data-level="9.3.5.1" id="block-broadcast"><span class="secno">9.3.5.1. </span><span class="content">Block Broadcast</span><a class="self-link" href="#block-broadcast"></a></h5>
   <p>An eligible miner broadcasts the completed block to the network (via <a href="data-propagation.md">block propagation</a>), and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>
   <h4 class="heading settled" data-level="9.3.6" id="block-rewards"><span class="secno">9.3.6. </span><span class="content">Block Rewards</span><a class="self-link" href="#block-rewards"></a></h4>
   <p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. The reward amount remains fixed for a period of 1 week (given our 30 second block time, this  is 20,160 blocks, the <code>AdjustmentPeriod</code>) and is then adjusted. Over time, the reward will eventually become zero as the fractional amount given out at each step shrinks the network account’s balance to 0.</p>
   <p>The equation for the current block reward is of the form:</p>
<pre>Reward = IV * (Decay ^ (BlockHeight / 20160))
</pre>
   <p><code>IV</code> is the initial value, and is computed by taking:</p>
<pre>IV = TotalIssuance * (1 - Decay)
</pre>
   <p><code>Decay</code> is computed by:</p>
<pre>Decay = e^(ln(0.5) / (HalvingPeriodBlocks / AdjustmentPeriod))
</pre>
<pre>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2
</pre>
   <p class="note" role="note"><span>Note:</span> Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it’s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>
   <h3 class="heading settled" data-level="9.4" id="open-questions②"><span class="secno">9.4. </span><span class="content">Open Questions</span><a class="self-link" href="#open-questions②"></a></h3>
   <ul>
    <li data-md>
     <p>How should receipts for tipsets 'virtual blocks' be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</p>
   </ul>
   <h3 class="heading settled" data-level="9.5" id="future-work"><span class="secno">9.5. </span><span class="content">Future Work</span><a class="self-link" href="#future-work"></a></h3>
    There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future. 
   <ul>
    <li data-md>
     <p><strong>Sector Resealing</strong>: Miners should be able to 're-seal' sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</p>
    <li data-md>
     <p><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</p>
   </ul>
   <h2 class="heading settled" data-level="10" id="expected-consensus"><span class="secno">10. </span><span class="content">Expected Consensus</span><a class="self-link" href="#expected-consensus"></a></h2>
   <p>This spec describes how to implement the protocol in general, for Filecoin-specific processes, see:</p>
   <ul>
    <li data-md>
     <p><a href="mining.md#mining-blocks">Mining Blocks</a> on how consensus is used.</p>
    <li data-md>
     <p><a href="./faults.md">Faults</a> on slashing.</p>
    <li data-md>
     <p><a href="./storage-market.md#the-power-table">Storage Market</a> on how the power table is maintained.</p>
    <li data-md>
     <p><a href="data-structures.md#block">Block data structure</a> for details on fields and encoding.</p>
   </ul>
   <p>Important Concepts</p>
   <ul>
    <li data-md>
     <p>TipSet</p>
    <li data-md>
     <p>Weight</p>
    <li data-md>
     <p>Round</p>
    <li data-md>
     <p>Height</p>
    <li data-md>
     <p>Epoch</p>
    <li data-md>
     <p>Ticket</p>
    <li data-md>
     <p>ElectionProof</p>
   </ul>
   <blockquote>
    <p><strong>Definition:</strong> A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on an <code>ElectionProof</code> derived from a ticket. At least one new ticket is produced with every new block.</p>
   </blockquote>
   <blockquote>
    <p><strong>Definition:</strong> An <code>ElectionProof</code> is derived from a past ticket and included in every block header. The <code>ElectionProof</code> proves that the miner was eligible to mine a block in that round.</p>
   </blockquote>
   <blockquote>
    <p><strong>Definition:</strong> A <code>round</code> is the period in which a miner runs leader election to attempt to generate a new block. A new ticket is produced at every round, consequently the duration of a round is currently bounded by the duration of the Verifiable Delay Function run to generate a ticket. Tickets can be counted by round as one will be produced for each round.</p>
   </blockquote>
   <blockquote>
    <p><strong>Definition:</strong> <code>Height</code> refers to the number of <code>TipSets</code> a given block is built upon since genesis (height 0). Multiple blocks in a <code>TipSet</code> will have the same height.</p>
   </blockquote>
   <blockquote>
    <p><strong>Defintion:</strong> An <code>epoch</code> is the period in which a new block is generated. There may be multiple rounds in an epoch.</p>
   </blockquote>
   <blockquote>
    <p><strong>Definition:</strong> A <code>TipSet</code> is a set of blocks with the same parent set, and same number of tickets (which implies they will have been mined at the same height).</p>
   </blockquote>
   <p>Expected Consensus is a probabilistic Byzantine fault-tolerant consensus protocol. At a high
level, it operates by running a leader election every round in which, on expectation, one 
participant may be eligible to submit a block. All valid blocks submitted in a given round form a <code>TipSet</code>. Every block in a TipSet adds weight to its chain. The 'best' chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on this, see <a href="#chain-selection">Chain Selection</a>.</p>
   <p>The basic algorithms are as follows:</p>
   <p>For each block received over the network, <code>OnBlockReceived</code> is called. <code>VerifyBlock</code> is defined in the <a href="mining.md#block-validation">mining spec</a>.</p>
<pre class="language-go highlight"><c- a>func</c-> OnBlockReceived<c- p>(</c->blk Block<c- p>)</c-> <c- p>{</c->
    <c- c1>// The exact definition of IsValid depends on the protocol</c->
    <c- c1>// For Filecoin, see mining.md</c->
    <c- k>if</c-> VerifyBlock<c- p>(</c->blk<c- p>)</c-> <c- p>{</c->
        ChainTipsMgr<c- p>.</c->Add<c- p>(</c->blk<c- p>)</c->
    <c- p>}</c->
    
    <c- c1>// Received an invalid block!</c->
<c- p>}</c->
</pre>
   <p>Separately, another process is running <code>Mine</code> to attempt to generate blocks.</p>
<pre class="language-go highlight"><c- a>func</c-> Mine<c- p>(</c->minerKey PrivateKey<c- p>)</c-> <c- p>{</c->
    <c- k>for</c-> r <c- o>:=</c-> <c- k>range</c-> rounds <c- p>{</c-> <c- c1>// for each round</c->
        bestTipset<c- p>,</c-> tickets <c- o>:=</c-> ChainTipsMgr<c- p>.</c->GetBestTipsetAtRound<c- p>(</c->r<c- o>-</c-><c- mi>1</c-><c- p>)</c->
        
        ticket <c- o>:=</c-> GenerateTicket<c- p>(</c->minerKey<c- p>,</c-> bestTipset<c- p>)</c->
        tickets<c- p>.</c->Append<c- p>(</c->ticket<c- p>)</c->
        
        <c- c1>// Generate an election proof and check if we win</c->
        <c- c1>// Note: even if we don’t win, we want to make a ticket</c->
        <c- c1>// in case we need to mine a null round</c->
        win<c- p>,</c-> proof <c- o>:=</c-> CheckIfWinnerAtRound<c- p>(</c->minerKey<c- p>,</c-> r<c- p>,</c-> bestTipset<c- p>)</c->
        <c- k>if</c-> win <c- p>{</c->
            GenerateAndBroadcastBlock<c- p>(</c->bestTipset<c- p>,</c-> tickets<c- p>,</c-> proof<c- p>)</c->
        <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
            <c- c1>// Even if we don’t win, add our ticket to the tracker in </c->
            <c- c1>// case we need to mine on it later.</c->
            ChainTipsMgr<c- p>.</c->AddFailedTicket<c- p>(</c->bestTipset<c- p>,</c-> tickets<c- p>)</c->
        <c- p>}</c->
    <c- p>}</c->
<c- p>}</c->
</pre>
   <p><code>IsProofAWinner</code> is taken from <a href="mining.md#block-validation">the mining doc</a>.</p>
<pre class="language-go highlight"><c- a>const</c-> RandomnessLookback <c- p>=</c-> <c- mi>1</c-> <c- c1>// Also referred to as "K" in many places</c->
<c- a>const</c-> PowerLookback <c- p>=</c-> <c- mi>1</c-> <c- c1>// Also referred to as "L" in many places</c->

<c- a>func</c-> CheckIfWinnerAtRound<c- p>(</c->key PrivateKey<c- p>,</c-> n Integer<c- p>,</c-> parentTipset Tipset<c- p>)</c-> <c- p>(</c-><c- b>bool</c-><c- p>,</c-> ElectionProof<c- p>)</c-> <c- p>{</c->
    lbt <c- o>:=</c-> ChainTipsMgr<c- p>.</c->TicketFromRound<c- p>(</c->n <c- o>-</c-> RandomnessLookback<c- p>)</c->
    
    eproof <c- o>:=</c-> ComputeElectionProof<c- p>(</c->lbt<c- p>,</c-> key<c- p>)</c->
    
    tipset <c- o>:=</c-> ChainTipsMgr<c- p>.</c->TipsetFromRound<c- p>(</c->n <c- o>-</c-> PowerLookback<c- p>)</c->
    minerPower <c- o>:=</c-> GetPower<c- p>(</c->tipset<c- p>.</c->state<c- p>,</c-> key<c- p>.</c->Public<c- p>())</c->
    totalPower <c- o>:=</c-> GetTotalPower<c- p>(</c->tipset<c- p>.</c->state<c- p>)</c->
    
    <c- k>return</c-> IsProofAWinner<c- p>(</c->eproof<c- p>,</c-> minerPower<c- p>,</c-> totalPower<c- p>),</c-> eproof
<c- p>}</c->
</pre>
   <p>TODO: get accurate estimates for K and L, potentially merge both to a single param.</p>
   <p class="note" role="note"><span>Note:</span> Validity of blocks beyond appropriate ticket generation (defined below) is defined by the specific protocol using EC. For the Filecoin definition of a valid block, see the <a href="mining.md">mining spec</a>.</p>
   <p>The basic algorithm can be broken down by looking in turn at its two major components:</p>
   <ul>
    <li data-md>
     <p>Leader Election</p>
    <li data-md>
     <p>Chain Selection</p>
   </ul>
   <h3 class="heading settled" data-level="10.1" id="secret-leader-election"><span class="secno">10.1. </span><span class="content">Secret Leader Election</span><a class="self-link" href="#secret-leader-election"></a></h3>
   <p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the storage <a href="./storage-market.md#the-power-table">power table</a>, where power is equivalent to storage provided through time.</p>
   <p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin’s use of EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new ticket with each attempted election.</p>
   <p>In cases in which no winning ticket is found by any miner in a given round (i.e. no block is mined on the network), miners move on to the next ticket in the ticket chain to attempt a new leader election. When this happens, miners should nonetheless generate a new ticket prior to the new leader election, thereby appropriately prolonging the ticket chain (the block chain can never be longer than the ticket chain). This situation is fleshed out in the <a href="#losing-tickets">Losing Tickets</a> section.</p>
   <p>In order to pressure the network to converge on a single chain, each miner may only submit one block per round (see: <code>Slashing</code>).</p>
   <p>TODO: pictures of ticket chain and block chain</p>
   <h4 class="heading settled" data-level="10.1.1" id="tickets"><span class="secno">10.1.1. </span><span class="content">Tickets</span><a class="self-link" href="#tickets"></a></h4>
   <p>One may think of leader election in EC as a verifiable lottery, in which participants win in proportion to the power they have within the network.</p>
   <p>A ticket is drawn from the past at the beginning of each new round, and a new ticket is generated in every round. Tickets are chained independently of the main blockchain. A ticket only depends on the ticket before it, and not any other data in the block. Nonetheless, in Filecoin, every block header contains one or more new tickets, thereby extending the ticket chain. A miner generates a new ticket in their block for every ticket they scratch running leader election, thereby ensuring the ticket chain is at least as long as the block chain.</p>
   <p>At a high-level, tickets must do the following:</p>
   <ul>
    <li data-md>
     <p>Ensure leader secrecy -- meaning a block producer will not be known until they release their block to the network.</p>
    <li data-md>
     <p>Prove leader election -- meaning a block producer can be verified by any participant in the network.</p>
    <li data-md>
     <p>Prove appropriate delay between drawings — thereby preventing leaders from "rushing" the protocol by releasing blocks early (at the expense of fairness for miners with worse connectivity).</p>
    <li data-md>
     <p>Ensure a single drawing per round — derived in part from the above, thereby preventing miners from grinding on tickets (e.g. by repeatedly drawing new tickets in the hopes of winning) within a round.</p>
   </ul>
   <p>For tickets in EC, one may use the following:</p>
<pre class="language-go highlight"><c- a>type</c-> Ticket <c- a>struct</c-> <c- p>{</c->
    <c- c1>// The VDF Result is derived from the prior ticket in the ticket chain</c->
    VDFResult BigInteger
    <c- c1>// The VDF proves a delay between tickets generated</c->
    VDFProof BigInteger
    <c- c1>// This signature is generated by the miner’s keypair run on the VDFResult.</c->
    <c- c1>// It is the value that will be used to generate future tickets or ElectionProofs.</c->
    Signature Signature
<c- p>}</c->
</pre>
   <p>In practice, EC defines two different fields within a block:</p>
   <ul>
    <li data-md>
     <p>A <code>Tickets</code> array — this stores new tickets generated during this epoch, or block generation attempt. It proves appropriate delay. It is from this array that miners will sample randomness to run leader election in <code>K</code> rounds. See <a href="#ticket-generation">Ticket generation</a>.</p>
    <li data-md>
     <p>An <code>ElectionProof</code> — this stores a proof that a given miner scratched a winning lottery ticket using the appropriate ticket <code>K</code> rounds back. It proves that the leader was elected in this round. See <a href="#checking-election-results">Checking election results</a>.</p>
   </ul>
   <p>On expectation, the <code>Tickets</code> array will contain a single ticket. For cases in which it contains more than one, see <a href="#losing-tickets">Losing Tickets</a>.</p>
<pre>On the two uses of tickets.

Tickets serve two main purposes.

1) As a proof that blocks were appropriately delayed. This both prevents miners grinding through tickets in a given epoch and a winner rushing the protocol by publishing
blocks as fast as possible (thereby penalizing poorly connected miners).

This is a result of a new ticket being generated by the miner for every leader election
attempt (using a ticket from the past). This ticket is generated using the ticket from
the prior block, or "losing" tickets generated in this epoch.

2) As a source of randomness used to prove that a leader was correctly elected. 

This is done by generating an 'ElectionProof' derived from a ticket sampled K rounds
back.

But why the lookback?

The lookback helps turn independent lotteries (ticket drawings from a block one round back)
into a global lottery instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.
</pre>
   <h5 class="heading settled" data-level="10.1.1.1" id="ticket-generation①"><span class="secno">10.1.1.1. </span><span class="content">Ticket generation</span><a class="self-link" href="#ticket-generation①"></a></h5>
   <p>This section discusses how tickets are generated for the <code>Tickets</code> array.</p>
   <p>At round <code>N</code>, new tickets are generated using tickets drawn from the <a href="#tipsets">TipSet</a> at round <code>N-1</code>. This ensures the miner cannot publish a new block (corresponding to the <code>ElectionProof</code> generated by a winning ticket <code>K</code> rounds back) until the correct round.</p>
   <p>Because a Tipset can contain multiple blocks (see <a href="#chain-selection">Chain Selection</a> below), the smallest ticket in the Tipset must be drawn otherwise the block will be invalid.</p>
   <p>TODO: pictures of TipSet ticket drawing</p>
   <p>The miner runs the prior ticket through a Verifiable Delay Function (VDF) to get a new unique output. This approximates clock synchrony for miners, thereby ensuring miners have waited an appropriate delay ahead of drawing a new ticket. It also establishes a lower-bound delay between production of new blocks at different heights. This helps ensure fairness, in that miners with lesser connectivity are not penalized and have a chance to produce blocks.</p>
   <p>This output is then used as input into a Verifiable Random Function (VRF) generating a new ticket, different from any other miners'. This adds entropy to the ticket chain, limiting a miner’s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p>
   <p>Succinctly, the process of crafting a new ticket in round <code>N</code> is as follows:</p>
<pre>old_ticket := sort(parentTickets)[0]
new_ticket := Sig(VDF(H(old_ticket)))

new_ticket: ticket to be used at round N in case of block generation
old_ticket: ticket drawn from round N-1
H: Cryptographic compression function
sort: bytewise sort
VDF: Verifiable Delay Function
Sig: Signature with the miner’s keypair, used as a Verifiable Random Function.
</pre>
   <h5 class="heading settled" data-level="10.1.1.2" id="checking-election-results"><span class="secno">10.1.1.2. </span><span class="content">Checking election results</span><a class="self-link" href="#checking-election-results"></a></h5>
   <p>Now, a miner must also check whether they have won in this round.</p>
   <p>The process is as follows:</p>
   <ul>
    <li data-md>
     <p>At round N, the miner will draw the smallest ticket from the TipSet at round <code>N-K</code>, with <code>K</code> the randomness lookback parameter.</p>
    <li data-md>
     <p>In the case where there are multiple tickets to choose from at round <code>N-K</code> (i.e. if the TipSet eventually created has multiple blocks), miners should attempt to generate their <code>ElectionProof</code> from the ticket generated by the block with the smallest final ticket (i.e. not necessarily the smallest ticket generated at that round).</p>
    <li data-md>
     <p>The miner will use this ticket as input to a VRF (Verifiable Random Function), thereby ensuring secrecy: no other participant can generate this output without the miner’s private key. In that sense whether the miner has scratched a winning ticket remains a secret until they release their <code>ElectionProof</code> along with a new block.</p>
    <li data-md>
     <p>The miner will compare the output to their power fraction from round <code>N-L</code>, with <code>L</code> the committee lookback parameter. If it is smaller, they have won and can mine a block inserting this winning <code>ElectionProof</code> in the block header for the block produced at round <code>N</code>. Else they wait to hear of another block generated in this round.</p>
   </ul>
   <p>At round N:</p>
<pre>electionProof = Sig(H(SampleRandomness(CurrentRound - K)))

Sig: Signature with the miner’s keypair, used as a VRF.
H: Cryptographic compression function
sort: bytewise sort
SampleRandomness: returns the appropriate ticket from round N-K
</pre>
   <p>It is important to note that a miner generates two artifacts: one, a ticket derived from last block’s ticket to prove that they have waited the appropriate delay, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p>
   <p>Typically, either a miner will generate a winning ticket (see <a href="#block-generation">Block Generation</a> or will hear about a new block (or multiple) by the end of a round (and start mining atop the smallest ticket of this new TipSet). The round may also have no successful miners.</p>
   <h4 class="heading settled" data-level="10.1.2" id="losing-tickets"><span class="secno">10.1.2. </span><span class="content">Losing Tickets</span><a class="self-link" href="#losing-tickets"></a></h4>
   <p>In the case that everybody draws a losing ticket in a given round (i.e. no miner is eligible to produce a block), every miner can run leader election again by "scratching" (attempting to generate a new <code>ElectionProof</code> from) the next ticket in the chain. That is, miners will now use the ticket sampled <code>K-1</code> rounds back to generate a new <code>ElectionProof</code>. They can then compare that proof with their power in the table <code>N-(L-1)</code> blocks back. This is repeated until a miner scratches a winning ticket and can publish a block (see <a href="#block-generation">Block Generation</a>).</p>
   <p>In addition to each attempted <code>ElectionProof</code> generation, the miner will need to extend the ticket chain by generating a new ticket. They use the ticket they generated in the prior round, rather than the prior block’s (as is normally used). This proves appropriate delay (given that finding a winning Ticket has taken multiple rounds). Thus, each time it is discovered that nobody has won in a given round, every miner should use their previously generated ticket to repeat the ticket generation process, appending said ticket to their would-be block’s <code>Ticket</code> array. This continues until some miner finds a winning ticket (see below), ensuring that the ticket chain remains at least as long as the block chain.</p>
   <p>As was stated above, in the case where there are multiple tickets to choose from at round <code>N-K</code> (i.e. if the TipSet eventually created has multiple blocks), miners should attempt to generate their <code>ElectionProof</code> from the ticket generated by the block with the smallest final ticket (i.e. not necessarily the smallest ticket generated at that round). Put another way, the block in a TipSet with the smallest final ticket prolongs the valid ticket chain.</p>
   <p>TODO: Add a diagram to illustrate this</p>
   <p>The VDF ensures fairness by enforcing that miners cannot grind through repeated losing tickets (see more <a href="https://github.com/filecoin-project/research/issues/31">here</a>) and that a miner cannot "rush" the protocol by outputting a block before others have had a chance to (e.g. geographically disadvantaged miners). The VDF delay is currently to 30 seconds, given estimated network propagation times.</p>
   <p>Thus, our full ticket generation algorithm (reprised from <a href="#ticket-generation">Ticket Generation</a>) is roughly (ticket handling is simplified in the pseudocode below for legibility):</p>
<pre class="language-go highlight"><c- c1>// Ticket is created as an array, with the initial ticket</c->
<c- c1>// coming from the parent TipSet.</c->
<c- a>var</c-> Tickets <c- p>[]</c->Ticket
oldTicket <c- o>:=</c-> sort<c- p>(</c->parentTickets<c- p>)[</c-><c- mi>0</c-><c- p>]</c->
newTicket <c- o>:=</c-> VRF<c- p>(</c->VDF<c- p>(</c->H<c- p>(</c->oldTicket<c- p>)))</c->
electionProof <c- o>:=</c-> VRF<c- p>(</c->H<c- p>(</c->ticketFromRound<c- p>(</c->curRound<c- o>-</c->K<c- p>)))</c->

Tickets <c- p>=</c-> append<c- p>(</c->Tickets<c- p>,</c-> newTicket<c- p>)</c->

<c- c1>// If the current ticket isn’t a winner and the block isn’t found by another miner,</c->
<c- c1>// derive a ticket from the last ticket</c->
<c- k>for</c-> <c- p>!</c->IsProofAWinner<c- p>(</c->electionProof<c- p>)</c-> <c- o>&amp;&amp;</c-> <c- p>!</c->blockFound<c- p>())</c-> <c- p>{</c->
 newTicket <c- p>=</c-> VRF<c- p>(</c->VDF<c- p>(</c->H<c- p>(</c->newTicket<c- p>)))</c->
 newElectionProof <c- p>=</c-> Sig<c- p>(</c->H<c- p>(</c->ticketFromRound<c- p>(</c->curRound<c- o>-</c->K<c- p>)))</c->
 Tickets <c- p>=</c-> append<c- p>(</c->Tickets<c- p>,</c-> newTicket<c- p>)</c->
 curRound <c- o>+=</c-> <c- mi>1</c->
<c- p>}</c->

<c- c1>// if the process yields a winning ticket, mine and put out a block</c->
<c- c1>// containing the ticket array</c->
<c- k>if</c-> winning<c- p>(</c->electionProof<c- p>)</c-> <c- p>{</c->
    mineBlock<c- p>(</c->electionProof<c- p>,</c-> Tickets<c- p>)</c->
<c- p>}</c->
</pre>
   <p>A ticket can be verified to have been generated in the appropriate number of rounds by looking at the <code>Tickets</code> array, and ensuring that each subsequent ticket (leading to the final ticket in that array) was generated using the previous one in the array. Note that this has implications on block size, and client memory requirements, though on expectation, the <code>Ticket</code> array should only contain one value.</p>
   <p>In fact, the length of repeated losing tickets in the ticket chain (equivalent to the length of generated tickets referenced by a single block, or the length of the <code>Tickets</code> array) decreases exponentially in the number of repeated losing tickets (see more <a href="https://github.com/filecoin-project/go-filecoin/pull/1516">here</a>). In the unlikely case the number of losing tickets drawn by miners grows larger than the randomness lookback <code>K</code> (i.e. if a miner runs out of existing tickets on the ticket chain for use as randomness), a miner should proceed as usual using new tickets generated in this epoch for randomness. This has no impact on the protocol safety/validity.</p>
   <p>New blocks (with multiple tickets) will have a few key properties:</p>
   <ul>
    <li data-md>
     <p>All tickets in the <code>Tickets</code> array are signed by the same miner -- to avoid grinding through out-of-band collusion between miners exchanging tickets.</p>
    <li data-md>
     <p>The <code>ElectionProof</code> was correctly generated from the ticket <code>K-|Tickets|-1</code> (with <code>|Tickets|</code> the length of the <code>Tickets</code> array) rounds back.</p>
   </ul>
   <p>This means that valid <code>ElectionProof</code>s can be generated from tickets in the middle of the <code>Tickets</code> array.</p>
   <h4 class="heading settled" data-level="10.1.3" id="block-generation"><span class="secno">10.1.3. </span><span class="content">Block Generation</span><a class="self-link" href="#block-generation"></a></h4>
   <p>Once a miner has a winning election proof generated over <code>i</code> rounds and <code>i</code> corresponding tickets, they may create a block. For more on this, see the <a href="./mining.md#block-creation">Mining spec</a>.</p>
   <h3 class="heading settled" data-level="10.2" id="chain-selection"><span class="secno">10.2. </span><span class="content">Chain Selection</span><a class="self-link" href="#chain-selection"></a></h3>
   <p>Just as there can have 0 miners win in a round, multiple miners can be elected in a given round . This in turn means multiple blocks can be created in a round. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round</p>
   <h4 class="heading settled" data-level="10.2.1" id="tipsets"><span class="secno">10.2.1. </span><span class="content">Tipsets</span><a class="self-link" href="#tipsets"></a></h4>
   <p>All valid blocks generated in a round form a <code>TipSet</code> that participants will attempt to mine off of in the subsequent round (see above). TipSets are valid so long as:</p>
   <ul>
    <li data-md>
     <p>All blocks in a TipSet have the same parent TipSet</p>
    <li data-md>
     <p>All blocks in a TipSet have the same number of tickets in their <code>Tickets</code> array</p>
   </ul>
   <p>The first condition implies that all blocks in a TipSet were mined at the same height (remember that height refers to block height as opposed to ticket round). This rule is key to helping ensure that EC converges over time. While multiple new blocks can be mined in a round, subsequent blocks all mine off of a TipSet bringing these blocks together. The second rule means blocks in a TipSet are mined in a same round.</p>
   <p>Due to network propagation delay, it is possible for a miner in round N+1 to omit valid blocks mined at round N from their TipSet. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol.</p>
   <h4 class="heading settled" data-level="10.2.2" id="chain-weighting"><span class="secno">10.2.2. </span><span class="content">Chain Weighting</span><a class="self-link" href="#chain-weighting"></a></h4>
   <p>TODO: ensure 'power' is properly and clearly defined</p>
   <p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on 'one true chain', with every block adding to the chain’s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin’s case, the most storage provided.</p>
   <p>The weight at each block is equal to its <code>ParentWeight</code>, plus that block’s delta weight. Delta
weight is a constant <code>V</code>, plus <code>X</code> - a function of the total power in the network as reported in the Power Table.  The exact value for <code>V</code> and the magnitude of the power ratio value are
still to be determined, but for now <code>V = 10</code> and <code>X = log(TotalPower)</code>.</p>
   <p><code>ParentWeight</code> is the aggregate chain weight of a given block’s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given TipSet should have 
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the 
computation a bit easier, a block’s <code>ParentWeight</code> is stored in the block itself (otherwise 
potentially long chain scans would be required to compute a given block’s weight).</p>
   <p>When selecting between TipSets of equal weight, a miner chooses the one with the smallest min ticket (by bytewise comparison).</p>
   <h4 class="heading settled" data-level="10.2.3" id="slashing"><span class="secno">10.2.3. </span><span class="content">Slashing</span><a class="self-link" href="#slashing"></a></h4>
   <p>See the <a href="./faults.md">Faults spec</a> for implementation details.</p>
   <p>Due to the existence of potential forks, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>
   <p>This happens in the following instances:</p>
   <ul>
    <li data-md>
     <p>A miner submits two blocks for the same round.</p>
    <li data-md>
     <p>A miner mines atop a TipSet that should have contained their own block (same height, same parents) but does not.</p>
    <li data-md>
     <p>A miner may omit their own block if they find a winning Ticket in the parent TipSet though they themselves have submitted a smaller (losing) ticket. While it cannot be proven that block omission from a TipSet is malicious (i.e. network latency could simply mean the miner did not receive a particular block), for obvious reasons, a miner must be are aware of the block they previously mined.</p>
    <li data-md>
     <p>Also: https://github.com/filecoin-project/consensus/issues/45#issuecomment-468035739</p>
   </ul>
   <p>Any node that detects this occurring should take both block headers, and call [<code>storagemarket.SlashConsensusFault</code>](actors.md#slashconsensusfault). The network will then take all of that node’s collateral, give a portion of it to
the reporter, and keep the rest.</p>
   <p>TODO: It is unclear that rewarding the reporter any more than gas fees is the right thing to do. Needs thought. Tracking issue: https://github.com/filecoin-project/specs/issues/159</p>
   <p class="note" role="note"><span>Note:</span> One may wonder what prevents miners from simply breaking up their power into multiple un-linkable miner actors  (or sybils) that will be able to mine on multiple chains without being caught mining at the same round at the same time. We call this the "whyru slashing" attack.</p>
   <p>TODO: Discuss with @zenground0 to ensure the below should not be removed</p>
<pre>An attacker with 30% of the power has a 30% chance of mining a block at any given moment.
During a fork, an attacker would have a 30% chance of winning _on each fork_, meaning
they could continue to mine on both forks, except for 30% of the time they win, they
will win on both chains and have to forgo publishing one of the blocks to avoid being
slashed. This means that the miner loses 30% of their expected rewards, but is still
able to mine on both chains. 

Now, if the miner instead controls two miners each with 15% of the total power in
the network, they still have a 30% chance of winning on each fork (using both sybils),
but they drop the probability of mining with the same miner at the same time on both
chains down to 15% of their winnings (meaning they have to forgo 15% of their
‘successfully’ mined blocks). This continues on down, 3 identities is 10%, 4 is 7.6%,
5 is 6% and so on. So at the end of the day, the miner can mine on both chains with
only a minimal loss in potential proceeds.

The above assumes that every election is an independent random process (even across forks).
However, using a lookback parameter for seed sampling, the independent lottery drawing
becomes a global lottery for all forks originating after the lookback (where the
randomness was drawn). That is to say, given a common random seed and public key, each
sybil will either win on all forks, or lose on all forks. This greatly decreases the
chances that this attack succeeds, erasing the economic advantage sybils created.
</pre>
   <h3 class="heading settled" data-level="10.3" id="implementation-notes"><span class="secno">10.3. </span><span class="content">Implementation Notes</span><a class="self-link" href="#implementation-notes"></a></h3>
   <ul>
    <li data-md>
     <p>When selecting messages from the mempool to include in the block, be aware that other miners may also generate blocks during this round, and to maximize fee earnings it may be best to select some messages at random (second in a duplicate earns no fees).</p>
   </ul>
   <h3 class="heading settled" data-level="10.4" id="open-questions③"><span class="secno">10.4. </span><span class="content">Open Questions</span><a class="self-link" href="#open-questions③"></a></h3>
   <ul>
    <li data-md>
     <p>Parameter K, Parameter L</p>
    <li data-md>
     <p>Checkpointing Strategy</p>
    <li data-md>
     <p>Block confirmation time</p>
    <li data-md>
     <p>When selecting between two forks of equal weight, one strategy might be to select the 'Tipset' with the lowest number of linked tickets for a given block height and weight.</p>
    <li data-md>
     <p>Should there be a minimum power required to participate in the consensus process?</p>
    <li data-md>
     <p>How long should 'valid' candidate blocks be kept around? Essentially the question is: when is finality?</p>
    <li data-md>
     <p>How should block rewards be assigned in the expected consensus setting?</p>
    <li data-md>
     <p>VDF difficulty adjustment</p>
   </ul>
   <h2 class="heading settled" data-level="11" id="state-machine"><span class="secno">11. </span><span class="content">State Machine</span><a class="self-link" href="#state-machine"></a></h2>
   <p>The majority of Filecoin’s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin State Machine. The network generates a series of blocks, and agrees which 'chain' of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>
   <p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>
   <p>An <code>actor</code> is the Filecoin equivalent of Ethereum’s smart contracts, it is essentially an 'object' in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>
   <h3 class="heading settled" data-level="11.1" id="method-invocation"><span class="secno">11.1. </span><span class="content">Method Invocation</span><a class="self-link" href="#method-invocation"></a></h3>
   <p>There are two routes to calling a method on an <code>actor</code>.</p>
   <p>First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of 'gas'. We also use 'gas').</p>
   <p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>
   <h3 class="heading settled" data-level="11.2" id="state-representation"><span class="secno">11.2. </span><span class="content">State Representation</span><a class="self-link" href="#state-representation"></a></h3>
   <p>The <code>global state</code> is modeled as a map of actor addresses to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT). Each actor’s <code>state</code> is an ipld pointer to a graph that can be entirely defined by the actor.</p>
   <h3 class="heading settled" data-level="11.3" id="execution-calling-a-method-on-an-actor"><span class="secno">11.3. </span><span class="content">Execution (Calling a method on an Actor)</span><a class="self-link" href="#execution-calling-a-method-on-an-actor"></a></h3>
   <p>Message execution currently relies entirely on 'built-in' code, with a common external interface. The method and actor to call it on are specified in the <code>Method</code> and <code>To</code> fields of a message, respectively. Method parameters are encoded and put into the <code>Params</code> field of a message. The encoding is a cbor array of each of the types individually encoded. The individual encodings for each type are as follows.</p>
   <p>These functions are given, as input, an <code>ExecutionContext</code> containing useful information for their execution.</p>
<pre class="language-go highlight"><c- a>type</c-> VMContext <c- a>interface</c-> <c- p>{</c->
	<c- c1>// Message is the message that kicked off the current invocation</c->
	Message<c- p>()</c-> Message

	<c- c1>// Storage provides access to the VM storage layer</c->
	Storage<c- p>()</c-> Storage

	<c- c1>// Send allows the current execution context to invoke methods on other actors in the system</c->
	Send<c- p>(</c->to address<c- p>.</c->Address<c- p>,</c-> method <c- b>string</c-><c- p>,</c-> value <c- o>*</c->types<c- p>.</c->AttoFIL<c- p>,</c-> params <c- p>[]</c-><c- a>interface</c-><c- p>{})</c-> <c- p>([][]</c-><c- b>byte</c-><c- p>,</c-> <c- b>uint8</c-><c- p>,</c-> <c- b>error</c-><c- p>)</c->

	<c- c1>// BlockHeight returns the height of the block this message was added to the chain in</c->
	BlockHeight<c- p>()</c-> <c- o>*</c->types<c- p>.</c->BlockHeight

	<c- c1>// CreateNewActor is used to create a new actor from the given code and constructor</c->
    <c- c1>// parameters (TODO: address should probably not be a parameter)</c->
	CreateNewActor<c- p>(</c->addr address<c- p>.</c->Address<c- p>,</c-> code cid<c- p>.</c->Cid<c- p>,</c-> initalizationParams <c- a>interface</c-><c- p>{})</c-> <c- b>error</c->
<c- p>}</c->
</pre>
   <p>If the execution completes successfully, changes to the state tree are saved. Otherwise, the message is marked as failed, and any state changes are reverted.</p>
<pre class="language-go highlight"><c- a>func</c-> ApplyMessage<c- p>(</c->st StateTree<c- p>,</c-> msg Message<c- p>)</c-> MessageReceipt <c- p>{</c->
    st<c- p>.</c->Snapshot<c- p>()</c->
    fromActor <c- o>:=</c-> st<c- p>.</c->GetActor<c- p>(</c->msg<c- p>.</c->From<c- p>)</c->

    totalCost <c- o>:=</c-> msg<c- p>.</c->Value <c- o>+</c-> <c- p>(</c->msg<c- p>.</c->GasLimit <c- o>*</c-> msg<c- p>.</c->GasPrice<c- p>)</c->
    <c- k>if</c-> fromActor<c- p>.</c->Balance <c- p>&lt;</c-> totalCost <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough funds"</c-><c- p>)</c->
    <c- p>}</c->

	<c- k>if</c-> msg<c- p>.</c->Nonce<c- p>()</c-> <c- o>!=</c-> fromActor<c- p>.</c->Nonce <c- o>+</c-> <c- mi>1</c-> <c- p>{</c->
		Fatal<c- p>(</c-><c- s>"invalid nonce"</c-><c- p>)</c->
	<c- p>}</c->

    st<c- p>.</c->DeductFunds<c- p>(</c->msg<c- p>.</c->From<c- p>,</c-> totalCost<c- p>)</c->
    st<c- p>.</c->DepositFunds<c- p>(</c->msg<c- p>.</c->To<c- p>,</c-> msg<c- p>.</c->Value<c- p>)</c->

    vmctx <c- o>:=</c-> makeVMContext<c- p>(</c->st<c- p>,</c-> msg<c- p>)</c->

    ret<c- p>,</c-> errcode <c- o>:=</c-> fromActor<c- p>.</c->Invoke<c- p>(</c->vmctx<c- p>,</c-> msg<c- p>.</c->Method<c- p>,</c-> msg<c- p>.</c->Params<c- p>)</c->
    <c- k>if</c-> errcode <c- o>!=</c-> <c- mi>0</c-> <c- p>{</c->
        <c- c1>// revert all state changes since snapshot</c->
        st<c- p>.</c->Revert<c- p>()</c->
        st<c- p>.</c->DeductFunds<c- p>(</c->msg<c- p>.</c->From<c- p>,</c-> vmctx<c- p>.</c->GasUsed<c- p>()</c-> <c- o>*</c-> msg<c- p>.</c->GasPrice<c- p>)</c->
    <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
        <c- c1>// refund unused gas</c->
        st<c- p>.</c->DepositFunds<c- p>(</c->msg<c- p>.</c->From<c- p>,</c-> <c- p>(</c->msg<c- p>.</c->GasLimit <c- o>-</c-> vmctx<c- p>.</c->GasUsed<c- p>())</c-> <c- o>*</c-> msg<c- p>.</c->GasPrice<c- p>)</c->
    <c- p>}</c->

    <c- c1>// reward miner gas fees</c->
    st<c- p>.</c->DepositFunds<c- p>(</c->msg<c- p>.</c->To<c- p>,</c-> msg<c- p>.</c->GasPrice <c- o>*</c-> vmctx<c- p>.</c->GasUsed<c- p>())</c->

    <c- k>return</c-> MessageReceipt<c- p>{</c->
        ExitCode<c- p>:</c-> errcode<c- p>,</c->
        Return<c- p>:</c-> ret<c- p>,</c->
        GasUsed<c- p>:</c-> vmctx<c- p>.</c->GasUsed<c- p>(),</c->
    <c- p>}</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="11.3.1" id="receipts"><span class="secno">11.3.1. </span><span class="content">Receipts</span><a class="self-link" href="#receipts"></a></h4>
   <p>Every message execution generates a <a href="data-structures.md#message-receipt">receipt</a>. These receipts contain the encoded return value of the method invocation, and an exit code.</p>
   <h4 class="heading settled" data-level="11.3.2" id="storage①"><span class="secno">11.3.2. </span><span class="content">Storage</span><a class="self-link" href="#storage①"></a></h4>
   <p>Actors are given acess to a <code>Storage</code> interface to fulfil their need for persistent storage. The <code>Storage</code> interface describes a content addressed block storage system (<code>Put</code> and <code>Get</code>) and a pointer into it (<code>Head</code> and <code>Commit</code>) that points to the actor’s current state.</p>
<pre class="language-go highlight"><c- a>type</c-> Storage <c- a>interface</c-> <c- p>{</c->
	<c- c1>// Put writes the given object to the storage staging area and returns its CID</c->
	Put<c- p>(</c-><c- a>interface</c-><c- p>{})</c-> <c- p>(</c->Cid<c- p>,</c-> <c- b>error</c-><c- p>)</c->

	<c- c1>// Get fetches the given object from storage (either staging, or local) and returns</c->
	<c- c1>// the serialized data.</c->
	Get<c- p>(</c->Cid<c- p>)</c-> <c- p>([]</c-><c- b>byte</c-><c- p>,</c-> <c- b>error</c-><c- p>)</c->

	<c- c1>// Commit updates the actual stored state for the actor. This is a compare and swap</c->
	<c- c1>// operation, and will fail if 'old' is not equal to the current return value of &lt;code data-opaque bs-autolink-syntax='`Head`'>Head&lt;/code>.</c->
	<c- c1>// This functionality is used to prevent issues with re-entrancy</c->
	Commit<c- p>(</c->old Cid<c- p>,</c-> new Cid<c- p>)</c-> <c- b>error</c->

	<c- c1>// Head returns the CID of the current actor state</c->
	Head<c- p>()</c-> Cid
<c- p>}</c->
</pre>
   <p>Actors can store state as a single block or implement any persistent
data structure that can be built upon a content addressed block store.
Implementations may provide data structure implementations to simplify
development. The current interface only supports CBOR-IPLD, but this
should soon expand to allow other types of IPLD data structures (as long
as the system has resolvers for them).</p>
   <p>The current state of a given actor can be accessed first by calling <code>Head</code> to retrieve the CID of the root of the actors state, then by using <code>Get</code> to retrieve the actual object being referenced.</p>
   <p>To store data, <code>Put</code> is used. Any number of objects may be <code>Put</code>, but only the object whose CID is committed, or objects that are linked to in some way by the committed object will be kept. All other objects are dropped after the method invocation returns. Objects stored via <code>Put</code> are first marshaled to CBOR-IPLD, and then stored, the returned CID is a 32 byte sha2-256 CBOR-IPLD content identifier.</p>
   <h2 class="heading settled" data-level="12" id="state-machine-actors"><span class="secno">12. </span><span class="content">State Machine Actors</span><a class="self-link" href="#state-machine-actors"></a></h2>
   <p>Any implementations of the Filecoin actors must be exactly byte for byte compatible with the go-filecoin actor implementations. The pseudocode below tries to capture most of the important logic, but capturing all the detail would require embedding exactly the code from go-filecoin, so for now, its simply informative pseudocode.</p>
   <p>This spec decsribes a set of actors that operate within the <a href="state-machine.md">Filecoin State Machine</a>. All types are defined in <a href="data-structures.md#basic-type-encodings">the basic type encoding spec</a>.</p>
   <h3 class="heading settled" data-level="12.1" id="storage-market-actor"><span class="secno">12.1. </span><span class="content">Storage Market Actor</span><a class="self-link" href="#storage-market-actor"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> StorageMarketActor <c- a>struct</c-> <c- p>{</c->
    Miners AddressSet

    TotalStorage Integer
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.1.1" id="createstorageminer"><span class="secno">12.1.1. </span><span class="content">CreateStorageMiner</span><a class="self-link" href="#createstorageminer"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>pubkey PublicKey</p>
    <li data-md>
     <p>pledge BytesAmount</p>
    <li data-md>
     <p>pid PeerID</p>
   </ul>
   <p>Return: Address</p>
<pre class="language-go highlight"><c- a>func</c-> CreateStorageMiner<c- p>(</c->pubkey PublicKey<c- p>,</c-> pledge BytesAmount<c- p>,</c-> pid PeerID<c- p>)</c-> Address <c- p>{</c->
    <c- k>if</c-> pledge <c- p>&lt;</c-> MinimumPledge <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Pledge too low"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> msg<c- p>.</c->Value <c- p>&lt;</c-> MinimumCollateral<c- p>(</c->pledge<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough funds to cover required collateral"</c-><c- p>)</c->
    <c- p>}</c->

    newminer <c- o>:=</c-> VM<c- p>.</c->CreateActor<c- p>(</c->MinerActor<c- p>,</c-> msg<c- p>.</c->Value<c- p>,</c-> pubkey<c- p>,</c-> pledge<c- p>,</c-> pid<c- p>)</c->

    self<c- p>.</c->Miners<c- p>.</c->Add<c- p>(</c->newminer<c- p>)</c->

    <c- k>return</c-> newminer
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.1.2" id="slashconsensusfault"><span class="secno">12.1.2. </span><span class="content">SlashConsensusFault</span><a class="self-link" href="#slashconsensusfault"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>block1 BlockHeader</p>
    <li data-md>
     <p>block2 BlockHeader</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> SlashConsensusFault<c- p>(</c->block1<c- p>,</c-> block2 BlockHeader<c- p>)</c-> <c- p>{</c->
	<c- k>if</c-> block1<c- p>.</c->Height <c- o>!=</c-> block2<c- p>.</c->Height <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"cannot slash miner for blocks of differing heights"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> <c- p>!</c->ValidateSignature<c- p>(</c->block1<c- p>.</c->Signature<c- p>)</c-> <c- o>||</c-> <c- p>!</c->ValidateSignature<c- p>(</c->block2<c- p>.</c->Signature<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Invalid blocks"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> AuthorOf<c- p>(</c->block1<c- p>)</c-> <c- o>!=</c-> AuthorOf<c- p>(</c->block2<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"blocks must be from the same miner"</c-><c- p>)</c->
    <c- p>}</c->

    miner <c- o>:=</c-> AuthorOf<c- p>(</c->block1<c- p>)</c->

    <c- c1>// Burn all of the miners collateral</c->
    miner<c- p>.</c->BurnCollateral<c- p>()</c->

    <c- c1>// TODO: Some of the slashed collateral should be paid to the slasher</c->

    <c- c1>// Remove the miner from the list of network miners</c->
    self<c- p>.</c->Miners<c- p>.</c->Remove<c- p>(</c->miner<c- p>)</c->
    self<c- p>.</c->UpdateStorage<c- p>(</c-><c- o>-</c-><c- mi>1</c-> <c- o>*</c-> miner<c- p>.</c->Power<c- p>)</c->

    <c- c1>// Now delete the miner (maybe this is a bit harsh, but i’m okay with it for now)</c->
    miner<c- p>.</c->SelfDestruct<c- p>()</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.1.3" id="updatestorage"><span class="secno">12.1.3. </span><span class="content">UpdateStorage</span><a class="self-link" href="#updatestorage"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>delta Integer</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> UpdateStorage<c- p>(</c->delta Integer<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>!</c->self<c- p>.</c->Miners<c- p>.</c->Has<c- p>(</c->msg<c- p>.</c->From<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"update storage must only be called by a miner actor"</c-><c- p>)</c->
    <c- p>}</c->

    self<c- p>.</c->TotalStorage <c- o>+=</c-> delta
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.1.4" id="gettotalstorage"><span class="secno">12.1.4. </span><span class="content">GetTotalStorage</span><a class="self-link" href="#gettotalstorage"></a></h4>
   <p>Parameters: None</p>
   <p>Return: Integer</p>
<pre class="language-go highlight"><c- a>func</c-> GetTotalStorage<c- p>()</c-> Integer <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->TotalStorage
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="12.2" id="storage-miner-actor"><span class="secno">12.2. </span><span class="content">Storage Miner Actor</span><a class="self-link" href="#storage-miner-actor"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> StorageMiner <c- a>struct</c-> <c- p>{</c->
    <c- c1>// Owner is the address of the account that owns this miner</c->
    Owner Address

    <c- c1>// Worker is the address of the worker account for this miner</c->
    Worker Address

    <c- c1>// PeerID is the libp2p peer identity that should be used to connect</c->
    <c- c1>// to this miner</c->
    PeerID peer<c- p>.</c->ID

    <c- c1>// PublicKey is the public portion of the key that the miner will use to sign blocks</c->
    PublicKey PublicKey

    <c- c1>// PledgeBytes is the amount of space being offered by this miner to the network</c->
    PledgeBytes BytesAmount

    <c- c1>// Collateral is locked up filecoin the miner has available to commit to storage.</c->
    <c- c1>// When miners commit new sectors, tokens are moved from here to 'ActiveCollateral'</c->
    <c- c1>// The sum of collateral here and in activecollateral should equal the required amount</c->
    <c- c1>// for the size of the miners pledge.</c->
    Collateral TokenAmount

    <c- c1>// ActiveCollateral is the amount of collateral currently committed to live storage</c->
    ActiveCollateral TokenAmount

    <c- c1>// DePledgedCollateral is collateral that is waiting to be withdrawn</c->
    DePledgedCollateral TokenAmount

    <c- c1>// DePledgeTime is the time at which the depledged collateral may be withdrawn</c->
    DePledgeTime BlockHeight

    <c- c1>// Sectors is the set of all sectors this miner has committed</c->
    Sectors SectorSet

    <c- c1>// ProvingSet is the set of sectors this miner is currently mining. It is only updated</c->
    <c- c1>// when a PoSt is submitted (not as each new sector commitment is added)</c->
    ProvingSet SectorSet

    <c- c1>// NextDoneSet is a set of sectors reported during the last PoSt submission as</c->
    <c- c1>// being 'done'. The collateral for them is still being held until the next PoSt</c->
    <c- c1>// submission in case early sector removal penalization is needed.</c->
    NextDoneSet SectorSet

    <c- c1>// ArbitratedDeals is the set of deals this miner has been slashed for since the</c->
    <c- c1>// last post submission</c->
    ArbitratedDeals CidSet

    <c- c1>// TODO: maybe this number is redundant with power</c->
    LockedStorage BytesAmount

    <c- c1>// Power is the amount of power this miner has</c->
    Power BytesAmount
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.1" id="constructor"><span class="secno">12.2.1. </span><span class="content">Constructor</span><a class="self-link" href="#constructor"></a></h4>
   <p>Along with the call, the actor must be created with exactly enough filecoin for the collateral necessary for the pledge.</p>
<pre class="language-go highlight"><c- a>func</c-> StorageMinerActor<c- p>(</c->pubkey PublicKey<c- p>,</c-> pledge BytesAmount<c- p>,</c-> pid PeerID<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> msg<c- p>.</c->Value <c- p>&lt;</c-> CollateralForPledgeSize<c- p>(</c->pledge<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough collateral given"</c-><c- p>)</c->
    <c- p>}</c->

    self<c- p>.</c->Owner <c- p>=</c-> message<c- p>.</c->From
    self<c- p>.</c->PublicKey <c- p>=</c-> pubkey
    self<c- p>.</c->PeerID <c- p>=</c-> pid
    self<c- p>.</c->PledgeBytes <c- p>=</c-> pledge
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.2" id="addask"><span class="secno">12.2.2. </span><span class="content">AddAsk</span><a class="self-link" href="#addask"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>price TokenAmount</p>
    <li data-md>
     <p>ttl Integer</p>
   </ul>
   <p>Return: AskID</p>
<pre class="language-go highlight"><c- a>func</c-> AddAsk<c- p>(</c->price TokenAmount<c- p>,</c-> ttl Integer<c- p>)</c-> AskID <c- p>{</c->
    <c- k>if</c-> msg<c- p>.</c->From <c- o>!=</c-> self<c- p>.</c->Worker <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Asks may only be added via the worker address"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// Filter out expired asks</c->
    self<c- p>.</c->Asks<c- p>.</c->FilterExpired<c- p>()</c->

    askid <c- o>:=</c-> self<c- p>.</c->NextAskID
    self<c- p>.</c->NextAskID<c- o>++</c->

    self<c- p>.</c->Asks<c- p>.</c->Append<c- p>(</c->Ask<c- p>{</c->
        Price<c- p>:</c-> price<c- p>,</c->
        Expiry<c- p>:</c-> CurrentBlockHeight <c- o>+</c-> ttl<c- p>,</c->
        ID<c- p>:</c-> askid<c- p>,</c->
    <c- p>})</c->

    <c- k>return</c-> askid
<c- p>}</c->
</pre>
   <p class="note" role="note"><span>Note:</span> this may be moved off chain soon, don’t worry about testing it too heavily.</p>
   <h4 class="heading settled" data-level="12.2.3" id="commitsector"><span class="secno">12.2.3. </span><span class="content">CommitSector</span><a class="self-link" href="#commitsector"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>commD []byte</p>
    <li data-md>
     <p>commR []byte</p>
    <li data-md>
     <p>commRStar []byte</p>
    <li data-md>
     <p>proof SealProof</p>
   </ul>
   <p>Return: SectorID</p>
<pre class="language-go highlight"><c- a>func</c-> CommitSector<c- p>(</c->commD<c- p>,</c-> commR <c- p>[]</c-><c- b>byte</c-><c- p>,</c-> proof <c- o>*</c->SealProof<c- p>)</c-> SectorID <c- p>{</c->
    <c- k>if</c-> <c- p>!</c->miner<c- p>.</c->ValidatePoRep<c- p>(</c->commD<c- p>,</c-> commR<c- p>,</c-> miner<c- p>.</c->PublicKey<c- p>,</c-> proof<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"bad proof!"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// make sure the miner isnt trying to submit a pre-existing sector</c->
    <c- k>if</c-> <c- p>!</c->miner<c- p>.</c->EnsureSectorIsUnique<c- p>(</c->commR<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"sector already committed!"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// make sure the miner has enough collateral to add more storage</c->
    <c- c1>// currently, all sectors are the same size, and require the same collateral</c->
    <c- c1>// in the future, we may have differently sized sectors and need special handling</c->
    coll <c- p>=</c-> CollateralForSector<c- p>()</c->

    <c- k>if</c-> coll <c- p>&lt;</c-> miner<c- p>.</c->Collateral <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough collateral"</c-><c- p>)</c->
    <c- p>}</c->

    miner<c- p>.</c->Collateral <c- o>-=</c-> coll
    miner<c- p>.</c->ActiveCollateral <c- o>+=</c-> coll

    sectorId <c- p>=</c-> miner<c- p>.</c->Sectors<c- p>.</c->Add<c- p>(</c->commR<c- p>)</c->
    <c- c1>// TODO: sectors IDs might not be that useful. For now, this should just be the number of</c->
    <c- c1>// the sector within the set of sectors, but that can change as the miner experiences</c->
    <c- c1>// failures.</c->

    <c- c1>// if miner is not mining, start their proving period now</c->
    <c- c1>// Note: As written here, every miners first PoSt will only be over one sector.</c->
    <c- c1>// We could set up a 'grace period' for starting mining that would allow miners</c->
    <c- c1>// to submit several sectors for their first proving period. Alternatively, we</c->
    <c- c1>// could simply make the 'CommitSector' call take multiple sectors at a time.</c->
    <c- k>if</c-> miner<c- p>.</c->ProvingSet<c- p>.</c->Size<c- p>()</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>{</c->
       miner<c- p>.</c->ProvingSet <c- p>=</c-> miner<c- p>.</c->Sectors
       miner<c- p>.</c->ProvingPeriodEnd <c- p>=</c-> chain<c- p>.</c->Now<c- p>()</c-> <c- o>+</c-> ProvingPeriodDuration
    <c- p>}</c->

    <c- k>return</c-> sectorId
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.4" id="submitpost"><span class="secno">12.2.4. </span><span class="content">SubmitPoSt</span><a class="self-link" href="#submitpost"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>proofs []PoStProof</p>
    <li data-md>
     <p>faults []FailureSet</p>
    <li data-md>
     <p>recovered SectorSet</p>
    <li data-md>
     <p>done SectorSet</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> SubmitPost<c- p>(</c->proofs <c- p>[]</c->PoStProof<c- p>,</c-> faults <c- p>[]</c->FaultSet<c- p>,</c-> recovered BitField<c- p>,</c-> done BitField<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> msg<c- p>.</c->From <c- o>!=</c-> miner<c- p>.</c->Worker <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not authorized to submit post for miner"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// ensure the fault sets properly stack, recovered is a subset of the combined</c->
    <c- c1>// fault sets, and that done does not intersect with either, and that all sets</c->
    <c- c1>// only reference sectors that currently exist</c->
    <c- k>if</c-> <c- p>!</c->miner<c- p>.</c->ValidateFaultSets<c- p>(</c->faults<c- p>,</c-> recovered<c- p>,</c-> done<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"fault sets invalid"</c-><c- p>)</c->
    <c- p>}</c->

    <c- a>var</c-> feesRequired TokenAmount

    <c- k>if</c-> chain<c- p>.</c->Now<c- p>()</c-> <c- p>></c-> miner<c- p>.</c->ProvingPeriodEnd <c- o>+</c-> GenerationAttackTime <c- p>{</c->
        <c- c1>// TODO: determine what exactly happens here. Is the miner permanently banned?</c->
        Fatal<c- p>(</c-><c- s>"Post submission too late"</c-><c- p>)</c->
    <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> chain<c- p>.</c->Now<c- p>()</c-> <c- p>></c-> miner<c- p>.</c->ProvingPeriodEnd <c- p>{</c->
        feesRequired <c- o>+=</c-> ComputeLateFee<c- p>(</c->chain<c- p>.</c->Now<c- p>()</c-> <c- o>-</c-> miner<c- p>.</c->ProvingPeriodEnd<c- p>)</c->
    <c- p>}</c->

    feesRequired <c- o>+=</c-> ComputeTemporarySectorFailureFee<c- p>(</c->recovered<c- p>)</c->

    <c- k>if</c-> msg<c- p>.</c->Value <c- p>&lt;</c-> feesRequired <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough funds to pay post submission fees"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// we want to ensure that the miner can submit more fees than required, just in case</c->
    <c- k>if</c-> msg<c- p>.</c->Value <c- p>></c-> feesRequired <c- p>{</c->
        Refund<c- p>(</c->msg<c- p>.</c->Value <c- o>-</c-> feesRequired<c- p>)</c->
    <c- p>}</c->


    <c- k>if</c-> <c- p>!</c->CheckPostProofs<c- p>(</c->proofs<c- p>,</c-> faults<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"proofs invalid"</c-><c- p>)</c->
    <c- p>}</c->

    permLostSet <c- p>=</c-> AggregateBitfields<c- p>(</c->faults<c- p>).</c->Subtract<c- p>(</c->recovered<c- p>)</c->

    <c- c1>// adjust collateral for 'done' sectors</c->
    miner<c- p>.</c->ActiveCollateral <c- o>-=</c-> CollateralForSectors<c- p>(</c->miner<c- p>.</c->NextDoneSet<c- p>)</c->
    miner<c- p>.</c->Collateral <c- o>+=</c-> CollateralForSectors<c- p>(</c->miner<c- p>.</c->NextDoneSet<c- p>)</c->

    <c- c1>// penalize collateral for lost sectors</c->
    miner<c- p>.</c->Collateral <c- o>-=</c-> CollateralForSectors<c- p>(</c->permLostSet<c- p>)</c->
    miner<c- p>.</c->ActiveCollateral <c- o>-=</c-> CollateralForSectors<c- p>(</c->permLostSet<c- p>)</c->

    <c- c1>// burn funds for fees and collateral penalization</c->
    BurnFunds<c- p>(</c->miner<c- p>,</c-> CollateralForSectors<c- p>(</c->permLostSet<c- p>)</c-> <c- o>+</c-> feesRequired<c- p>)</c->

    <c- c1>// update sector sets and proving set</c->
    miner<c- p>.</c->Sectors<c- p>.</c->Subtract<c- p>(</c->miner<c- p>.</c->NextDoneSet<c- p>)</c->
    miner<c- p>.</c->Sectors<c- p>.</c->Subtract<c- p>(</c->permLostSet<c- p>)</c->

    <c- c1>// update miner power to the amount of data actually proved during</c->
    <c- c1>// the last proving period.</c->
    oldPower <c- o>:=</c-> miner<c- p>.</c->Power
    miner<c- p>.</c->Power <c- p>=</c-> SizeOf<c- p>(</c->Filter<c- p>(</c->miner<c- p>.</c->ProvingSet<c- p>,</c-> faults<c- p>))</c->
    StorageMarket<c- p>.</c->UpdateStorage<c- p>(</c->miner<c- p>.</c->Power <c- o>-</c-> oldPower<c- p>)</c->

    miner<c- p>.</c->ProvingSet <c- p>=</c-> miner<c- p>.</c->Sectors

    <c- c1>// NEEDS REVIEW: early submission of PoSts may give the miner extra time for</c->
    <c- c1>// their next PoSt, which could compound. Does the beacon reseeding for Posts</c->
    <c- c1>// address this well enough?</c->
    miner<c- p>.</c->ProvingPeriodEnd <c- p>=</c-> miner<c- p>.</c->ProvingPeriodEnd <c- o>+</c-> ProvingPeriodDuration

    <c- c1>// update next done set</c->
    miner<c- p>.</c->NextDoneSet <c- p>=</c-> done
    miner<c- p>.</c->ArbitratedDeals<c- p>.</c->Clear<c- p>()</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.5" id="increasepledge"><span class="secno">12.2.5. </span><span class="content">IncreasePledge</span><a class="self-link" href="#increasepledge"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>addspace BytesAmount</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> IncreasePledge<c- p>(</c->addspace BytesAmount<c- p>)</c-> <c- p>{</c->
    <c- c1>// Note: msg.Value is implicitly transferred to the miner actor</c->
    <c- k>if</c-> miner<c- p>.</c->Collateral <c- o>+</c-> msg<c- p>.</c->Value <c- p>&lt;</c-> CollateralForPledge<c- p>(</c->addspace <c- o>+</c-> miner<c- p>.</c->PledgeBytes<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"not enough total collateral for the requested pledge"</c-><c- p>)</c->
    <c- p>}</c->

    miner<c- p>.</c->Collateral <c- o>+=</c-> msg<c- p>.</c->Value
    miner<c- p>.</c->PledgeBytes <c- o>+=</c-> addspace
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.6" id="slashstoragefault"><span class="secno">12.2.6. </span><span class="content">SlashStorageFault</span><a class="self-link" href="#slashstoragefault"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>miner Address</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> SlashStorageFault<c- p>()</c-> <c- p>{</c->
	<c- k>if</c-> self<c- p>.</c->SlashedAt <c- p>></c-> <c- mi>0</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"miner already slashed"</c-><c- p>)</c->
	<c- p>}</c->

    <c- k>if</c-> chain<c- p>.</c->Now<c- p>()</c-> <c- o>&lt;=</c-> miner<c- p>.</c->ProvingPeriodEnd <c- o>+</c-> GenerationAttackTime <c- p>{</c->
    	Fatal<c- p>(</c-><c- s>"miner is not yet tardy"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> miner<c- p>.</c->ProvingSet<c- p>.</c->Size<c- p>()</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"miner is inactive"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// Strip miner of their power</c->
    StorageMarketActor<c- p>.</c->UpdateStorage<c- p>(</c-><c- o>-</c-><c- mi>1</c-> <c- o>*</c-> self<c- p>.</c->Power<c- p>)</c->
    self<c- p>.</c->Power <c- p>=</c-> <c- mi>0</c->

    <c- c1>// TODO: make this less hand wavey</c->
    BurnCollateral<c- p>(</c->self<c- p>.</c->ConsensusCollateral<c- p>)</c->

    self<c- p>.</c->SlashedAt <c- p>=</c-> CurrentBlockHeight
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.7" id="getcurrentprovingset"><span class="secno">12.2.7. </span><span class="content">GetCurrentProvingSet</span><a class="self-link" href="#getcurrentprovingset"></a></h4>
   <p>Parameters: None</p>
   <p>Return: <code>[][]byte</code></p>
<pre class="language-go highlight"><c- a>func</c-> GetCurrentProvingSet<c- p>()</c-> <c- p>[][]</c-><c- b>byte</c-> <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->ProvingSet
<c- p>}</c->
</pre>
   <p class="note" role="note"><span>Note:</span> this is unlikely to ever be called on-chain, and will be a very large amount of data. We should reconsider the need for a list of all sector commitments (maybe fixing with accumulators?)</p>
   <h4 class="heading settled" data-level="12.2.8" id="arbitratedeal"><span class="secno">12.2.8. </span><span class="content">ArbitrateDeal</span><a class="self-link" href="#arbitratedeal"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>deal Deal</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> AbitrateDeal<c- p>(</c->d Deal<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>!</c->ValidateSignature<c- p>(</c->d<c- p>,</c-> self<c- p>.</c->Worker<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"invalid signature on deal"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> CurrentBlockHeight <c- p>&lt;</c-> d<c- p>.</c->StartTime <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Deal not yet started"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> d<c- p>.</c->Expiry <c- p>&lt;</c-> CurrentBlockHeight <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Deal is expired"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> <c- p>!</c->self<c- p>.</c->NextDoneSet<c- p>.</c->Has<c- p>(</c->d<c- p>.</c->PieceCommitment<c- p>.</c->Sector<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Deal agreement not broken, or arbitration too late"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> self<c- p>.</c->ArbitratedDeals<c- p>.</c->Has<c- p>(</c->d<c- p>.</c->PieceRef<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"cannot slash miner twice for same deal"</c-><c- p>)</c->
    <c- p>}</c->

    pledge<c- p>,</c-> storage <c- o>:=</c-> CollateralForDeal<c- p>(</c->d<c- p>)</c->

    <c- c1>// burn the pledge collateral</c->
    self<c- p>.</c->BurnFunds<c- p>(</c->pledge<c- p>)</c->

    <c- c1>// pay the client the storage collateral</c->
    TransferFunds<c- p>(</c->d<c- p>.</c->ClientAddr<c- p>,</c-> storage<c- p>)</c->

    <c- c1>// make sure the miner can’t be slashed twice for this deal</c->
    self<c- p>.</c->ArbitratedDeals<c- p>.</c->Add<c- p>(</c->d<c- p>.</c->PieceRef<c- p>)</c->
<c- p>}</c->
</pre>
   <p>TODO(scaling): This method, as currently designed, must be called once per sector. If a miner agrees to store 1TB (1000 sectors) for a particular client, and loses all that data, the client must then call this method 1000 times, which will be really expensive.</p>
   <h4 class="heading settled" data-level="12.2.9" id="depledge"><span class="secno">12.2.9. </span><span class="content">DePledge</span><a class="self-link" href="#depledge"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>amt TokenAmount</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> DePledge<c- p>(</c->amt TokenAmount<c- p>)</c-> <c- p>{</c->
    <c- c1>// TODO: Do both the worker and the owner have the right to call this?</c->
    <c- k>if</c-> msg<c- p>.</c->From <c- o>!=</c-> miner<c- p>.</c->Worker <c- o>&amp;&amp;</c-> msg<c- p>.</c->From <c- o>!=</c-> miner<c- p>.</c->Owner <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Not authorized to call DePledge"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> miner<c- p>.</c->DePledgeTime <c- p>></c-> <c- mi>0</c-> <c- p>{</c->
        <c- k>if</c-> miner<c- p>.</c->DePledgeTime <c- p>></c-> CurrentBlockHeight <c- p>{</c->
            Fatal<c- p>(</c-><c- s>"too early to withdraw collateral"</c-><c- p>)</c->
        <c- p>}</c->

        TransferFunds<c- p>(</c->miner<c- p>.</c->Owner<c- p>,</c-> miner<c- p>.</c->DePledgedCollateral<c- p>)</c->
        miner<c- p>.</c->DePledgeTime <c- p>=</c-> <c- mi>0</c->
        miner<c- p>.</c->DePledgedCollateral <c- p>=</c-> <c- mi>0</c->
        <c- k>return</c->
    <c- p>}</c->

    <c- k>if</c-> amt <c- p>></c-> miner<c- p>.</c->Collateral <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"Not enough free collateral to withdraw that much"</c-><c- p>)</c->
    <c- p>}</c->

    miner<c- p>.</c->Collateral <c- o>-=</c-> amt
    miner<c- p>.</c->DePledgedCollateral <c- p>=</c-> amt
    miner<c- p>.</c->DePledgeTime <c- p>=</c-> CurrentBlockHeight <c- o>+</c-> DePledgeCooldown
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.10" id="getowner"><span class="secno">12.2.10. </span><span class="content">GetOwner</span><a class="self-link" href="#getowner"></a></h4>
   <p>Parameters: None</p>
   <p>Return: Address</p>
<pre class="language-go highlight"><c- a>func</c-> GetOwner<c- p>()</c-> Address <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->Owner
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.11" id="getworkeraddr"><span class="secno">12.2.11. </span><span class="content">GetWorkerAddr</span><a class="self-link" href="#getworkeraddr"></a></h4>
   <p>Parameters: None</p>
   <p>Return: Address</p>
<pre class="language-go highlight"><c- a>func</c-> GetWorkerAddr<c- p>()</c-> Address <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->Worker
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.12" id="getpower"><span class="secno">12.2.12. </span><span class="content">GetPower</span><a class="self-link" href="#getpower"></a></h4>
   <p>Parameters: None</p>
   <p>Return: Integer</p>
<pre class="language-go highlight"><c- a>func</c-> GetPower<c- p>()</c-> Integer <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->Power
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.13" id="getkey"><span class="secno">12.2.13. </span><span class="content">GetKey</span><a class="self-link" href="#getkey"></a></h4>
   <p>Parameters: None</p>
   <p>Return: PublicKey</p>
<pre class="language-go highlight"><c- a>func</c-> GetKey<c- p>()</c-> PublicKey <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->PublicKey
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.14" id="getpeerid"><span class="secno">12.2.14. </span><span class="content">GetPeerID</span><a class="self-link" href="#getpeerid"></a></h4>
   <p>Parameters: None</p>
   <p>Return: PeerID</p>
<pre class="language-go highlight"><c- a>func</c-> GetPeerID<c- p>()</c-> PeerID <c- p>{</c->
    <c- k>return</c-> self<c- p>.</c->PeerID
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="12.2.15" id="updatepeerid"><span class="secno">12.2.15. </span><span class="content">UpdatePeerID</span><a class="self-link" href="#updatepeerid"></a></h4>
   <p>Parameters:</p>
   <ul>
    <li data-md>
     <p>pid PeerID</p>
   </ul>
   <p>Return: None</p>
<pre class="language-go highlight"><c- a>func</c-> UpdatePeerID<c- p>(</c->pid PeerID<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> msg<c- p>.</c->From <c- o>!=</c-> self<c- p>.</c->Worker <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"only the mine worker may update the peer ID"</c-><c- p>)</c->
    <c- p>}</c->

    self<c- p>.</c->PeerID <c- p>=</c-> pid
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="12.3" id="payment-channel-broker-actor"><span class="secno">12.3. </span><span class="content">Payment Channel Broker Actor</span><a class="self-link" href="#payment-channel-broker-actor"></a></h3>
   <p>TODO</p>
   <h2 class="heading settled" data-level="13" id="faults①"><span class="secno">13. </span><span class="content">Faults</span><a class="self-link" href="#faults①"></a></h2>
   <p>A fault is what happens when partcipants in the protocol are behaving incorrectly and that behavior needs to be punished. There are a number of possible faults in the Filecoin protocol, their details are all recorded below.</p>
   <h3 class="heading settled" data-level="13.1" id="fault-list"><span class="secno">13.1. </span><span class="content">Fault List</span><a class="self-link" href="#fault-list"></a></h3>
   <h4 class="heading settled" data-level="13.1.1" id="consensus-faults"><span class="secno">13.1.1. </span><span class="content">Consensus Faults</span><a class="self-link" href="#consensus-faults"></a></h4>
   <ul>
    <li data-md>
     <p><strong>Duplicate Block Submission Slashing:</strong></p>
    <li data-md>
     <p><strong>Condition:</strong> If any miner posts two different blocks for the same chain height.</p>
    <li data-md>
     <p><strong>Reporting:</strong> Anyone may call <code>SlashConsensusFault</code> and pass in the two offending block headers.</p>
    <li data-md>
     <p><strong>Check:</strong> The chain checks that both blocks are valid, have the same height, and are correctly signed by the same miner.</p>
    <li data-md>
     <p><strong>Penalization:</strong> All of the miners pledge collateral and all of their power is irrevocably slashed.</p>
   </ul>
   <h4 class="heading settled" data-level="13.1.2" id="market-faults"><span class="secno">13.1.2. </span><span class="content">Market Faults</span><a class="self-link" href="#market-faults"></a></h4>
   <ul>
    <li data-md>
     <p><strong>Late submission penalty:</strong></p>
    <li data-md>
     <p><strong>Condition</strong>: If the miner posts their PoSt after the proving period ends, but before the generation attack threshold.</p>
    <li data-md>
     <p><strong>Reporting:</strong> The miner submits their PoSt as usual, but includes the late submission fee.</p>
    <li data-md>
     <p><strong>Check:</strong> The chain checks first that the submission is within the <code>generation attack threshold</code>, and then checks that the fee provided matches the required fee for how many blocks late the submission is.</p>
    <li data-md>
     <p><strong>Penalization:</strong> The miner is penalized proportionally to the delay. Penalizations are enforced by a standard PoSt submission.</p>
     <ul>
      <li data-md>
       <p><em>Economic penalization</em>: To determine the penalty amount, <code>CalculateLatePenalty(numLate)</code> is called. The miners power is not reduced after the fee submission.</p>
      <li data-md>
       <p><em>Power penalization</em>: The miners' power is not reduced. Note that the current view of the power table is computed with the lookback parameter.</p>
      <li data-md>
       <p><em>Why are we accounting the power table with a lookback parameter ?</em> If we do not use the lookback parameter then, we need to penalize late miners for the duration that they are late. This is tricky to do efficiently. For xample, if miners A, B and C each have 1/3 of the networks power, and C is late in submitting their proofs, then for that duration, A and B should each have effectively half of the networks power (and a 50% chance each of winning the block).</p>
     </ul>
    <li data-md>
     <p>TODO: write on the spec exact parameters for PoSt Deadline and Gen Attack threshold</p>
    <li data-md>
     <p><strong>Unreported storage fault slashing:</strong></p>
    <li data-md>
     <p><strong>Condition:</strong> If the miner does not submit their PoSt by the <code>generation attack threshold</code>.</p>
    <li data-md>
     <p><strong>Reporting:</strong> The miner can be slashed by anyone else in the network who calls <code>SlashStorageFaults</code>. We expect miners to report these faults.</p>
     <ul>
      <li data-md>
       <p>Future design note: moving forward, we should either compensate the caller, or require this</p>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> we could <em>require</em> the method be called, as part of the consensus rules (this gets complicated though). In this case, there is a DoS attack where if I make a large number of miners each with a single sector, and fail them all at the same time, the next block miner will be forced to do a very large amount of work. This would either need an extended 'gas limit', or some other method to avoid too long validation times.</p>
     </ul>
    <li data-md>
     <p><strong>Check:</strong> The chain checks that the miners last PoSt submission was before the start of their current proving period, and that the current block is after the generation attack threshold for their current proving period.</p>
    <li data-md>
     <p><strong>Penalization:</strong> Penalizations are enforced by <code>SlashStorageFault</code> on the <code>storage market</code> actor.</p>
     <ul>
      <li data-md>
       <p><em>Economic Penalization</em>: Miner loses all collateral.</p>
      <li data-md>
       <p><em>Power Penalization</em>: Miner loses all power.</p>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> If a miner is in this state, where they have failed to submit a PoST, any block they attempt to mine will be invalid, even if the election function selects them. (the election function should probably be made to never select them)</p>
      <li data-md>
       <p>Future design note: There is a way to tolerate Internet connection faults. A miner runs an Emergency PoSt which does not take challenges from the chain, if the miner gets reconnected before the VDF attack time (based on Amax), then, they can submit the Emergency PoSt and get pay a late penalization fee.</p>
     </ul>
    <li data-md>
     <p><strong>Reported storage fault penalty:</strong></p>
    <li data-md>
     <p><strong>Condition:</strong> The miner submits their PoSt with a non-empty set of 'missing sectors'.</p>
    <li data-md>
     <p><strong>Reporting:</strong> The miner can specify some sectors that they failed to prove during the proving period.</p>
     <ul>
      <li data-md>
       <p class="note" role="note"><span>Note:</span> These faults are output by the <code>ProveStorage</code> routine, and are posted on-chain when posting the proof. This occurs when the miner (for example) has a disk failure, or other local data corruption.</p>
     </ul>
    <li data-md>
     <p><strong>Check:</strong> The chain checks that the proof verifies with the missing sectors.</p>
    <li data-md>
     <p><strong>Penalization:</strong> The miner is penalized for collateral and power proportional to the number of missing sectors. The sectors are also removed from the miners proving set.</p>
     <ul>
      <li data-md>
       <p>TODO: should the collateral lost here be proportional to the remaining time?</p>
      <li data-md>
       <p>TODO(nicola): check if the time between posting two proofs allows for a generation attack if it does not then we might reconsider the sector not being lost</p>
     </ul>
    <li data-md>
     <p class="note" role="note"><span>Note:</span> if a sector is missed here, and they are recovered after the fact, the miner could simple 're-commit' the sector. They still have to pay the collateral, but the data can be quickly re-introduced into the system to avoid clients calling them out for breach of contract (this would only work because the sector commD/commR is the same)</p>
    <li data-md>
     <p class="note" role="note"><span>Note:</span> In the case where a miner is temporarily unable to prove some of their data, they can simply wait for the temporary unavailability to recover, and then continue proving, submitting the proofs a bit late if necessary (paying appropriate fees, as described above).</p>
    <li data-md>
     <p><strong>Breach of contract dispute:</strong></p>
    <li data-md>
     <p><strong>Condition:</strong> A client who has stored data with a miner, and the miner removes the sector containing that data before the end of the agreed upon time period.</p>
    <li data-md>
     <p><strong>Reporting:</strong> The client invokes <code>ArbitrateDeal</code> on the offending miner actor with a signed deal from that miner for the storage in question. Note: the reporting must happen within one proving period of the miner removing the storage erroneously.</p>
    <li data-md>
     <p><strong>Check:</strong> The chain checks that the deal was correctly signed by the miner in question, that the deal has not yet expired, and that the sector referenced by the deal is no longer in the miners proving set.</p>
    <li data-md>
     <p><strong>Penalization:</strong> The miner is penalized an amount proportional to the incorrectly removed sector. This penalty is taken from their pledged collateral .</p>
    <li data-md>
     <p class="note" role="note"><span>Note:</span> This implies that miners cannot re-seal data into different sectors. We could come up with a protocol where the client gives the miner explicit consent to re-seal, but that is more complicated and can be done later.</p>
   </ul>
   <h2 class="heading settled" data-level="14" id="signatures"><span class="secno">14. </span><span class="content">Signatures</span><a class="self-link" href="#signatures"></a></h2>
   <h3 class="heading settled" data-level="14.1" id="what-are-signatures-in-filecoin"><span class="secno">14.1. </span><span class="content">What are signatures in Filecoin</span><a class="self-link" href="#what-are-signatures-in-filecoin"></a></h3>
   <p>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.</p>
   <p>We use signatures in filecoin to verify <em>something</em> was done by <em>someone</em>. For example, we use signatures in order to validate deal messages which represent an action like a storage deals We also use signatures to determine who generated a particular message, determine public keys--which can be recovered from signed data and a signature, and find filecoin addresses which generated from a public key.</p>
   <ul>
    <li data-md>
     <p>Messages (From actors to the blockchain)</p>
    <li data-md>
     <p>Tickets (Signature of proof - <a href="mining.md">Mining</a></p>
    <li data-md>
     <p>Block signature (Signature over all data in the block - done by block leader)</p>
   </ul>
   <h3 class="heading settled" data-level="14.2" id="what-signatures-affect"><span class="secno">14.2. </span><span class="content">What signatures affect</span><a class="self-link" href="#what-signatures-affect"></a></h3>
   <p>What uses them</p>
   <ul>
    <li data-md>
     <p>Messages [TODO: Link to messages spec]</p>
    <li data-md>
     <p>Block validation</p>
    <li data-md>
     <p>Tickets which inform leader election in Expected Consensus (EC) [TODO: link to EC spec]</p>
   </ul>
   <p>Note that messages between actors are not signed this is because messages between actors are always spawned by a message from a user -- which are singed by that user.</p>
   <p>Filecoin specific reliance</p>
   <ul>
    <li data-md>
     <p>SignedMessages in go-filecoin</p>
   </ul>
   <h3 class="heading settled" data-level="14.3" id="dependencies③"><span class="secno">14.3. </span><span class="content">Dependencies</span><a class="self-link" href="#dependencies③"></a></h3>
   <p>Things that affect our choices for signatures</p>
   <ul>
    <li data-md>
     <p>Elliptic curve choices - We use ECDSA with secp256k1 (aka the BitCoin elliptic curve)</p>
    <li data-md>
     <p>Signature size limits - Our signatures are 64 bytes + 1 byte for public key recovery</p>
    <li data-md>
     <p>Avg. processing power available to a CPU (signature aggregation)</p>
   </ul>
   <p>Filecoin specific dependancies</p>
   <ul>
    <li data-md>
     <p>libsecp256k1</p>
   </ul>
   <h3 class="heading settled" data-level="14.4" id="non-dependencies"><span class="secno">14.4. </span><span class="content">Non-Dependencies</span><a class="self-link" href="#non-dependencies"></a></h3>
   <p>Does not affect</p>
   <ul>
    <li data-md>
     <p>Transport encryption</p>
    <li data-md>
     <p>File encodings (PoRep)</p>
   </ul>
   <h3 class="heading settled" data-level="14.5" id="interface①"><span class="secno">14.5. </span><span class="content">Interface</span><a class="self-link" href="#interface①"></a></h3>
   <p>Filecoin requires a system that fulfils the following interface to function correctly.</p>
   <p class="note" role="note"><span>Note:</span> <code>Message</code> is used here as the object being signed, but this interface should also work for other things that need to be signed.</p>
<pre class="language-go highlight"><c- a>type</c-> Signature <c- a>interface</c-> <c- p>{</c->

        <c- c1>// Sign generates a proof that miner &lt;code data-opaque bs-autolink-syntax='`M`'>M&lt;/code> generate message &lt;code data-opaque bs-autolink-syntax='`m`'>m&lt;/code></c->
        <c- c1>//</c->
        <c- c1>// Out:</c->
        <c- c1>//    sig - a series of bytes representing a signature usually &lt;code data-opaque bs-autolink-syntax='`r`'>r&lt;/code>|&lt;code data-opaque bs-autolink-syntax='`s`'>s&lt;/code></c->
        <c- c1>//    err - a standard error message indicating any process issues</c->
        <c- c1>// In:</c->
        <c- c1>//    m - a series of bytes representing a message to be signed</c->
        <c- c1>//    sk - a private key which cryptographically links &lt;code data-opaque bs-autolink-syntax='`M`'>M&lt;/code> to &lt;code data-opaque bs-autolink-syntax='`sig`'>sig&lt;/code></c->
        <c- c1>//</c->
        Sign<c- p>(</c->m Message<c- p>,</c-> sk PrivateKey<c- p>)</c-> <c- p>(</c->sig SignatureBytes<c- p>,</c-> err <c- b>error</c-><c- p>)</c->

        <c- c1>// Verify validates the statement: only &lt;code data-opaque bs-autolink-syntax='`M`'>M&lt;/code> could have generated &lt;code data-opaque bs-autolink-syntax='`sig`'>sig&lt;/code></c->
        <c- c1>// given the validator has a message &lt;code data-opaque bs-autolink-syntax='`m`'>m&lt;/code>, a signature &lt;code data-opaque bs-autolink-syntax='`sig`'>sig&lt;/code>, and a</c->
        <c- c1>// public key &lt;code data-opaque bs-autolink-syntax='`pk`'>pk&lt;/code>.</c->
        <c- c1>//</c->
        <c- c1>// Out:</c->
        <c- c1>//    valid - a boolean value indicating the signature is valid</c->
        <c- c1>//    err - a standard error message indicating any process issues</c->
        <c- c1>// In:</c->
        <c- c1>//    m - a series of bytes representing the signed message</c->
        <c- c1>//    pk - the public key belonging to the signer &lt;code data-opaque bs-autolink-syntax='`M`'>M&lt;/code></c->
        <c- c1>//    sig - a series of bytes representing a signature usually &lt;code data-opaque bs-autolink-syntax='`r`'>r&lt;/code>|&lt;code data-opaque bs-autolink-syntax='`s`'>s&lt;/code></c->
        <c- c1>//</c->
        Verify<c- p>(</c->m Messgage<c- p>,</c-> pk PublicKey<c- p>,</c-> sig SignatureBytes<c- p>)</c-> <c- p>(</c->valid <c- b>bool</c-><c- p>,</c-> err <c- b>error</c-><c- p>)</c->

        <c- c1>// Recover, as its name implies, recovers a public key associated with a</c->
        <c- c1>// particular signature. In the case of ECDSA signatures, this function can</c->
        <c- c1>// be fulfilled via the 'ECRecover' method. If a different signature scheme</c->
        <c- c1>// is used, then some other mechanism of 'recovering' a message authors</c->
        <c- c1>// public key must be provided.</c->
        <c- c1>//</c->
        <c- c1>// Out:</c->
        <c- c1>//    pk - the public key associated with &lt;code data-opaque bs-autolink-syntax='`M`'>M&lt;/code> who signed &lt;code data-opaque bs-autolink-syntax='`m`'>m&lt;/code></c->
        <c- c1>//    err - a standard error message indicating any process issues</c->
        <c- c1>//    **</c->
        <c- c1>// In:</c->
        <c- c1>//    m - a series of bytes representing the signed message</c->
        <c- c1>//    sig - a series of bytes representing a signature usually &lt;code data-opaque bs-autolink-syntax='`r`'>r&lt;/code>|&lt;code data-opaque bs-autolink-syntax='`s`'>s&lt;/code></c->
        <c- c1>//</c->
        Recover<c- p>(</c->m Message<c- p>,</c-> sig SignatureBytes<c- p>)</c-> <c- p>(</c->pk PublicKey<c- p>,</c-> err <c- b>error</c-><c- p>)</c->
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="14.6" id="selected-signature-scheme"><span class="secno">14.6. </span><span class="content">Selected Signature Scheme</span><a class="self-link" href="#selected-signature-scheme"></a></h3>
   <p>Currently, Filecoin uses secp256k1 signatures to fulfill the above interface. All signatures on messages, blocks, and tickets currently use the same scheme and format.</p>
   <h4 class="heading settled" data-level="14.6.1" id="wire-format"><span class="secno">14.6.1. </span><span class="content">Wire Format</span><a class="self-link" href="#wire-format"></a></h4>
   <p>What bits are on the wire and in what order/format. We are currently adhering to libsecp256k1 serialization which is laid out as follows. Note that this format description may not be accurate. See the github link below for an authoritative format description.</p>
   <p><strong>Signature</strong></p>
<pre>sig SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</pre>
   <p><code>s</code> = Scalar of size 32 bytes</p>
   <p><code>r</code> = Compressed elliptic curve point (x-coordinate) of size 32 bytes</p>
   <p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p>
   <ul>
    <li data-md>
     <p>LSB(0) = parity of y-coordinate of r</p>
    <li data-md>
     <p>LSB(1) = overflow indicator</p>
   </ul>
   <p><code>indicator</code> = a 2 byte formatting indicator</p>
   <p>
    From: 
    <httpsU0003A U0003314a61d72474aa29ff4afba8472553ad91d88e9d bitcoin-core blob ecdsa_impl.hU00023l177 github.com secp256k1 src></httpsU0003A>
   </p>
   <p><strong>Signed Message</strong></p>
<pre>Type SignedMessage Struct {

    Message bytes &lt;code data-opaque bs-autolink-syntax='`JSON`'>JSON&lt;/code>

    Signature bytes &lt;code data-opaque bs-autolink-syntax='`JSON`'>JSON&lt;/code>

}
</pre>
   <p><a href="https://github.com/filecoin-project/go-filecoin/blob/ab60f73af1f86a954ef41e3252ef52a99066bbe2/types/signed_message.go#L25">Current Filecoin Implementation</a></p>
   <h4 class="heading settled" data-level="14.6.2" id="github"><span class="secno">14.6.2. </span><span class="content">Github</span><a class="self-link" href="#github"></a></h4>
   <httpsU0003A U0003131 filecoin-project github.com issues specs>
    <h4 class="heading settled" data-level="14.6.3" id="external-references"><span class="secno">14.6.3. </span><span class="content">External References</span><a class="self-link" href="#external-references"></a></h4>
    <ul>
     <li data-md>
      <p>How Recovering a Private Key from a message and a signature works in ethereum:</p>
     <li data-md>
      <ul>
       <li data-md>
        <httpsU0003A U00040libertylocked ec-signatures-and-recovery-in-ethereum-smart-contracts-560b6dd8876 medium.com></httpsU0003A>
      </ul>
     <li data-md>
      <p>More notes on recovery</p>
     <li data-md>
      <ul>
       <li data-md>
        <p><a href="https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106#18106">https://crypto.stackexchan ge.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106#18106</a></p>
      </ul>
     <li data-md>
      <p>See “4.1.6 Public Key Recovery Operation Page 47”</p>
     <li data-md>
      <ul>
       <li data-md>
        <httpU0003A sec1-v2.pdf www.secg.org></httpU0003A>
      </ul>
     <li data-md>
      <p>Secp256k1 Signature serialization -</p>
     <li data-md>
      <ul>
       <li data-md>
        <p>
         Secp256k1 cpp - 
         <httpsU0003A blob crypto ethash ethereum f5f0a8b1962544d2b6f40df8e4b0d9a32faf8f8e github.com go-ethereum include libsecp256k1 secp256k1 secp256k1_recovery.hU00023l55 vendor></httpsU0003A>
        </p>
      </ul>
     <li data-md>
      <p>
       Go-filecoin - 
       <httpsU0003A blob crypto e95bde8ff289b0c88d748e92b1bcca99ecc403cb filecoin-project github.com go-filecoin secp256.goU00023l98 secp256k1></httpsU0003A>
      </p>
    </ul>
    <h4 class="heading settled" data-level="14.6.4" id="references"><span class="secno">14.6.4. </span><span class="content">References</span><a class="self-link" href="#references"></a></h4>
    <p>TODO: this section should likely be removed, and the context it adds should be linked in some other way.</p>
    <ul>
     <li data-md>
      <p>Maybe Marshal/Unmarshal == NewSignedMessage/SignBytes?</p>
     <li data-md>
      <httpsU0003A blob filecoin-project github.com go-filecoin master signed_message.go types></httpsU0003A>
     <li data-md>
      <httpsU0003A blob filecoin-project github.com go-filecoin master signer.go types></httpsU0003A>
     <li data-md>
      <p>Message serialization currently: http://cbor.io</p>
     <li data-md>
      <p>
       Recover - Extract a PublicKey from SignatureBytes (Trade storage of PublicKey (pk) for CPU work to recover pk from a signature -- assumes signature bits are enough to recover pk which might not be the case for all signature algorithms). For full explanation of recover see: 
       <httpU0003A sec1-v2.pdf www.secg.org></httpU0003A>
      </p>
     <li data-md>
      <p>
       Point compression Go - 
       <httpsU0003A U000386fed781132ac890ee03e906e4ecd5d6fa180c64 blob btcd btcec btcsuite github.com signature.goU00023l338></httpsU0003A>
      </p>
     <li data-md>
      <p>
       Create recoverable sig - 
       <httpsU0003A U00039d62b9f0bc52d16160f79bfb84b2bbf0f6276b03 blob github.com go-secp256k1 include ipsn libsecp256k1 secp256k1_recovery.hU00023l70></httpsU0003A>
      </p>
     <li data-md>
      <p>
       Recid - 
       <httpsU0003A U0003314a61d72474aa29ff4afba8472553ad91d88e9d bitcoin-core blob ecdsa_impl.hU00023l288 github.com secp256k1 src></httpsU0003A>
      </p>
     <li data-md>
      <p>
       Serialize - 
       <httpsU0003A U0003314a61d72474aa29ff4afba8472553ad91d88e9d bitcoin-core blob ecdsa_impl.hU00023l177 github.com secp256k1 src></httpsU0003A>
      </p>
     <li data-md>
      <p>Should elliptic curve points always be compressed in Marshal?</p>
     <li data-md>
      <p>Recover is math trick trading CPU for space to generate sk*G</p>
     <li data-md>
      <p>Serialization should account for :</p>
     <li data-md>
      <ul>
       <li data-md>
        <p>Should there be point compression?</p>
      </ul>
     <li data-md>
      <p>Point compression (x,y); len(x) = n bits → x, recovery_bit; len(x||r_bit) = n+1 bits</p>
     <li data-md>
      <ul>
       <li data-md>
        <p>Easy to check add; use (mod2) or check last bit</p>
      </ul>
     <li data-md>
      <p>Sig = (r,s) - s is standard but r could be (rx,ry) or rx or r all of these can be used to generate r*G</p>
     <li data-md>
      <p>Recovery() can be used for (1) finding r<em>G from (r,s) and (2) pk = sk</em>G from SignatureBytes</p>
     <li data-md>
      <p>Remember that y = sqrt(curve equation for x) and there are 2 valid solutions for y. This should be accounted for in sig if point compression is used (i.e. if a PublicKey is provided (no compression) or recovered (compression) OR r is a point (no compression) or scalar(compression))</p>
    </ul>
    <p>Currently signatures are not sent over the wire on their own, instead they are encapsulated in in a <a href="https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L28">SignedMessage</a>. SignesMessage’s contain a Message and a Signature. When we want to send a SignedMessage over the wire we marshal it to cbor and send, once it is recevied it is unmarshaled form <a href="http://cbor.io/">cbor</a> back into the SignedMessage Structure. <a href="https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L38">Code for marshaling and unmarshaling SignedMessages </a>For opinions talks to @dig &amp; @phritz</p>
    <h4 class="heading settled" data-level="14.6.5" id="inspiration"><span class="secno">14.6.5. </span><span class="content">Inspiration</span><a class="self-link" href="#inspiration"></a></h4>
    <ul>
     <li data-md>
      <p>
       JSON Web Sigs/Keys: 
       <httpsU0003A html rfc7515 tools.ietf.org></httpsU0003A>
      </p>
     <li data-md>
      <p>
       NIST Signature Standard: 
       <httpsU0003A fips nist.fips.186-4.pdf nistpubs nvlpubs.nist.gov></httpsU0003A>
      </p>
     <li data-md>
      <p>
       Discussion on slack: 
       <httpsU0003A archives g7xur2tu2 p1528984460000977 protocollabs.slack.com></httpsU0003A>
      </p>
    </ul>
    <h2 class="heading settled" data-level="15" id="proofs"><span class="secno">15. </span><span class="content">Proofs</span><a class="self-link" href="#proofs"></a></h2>
    <p>The Filecoin protocol requires a means of generating and verifying the following cryptographic proofs:</p>
    <ul>
     <li data-md>
      <p>__<em>Proof of Replication</em>__ proves that a unique copy of a given __<em>sector</em>__ has been created. The <code>Seal</code> operation creates this unique copy and generates a corresponding __<em>Proof of Replication</em>__.</p>
     <li data-md>
      <p>__<em>Proof of Space-Time</em>__ proves that an arbitrary number of __<em>sealed sectors</em>__ existed over a specified period of time in their own dedicated storage — as opposed to being generated on-the-fly at proof time.</p>
     <li data-md>
      <p>__<em>Piece Inclusion Proof</em>__ proves that a given __<em>piece</em>__ is contained within a specified __<em>sealed sector</em>__.</p>
     <li data-md>
      <p>__<em>Proof of Retrievability</em>__ is a merkle proof that a given challenged leaf is present in an extant __<em>sealed sector</em>__.</p>
    </ul>
    <p>Throughout this document, the following definitions are used:</p>
    <ul>
     <li data-md>
      <p>__<em>sector:</em>__ a fixed-size block of data of <code>SECTOR_SIZE</code> bytes.</p>
     <li data-md>
      <p>__<em>piece:</em>__ a block of data of at most <code>SECTOR_SIZE</code> bytes.</p>
     <li data-md>
      <p>__<em>original data:</em>__ the concatenation of a __<em>sector’s</em>__ constitutent pieces, all __<em>piece padding</em>__, and any __<em>terminal padding</em>__.</p>
     <li data-md>
      <p>__<em>unsealed sector:</em>__ a concrete representation (on disk or in memory) of a sector’s __<em>original data</em>__.</p>
     <li data-md>
      <p>__<em>sealed sector:</em>__ a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an __<em>unsealed sector</em>__.</p>
     <li data-md>
      <p>__<em>piece padding:</em>__ a block of zero or more 'zero bytes' inserted between __<em>pieces</em>__ to ensure they are positioned within the containing __<em>sector</em>__ in a way compatible with the __<em>Piece Inclusion Proof</em>__.</p>
     <li data-md>
      <p>__<em>terminal padding:</em>__ a block of zero or more 'zero bytes' inserted after a __<em>sector’s</em>__ final piece, ensuring that the length of the __<em>original data</em>__ is <code>SECTOR_BYTES</code>.</p>
     <li data-md>
      <p>__<em>preprocessing:</em>__ a transformation applied to an __<em>unsealed sector</em>__ as the first stage of sealing and which may increase the size of the data.</p>
     <li data-md>
      <p>__<em>preprocessed data:</em>__ the result of __<em>preprocessing</em>__ the __<em>original data</em>__.</p>
     <li data-md>
      <p>__<em>preprocessed sector:</em>__ a concrete representation (on disk or in memory) of a __<em>sector’s</em>__ __<em>preprocessed data</em>__.</p>
     <li data-md>
      <p>__<em>SNARK proof:</em>__ a block of bytes which proves that the creator is in possession of a satisfying assignment to a quadratic arithmetic program (__<em>circuit</em>__).</p>
     <li data-md>
      <p>__<em>merkle inclusion proof:</em>__ a proof (whose format is unspecified here) that a given leaf block is contained within a merkle tree whose root is the __<em>commitment</em>__ associated with the proof.</p>
     <li data-md>
      <p>__<em>commitment:</em>__ an opaque block of data to which a prover 'commits', enabling subsequent proofs which cannot be validly constructed unless the __<em>commitment</em>__ itself was validly constructed. For example: the output of a suitable pseudorandom collision-resistant hash function may serve as a __<em>commitment</em>__ to the data which is the preimage of that hash. Publication of the __<em>commitment</em>__ proves that the creator was in possession of the preimage at the time the __<em>commitment</em>__ was generated.</p>
     <li data-md>
      <p>__<em>prover:</em>__ the party who generates a proof.</p>
     <li data-md>
      <p>__<em>verifier:</em>__ the party who verifies a proof generated by a __<em>prover</em>__.</p>
     <li data-md>
      <p>__<em>sectors count:</em>__ the number of sectors over which a proof-of-spacetime is performed (<code>POST_SECTORS_COUNT</code>).</p>
    </ul>
    <h3 class="heading settled" data-level="15.1" id="proof-of-replication"><span class="secno">15.1. </span><span class="content">Proof of Replication</span><a class="self-link" href="#proof-of-replication"></a></h3>
    <p>__<em>Proof of Replication</em>__ generates a unique copy (__<em>sealed sector</em>__) of a __<em>sector’s</em>__ __<em>original data</em>__, a __<em>SNARK proof</em>__, and a set of __<em>commitments</em>__ identifying the __<em>sealed sector</em>__ and linking it to the corresponding __<em>unsealed sector</em>__.</p>
    <h3 class="heading settled" data-level="15.2" id="seal"><span class="secno">15.2. </span><span class="content">Seal</span><a class="self-link" href="#seal"></a></h3>
    <p><code>Seal</code> has the side effect of generating a __<em>sealed sector</em>__ from an __<em>unsealed sector</em>__,  and returns identifying __<em>commitments</em>__ and a __<em>SNARK proof</em>__. The proof returned is a __<em>SNARK proofs</em>__.</p>
    <p>The commitments are used to verify that the correct __<em>original data</em>__ was sealed, and that the correct __<em>sealed data</em>__ is the subject of later __<em>Proofs of Space-Time</em>__, proving that this data is being stored continuously.</p>
    <p><code>Seal</code> operates by performing a slow encoding of the __<em>unsealed sector</em>__ — such that it is infeasible for a dishonest prover to computationally regenerate the __<em>sealed sector</em>__ quickly enough to satisfy subsequent required __<em>Proofs of Space-Time</em>__ — thus ensuring that the __<em>sealed sector</em>__ remains manifest as a unique, concrete representation of the __<em>original data</em>__.</p>
<pre>Seal
 (
  // request represents a request to seal a sector.
  proverID       [31]byte,    // uniquely identifies miner
  sealedAccess   string,      // identifier providing access to sealed sector-access
  sectorID       [31]byte,    // uniquely identifies sector
  storage        SectorStore, // used to manipulate sectors
  unsealedAccess string       // identifier providing access to unsealed sector-access
 ) err Error | (
  // response contains the commitments resulting from a successful Seal().
  commD          [32]byte,                       // data commitment: merkle root of original data
  commR          [32]byte,                       // replica commitment: merkle root of replicated data [will be removed in future iteration]
  commRStar      [32]byte,                       // a hash of intermediate layers
  proof          []byte,
 )

</pre>
    <h4 class="heading settled" data-level="15.2.1" id="verifyseal"><span class="secno">15.2.1. </span><span class="content">VerifySeal</span><a class="self-link" href="#verifyseal"></a></h4>
     <code>VerifySeal</code> is the functional counterpart to <code>Seal</code>'s proof component. It takes all of <code>Seal's</code> outputs, along with those of Seal’s inputs which are required to uniquely identify the created __<em>sealed sector</em>__. This allows a __<em>verifier</em>__ to determine whether a given proof is valid.  All inputs are required because verification requires sufficient context to determine not only that a proof is <em>valid</em> but also that the proof indeed corresponds to what it purports to prove. 
<pre>
VerifySeal
 (
  // request represents a request to verify the output of a Seal() operation.
  commD     [32]byte,                       // returned from Seal
  commR     [32]byte,                       // returned from Seal [will be removed in future iteration]
  commRStar [32]byte,                       // returned from Seal
  proof     []byte,                         // returned from Seal
  proverID  [31]byte,                       // uniquely identifies miner
  sectorID  [31]byte,                       // uniquely identifies sector
) err Error |
  IsValid bool                              // true iff the provided proof-of-replication os valid

</pre>
    <h4 class="heading settled" data-level="15.2.2" id="unseal"><span class="secno">15.2.2. </span><span class="content">Unseal</span><a class="self-link" href="#unseal"></a></h4>
    <p><code>Unseal</code> is the counterpart to <code>Seal</code>'s encoding side-effect. It reverses the 'slow encoding' and creates an __<em>unsealed sector</em>__ from a __<em>sealed sector</em>__ as a special case of its more general function. In general, it allows extraction of a range of bytes (specified in terms of the layout of the __<em>original data</em>__).</p>
<pre>Unseal
 (
  // request represents a request to unseal a sector.
  numBytes      uint64,      // number of bytes to unseal (corresponds to contents of unsealed sector-file)
  outputAccess  string,      // identifier providing access to write unsealed file-bytes
  proverID      [31]byte,    // uniquely identifies miner
  sealedAccess  string,      // identifier providing access to sealed sector-file
  sectorID      [31]byte,    // uniquely identifies sector
  startOffset   uint64,      // zero-based byte offset in original, unsealed sector-file
  storage       SectorStore  // used to manipulate sectors
 ) err Error |
  NumBytesWritten uint64     // the number of bytes unsealed (and written) by Unseal()
</pre>
    <h4 class="heading settled" data-level="15.2.3" id="security-notes"><span class="secno">15.2.3. </span><span class="content">Security Notes</span><a class="self-link" href="#security-notes"></a></h4>
    <h5 class="heading settled" data-level="15.2.3.1" id="guaranteeing-sector-uniqueness"><span class="secno">15.2.3.1. </span><span class="content">Guaranteeing sector uniqueness</span><a class="self-link" href="#guaranteeing-sector-uniqueness"></a></h5>
     Every sealed sector is unique, even if the unsealed data is identical. This prevents a malicious miner from storing the same sector twice without dedicating twice the amount of storage, or two malicious miners pretending to store the same sector, but only storing one copy. Sector uniqueness is guaranteed by having unique <code>proverId</code> and <code>sectorId</code>. Each miner has a unique <code>proverID</code>, and each sector has a unique <code>sectorID</code>within that miner’s sectors. Taken together, <code>proverID</code> and <code>sectorID</code> are globally unique . Both the <code>proverId</code> and the <code>sectorId</code> are used to encode the sealed data. 
    <p>The Filecoin node verifies that the correct <code>proverId</code> and <code>sectorId</code> is used when verifying the proof.</p>
    <hr>
    <h3 class="heading settled" data-level="15.3" id="proof-of-space-time"><span class="secno">15.3. </span><span class="content">Proof of Space-Time</span><a class="self-link" href="#proof-of-space-time"></a></h3>
     __NOTE:__ __<em>Proof of Space-Time</em>__ is in transition. Current implementations are mocked, and the final design has not been implemented. Consumers may refer to the below for reference, but nothing should be implemented until the spec is updated and synchronized with what will be the canonical construction. 
    <h4 class="heading settled" data-level="15.3.1" id="generatepost"><span class="secno">15.3.1. </span><span class="content">GeneratePost</span><a class="self-link" href="#generatepost"></a></h4>
    <p><code>GeneratePoSt</code> generates a __<em>Proof of Space-Time</em>__ over <code>POST_SECTORS_COUNT</code> __<em>sealed sectors</em>__ — identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (__<em>Proofs of Retrievability</em>__). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided <code>challengeSeed</code>. At each time step, a number of __<em>Proofs of Retrievability</em>__ are performed. The result of each such set of __<em>Proofs of Retrievability</em>__ is used to seed challenge generation for another iteration. Repeated and necessarily sequential generation of these __<em>Proofs of Retrievability</em>__ proves that the claimed __<em>sealed sectors</em>__ existed during the time required to generate them.</p>
    <p>Since many __<em>sealed sectors</em>__ may be proved at once, it may be the case that one or more __<em>sealed sectors</em>__ has been lost, damaged, or otherwise become impossible to validly prove. In this case, a fault is recorded and returned in an array of faults. This allows provers to selectively default on individual __<em>sealed sector</em>__ proofs while still providing a verifiable proof of their aggregate __<em>Proof of Space-Time</em>__ claims.</p>
<pre>GeneratePoSt
 (
  // request represents a request to generate a proof-of-spacetime.
  commRs         [POST_SECTORS_COUNT][32]byte,  // the commR commitments corresponding to the sealed sectors to prove
  challengeSeed  [32]byte,    // a pseudo-random value to be used in challenge generation
) err Error | (
  // response contains PoST proof and any faults that may have occurred.
  faults        []uint64,    // faults encountered while proving (by index of associated commR in the input)
  proof         []byte
)
</pre>
    <h4 class="heading settled" data-level="15.3.2" id="verifypost"><span class="secno">15.3.2. </span><span class="content">VerifyPoSt</span><a class="self-link" href="#verifypost"></a></h4>
    <p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>'s output, along with those of <code>GeneratePost</code>'s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p>
<pre>VerifyPoSt
 (
  // request represents a request to generate verify a proof-of-spacetime.
  commRs        [POST_SECTORS_COUNT][32]byte,        // the commRs provided to GeneratePoSt
  challengeSeed [32]byte,
  faults        []uint64
  proof         []byte,            // SNARK proof returned by GeneratePoSt
 ) err Error |
  isValid bool                     // true iff the provided Proof of Space-Time is valid
</pre>
    <hr>
    <h3 class="heading settled" data-level="15.4" id="piece-inclusion-proof"><span class="secno">15.4. </span><span class="content">Piece Inclusion Proof</span><a class="self-link" href="#piece-inclusion-proof"></a></h3>
    <h4 class="heading settled" data-level="15.4.1" id="pieceinclusionproof"><span class="secno">15.4.1. </span><span class="content">PieceInclusionProof</span><a class="self-link" href="#pieceinclusionproof"></a></h4>
     A <code>PieceInclusionProof</code> contains a merkle inclusion proof for the first and last node
of a piece. This ensures all 'edge' hashes necessary to generate a complete merkle
tree are available. 
    <p>Depending on the position of the nodes, not every hash provided will actually be needed.
As a space optimization, and at the cost of greater complexity in the encoding, 'interior' nodes
of either path may be omitted –– provided that the implementation <code>InclusionProof</code> allows for this omission.</p>
<pre>struct PieceInclusionProof {
    FirstNodeProof  InclusionProof,
    LastNodeProof   InclusionProof,
}
</pre>
    <h4 class="heading settled" data-level="15.4.2" id="generatepieceinclusionproofs"><span class="secno">15.4.2. </span><span class="content">GeneratePieceInclusionProofs</span><a class="self-link" href="#generatepieceinclusionproofs"></a></h4>
    <p><code>GeneratePieceInclusionProofs</code> takes a merkle tree and a slice of piece lengths, and returns
a vector of <code>PieceInclusionProofs</code> corresponding to the pieces. This assumes that the first
piece begins at offset 0, and that each piece begins directly after the previous piece ends.
For this method to work, the piece data used to validate pieces will need to be padded as necessary,
and pieces will need to be aligned (to 128-byte chunks due to details of __<em>preprocessing</em>__) when written.</p>
<pre>GeneratePieceInclusionProofs
 (
  Tree MerkleTree,
  PieceLengths uint,
 ) []PieceInclusionProof
</pre>
    <p><code>GeneratePieceInclusionProof</code> takes a merkle tree and the index positions of the first and last nodes
of the piece whose inclusion should be proved. It returns a corresponding <code>PieceInclusionProof</code>.
For the resulting proof to be valid, first_node must be &lt;= last_node.</p>
<pre>GeneratePieceInclusionProof
 (
  tree       MerkleTree,
  firstNode  uint,
  lastNode   uint,
 ) err Error | proof PieceInclusionProof
</pre>
    <p><code>VerifyPieceInclusionProof</code> takes a merkle root and (pre-processed) piece data.
Iff it returns true, then <code>PieceInclusionProof</code> indeed proves that piece’s
bytes were included in the merkle tree corresponding to root — and at the
position encoded in the proof.</p>
<pre>VerifyPieceInclusionProof
 (
  proof PieceInclusionProof,
  root  [32]byte,
  piece []byte
 ) err Error | IsValid bool // true iff the provided PieceInclusionProof is valid.
</pre>
    <h2 class="heading settled" data-level="16" id="filecoin-network-protocols"><span class="secno">16. </span><span class="content">Filecoin Network Protocols</span><a class="self-link" href="#filecoin-network-protocols"></a></h2>
    <p>TODO: table of contents</p>
    <hr>
    <p>All filecoin network protocols are implemented as libp2p protocols. This document will assume that all data is communicated between peers on a libp2p stream.</p>
    <h3 class="heading settled" data-level="16.1" id="cbor-rpc"><span class="secno">16.1. </span><span class="content">CBOR RPC</span><a class="self-link" href="#cbor-rpc"></a></h3>
    <p>Reference:</p>
    <ul>
     <li data-md>
      <p><a href="https://tools.ietf.org/html/rfc7049">RFC 7049, Concise Binary Object Representation</a></p>
     <li data-md>
      <p><a href="https://en.wikipedia.org/wiki/LEB128">Little Endian Base 128</a></p>
    </ul>
    <p>Filecoin uses many pre-existing protocols from ipfs and libp2p, and also implements several new protocols of its own. For these Filecoin specific protocols, we will try to use a CBOR RPC protocol format. This format is effectively just a leb128 varint length delimeted series of cbor serialized objects. Whenever a filecoin protocol says "send X", it means "cbor serialize the object X, write its length encoded using unsigned leb128, then write the serialized bytes".</p>
<pre class="language-go highlight"><c- a>func</c-> ReadCborRPC<c- p>(</c->r io<c- p>.</c->Reader<c- p>,</c-> out <c- o>*</c->Object<c- p>)</c-> <c- p>{</c->
	l <c- o>:=</c-> ReadUVarint<c- p>(</c->r<c- p>)</c->

	<c- c1>// Read 'l' bytes from the reader</c->
	buf <c- o>:=</c-> ReadCountBytes<c- p>(</c->r<c- p>,</c-> l<c- p>)</c->

	cbor<c- p>.</c->Unmarshal<c- p>(</c->buf<c- p>,</c-> out<c- p>)</c->
<c- p>}</c->

<c- a>func</c-> WriteCborRPC<c- p>(</c->w io<c- p>.</c->Writer<c- p>,</c-> obj Object<c- p>)</c-> <c- p>{</c->
	buf <c- o>:=</c-> cbor<c- p>.</c->Marshal<c- p>(</c->obj<c- p>)</c->

	WriteUVarint<c- p>(</c->w<c- p>,</c-> len<c- p>(</c->buf<c- p>))</c->

	w<c- p>.</c->Write<c- p>(</c->buf<c- p>)</c->
<c- p>}</c->
</pre>
    <h3 class="heading settled" data-level="16.2" id="hello-handshake"><span class="secno">16.2. </span><span class="content">Hello Handshake</span><a class="self-link" href="#hello-handshake"></a></h3>
    <p>The Hello protocol is used when two filecoin nodes initially connect to eachother in order to determine information about the other node. The libp2p protocol ID for this protocol is <code>/fil/hello/1.0.0</code>.</p>
    <p>Whenever a node gets a new connection, it opens a new stream on that connection and 'says hello'. This is done by crafting a <code>HelloMessage</code>, sending it to the other peer using CBOR RPC and finally, closing the stream.</p>
<pre class="language-go highlight"><c- a>type</c-> HelloMessage <c- a>struct</c-> <c- p>{</c->
    HeaviestTipSet <c- p>[]</c->Cid
    HeaviestTipSetHeight <c- b>uint64</c->
    GenesisHash Cid
<c- p>}</c->
</pre>
<pre class="language-go highlight"><c- a>func</c-> SayHello<c- p>(</c->p PeerID<c- p>)</c-> <c- p>{</c->
    s <c- o>:=</c-> OpenStream<c- p>(</c->p<c- p>)</c->
    mes <c- o>:=</c-> GetHelloMessage<c- p>()</c->
    serialized <c- o>:=</c-> cbor<c- p>.</c->Marshal<c- p>(</c->mes<c- p>)</c->

    WriteUVarint<c- p>(</c->s<c- p>,</c-> len<c- p>(</c->serialized<c- p>))</c->

    s<c- p>.</c->Write<c- p>(</c->serialized<c- p>)</c->
    s<c- p>.</c->Close<c- p>()</c->
<c- p>}</c->
</pre>
    <p>Upon receiving a 'hello' stream from another node, you should read off the CBOR RPC message, and then check that the genesis hash matches you genesis hash. If it does not, that node is not part of your network, and should probably be disconnected from. Next, the <code>HeaviestTipSet</code>, claimed <code>HeaviestTipSetHeight</code>, and peerID of the other node should be passed to the chain sync subsystem.</p>
    <h3 class="heading settled" data-level="16.3" id="storage-deal"><span class="secno">16.3. </span><span class="content">Storage Deal</span><a class="self-link" href="#storage-deal"></a></h3>
    <p>The storage deal protocol is used by any client to store data with a storage miner. The libp2p protocol ID for this protocol is <code>/fil/storage/mk/1.0.0</code>.</p>
    <p>The protocol starts with storage client (which in this case may be a normal storage client, or a broker). It is assumed that the client has their data already prepared into a <code>piece</code> prior to executing this protocol.</p>
    <p>First the client sends a signed <code>StorageDealProposal</code> to the storage miner:</p>
<pre class="language-go highlight"><c- a>type</c-> StorageDealProposal <c- a>struct</c-> <c- p>{</c->
    <c- c1>// PieceRef is the hash of the data in native structure. This will be used for</c->
    <c- c1>// certifying the data transfer</c->
    PieceRef Cid

    <c- c1>// TranslatedRef is the data hashed in a form that is compatible with the proofs system</c->
    <c- c1>// TODO: this *could* possibly be combined with the PieceRef</c->
    TranslatedRef Cid

    Size NumBytes

    TotalPrice TokenAmount

    <c- c1>// Duration is how long the file should be stored for</c->
    Duration NumBlocks

    <c- c1>// PaymentRef is a reference to the mechanism that the proposer</c->
    <c- c1>// will use to pay the miner. It should be verifiable by the</c->
    <c- c1>// miner using on-chain information.</c->
    Payment PaymentInfo

    <c- c1>// MinerAddress is the address of the storage miner in the deal proposal</c->
    MinerAddress Address

    ClientAddress Address
    Signature Signature
<c- p>}</c->

<c- a>type</c-> PaymentInfo <c- a>struct</c-> <c- p>{</c->
    <c- c1>// PayChActor is the address of the payment channel actor</c->
    <c- c1>// that will be used to facilitate payments</c->
    PayChActor Address

    <c- c1>// Payer is the address of the owner of the payment channel</c->
    Payer Address

    <c- c1>// Channel is the ID of the specific channel the client will</c->
    <c- c1>// use to pay the miner. It must already have sufficient funds locked up</c->
    Channel ChannelID

    <c- c1>// ChannelMsgCid is the B58 encoded CID of the message used to create the</c->
    <c- c1>// channel. Adding the message cid allows the miner to wait until the</c->
    <c- c1>// channel is accepted on chain.</c->
    ChannelMsgCid cid<c- p>.</c->Cid

    <c- c1>// Vouchers is a set of payments from the client to the miner that can be</c->
    <c- c1>// cashed out contingent on the agreed upon data being provably within a</c->
    <c- c1>// live sector in the miners control on-chain</c->
    Vouchers <c- p>[]</c->PaymentVouchers
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="16.3.1" id="deal-state-values"><span class="secno">16.3.1. </span><span class="content">Deal State Values</span><a class="self-link" href="#deal-state-values"></a></h4>
     Legal values for <code>DealState</code> are as follows: 
<pre class="language-go highlight"><c- a>const</c-> <c- p>(</c->
	<c- c1>// Unset implies a programmer error. This value should never appear</c->
    <c- c1>// in an actual message</c->
    Unset <c- p>=</c-> <c- mi>0</c->

	<c- c1>// Unknown signifies an unknown negotiation</c->
	Unknown <c- p>=</c-> <c- mi>1</c->

	<c- c1>// Rejected means the deal was rejected for some reason</c->
	Rejected <c- p>=</c-> <c- mi>2</c->

	<c- c1>// Accepted means the deal was accepted but hasnt yet started</c->
	Accepted <c- p>=</c-> <c- mi>3</c->

	<c- c1>// Started means the deal has started and the transfer is in progress</c->
	Started <c- p>=</c-> <c- mi>4</c->

	<c- c1>// Failed means the deal has failed for some reason</c->
	Failed <c- p>=</c-> <c- mi>5</c->

	<c- c1>// Complete means the deal is complete, and the sector that the deal is contained</c->
    <c- c1>// in has been sealed and its commitment posted on chain.</c->
	Complete <c- p>=</c-> <c- mi>6</c->

    <c- c1>// Staged is used by the storage deal protocol to indicate the data has been</c->
    <c- c1>// received and staged into a sector, but is not sealed yet</c->
    Staged <c- p>=</c-> <c- mi>7</c->
<c- p>)</c->
</pre>
<pre class="language-go highlight"><c- a>func</c-> SendStorageProposal<c- p>(</c->miner Address<c- p>,</c-> file Cid<c- p>,</c-> duration NumBlocks<c- p>,</c-> price TokenAmount<c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>!</c->IsMiner<c- p>(</c->miner<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"given address was not a miner"</c-><c- p>)</c->
    <c- p>}</c->

    <c- c1>// Get a PoRep friendly commitment from the file</c->
    commitment<c- p>,</c-> size <c- o>:=</c-> ProcessRef<c- p>(</c->file<c- p>)</c->

    <c- c1>// Get a handle on the payment system to be used to pay this miner</c->
    <c- c1>// Most likely, this grabs an existing payment channel, or creates</c->
    <c- c1>// a new one</c->
    payments <c- o>:=</c-> PaymentSysToMiner<c- p>(</c->miner<c- p>)</c->

    payInfo <c- o>:=</c-> payments<c- p>.</c->CreatePaymentInfo<c- p>(</c->storageStart<c- p>,</c-> duration<c- p>,</c-> price <c- o>*</c-> size<c- p>)</c->

    prop <c- o>:=</c-> StorageDealProposal<c- p>{</c->
	PieceRef<c- p>:</c-> file<c- p>,</c->
	TranslatedRef<c- p>:</c-> commitment<c- p>,</c->
	TotalPrice<c- p>:</c-> price <c- o>*</c-> size<c- p>,</c-> <c- c1>// Maybe just leave this to the payment info?</c->
	Duration<c- p>:</c-> duration<c- p>,</c->
	Size<c- p>:</c-> size<c- p>,</c->
	Payment<c- p>:</c-> payInfo<c- p>,</c->
    <c- p>}</c->

	client<c- p>.</c->SignProposal<c- p>(</c->prop<c- p>)</c->

	peerid <c- o>:=</c-> lookup<c- p>.</c->ByMinerAddress<c- p>(</c->miner<c- p>)</c->
	s <c- o>:=</c-> NewStream<c- p>(</c->peerid<c- p>,</c-> MakeStorageDealProtocolID<c- p>)</c->

	CborRpc<c- p>.</c->Write<c- p>(</c->s<c- p>,</c-> prop<c- p>)</c->

	resp <c- o>:=</c-> CborRpc<c- p>.</c->Read<c- p>(</c->s<c- p>)</c->

	<c- k>switch</c-> resp<c- p>.</c->State <c- p>{</c->

	<c- p>}</c->
<c- p>}</c->
</pre>
    <p>TODO: possibly also include a starting block height here, to indicate when this deal may be started (implying you could select a value in the future). After the first response, both parties will have signed agreeing that the deal started at that point. This could possibly be used to challenge either party in the event of a stall. This starting block height also gives the miner time to seal and post the commitment on chain. Otherwise a weird condition exists where a client could immediately slash a miner for not having their data stored.</p>
    <p>The miner then decides whether or not to accept the deal, and sends back a response:</p>
<pre class="language-go highlight"><c- a>type</c-> StorageDealResponse <c- a>struct</c-> <c- p>{</c->
    State DealState

    <c- c1>// Message is an optional message to add context to any given response</c->
    Message <c- b>string</c->

    <c- c1>// ProposalCid is the cid of the StorageDealProposal object this response is for</c->
    ProposalCid Cid

    <c- c1>// PieceConfirmation is a collection of information needed to convince the client that</c->
    <c- c1>// the miner has sealed the data into a sector.</c->
    PieceConfirmation PieceConfirmation

    <c- c1>// Signature is a signature from the miner over the response</c->
    Signature Signature
<c- p>}</c->
</pre>
<pre class="language-go highlight"><c- a>func</c-> HandleStorageDealProposal<c- p>(</c->s Stream<c- p>)</c-> <c- p>{</c->
    prop <c- o>:=</c-> CborRpc<c- p>.</c->Read<c- p>(</c->s<c- p>)</c->

    <c- k>if</c-> <c- p>!</c->ValidateInput<c- p>(</c->prop<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"client sent invalid proposal"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> accept<c- p>,</c-> reason <c- o>:=</c-> MinerPolicy<c- p>.</c->ShouldAccept<c- p>(</c->prop<c- p>);</c-> <c- p>!</c->accept <c- p>{</c->
        CborRpc<c- p>.</c->Write<c- p>(</c->s<c- p>,</c-> StorageDealResponse<c- p>{</c->
            State<c- p>:</c-> Rejected<c- p>,</c->
            Message<c- p>:</c-> reason<c- p>,</c->
        <c- p>})</c->
        <c- k>return</c->
    <c- p>}</c->

    <c- c1>// Alright, we’re accepting</c->
    resp <c- o>:=</c-> StorageDealResponse<c- p>{</c->
        State<c- p>:</c-> Accepted<c- p>,</c->
        Proposal<c- p>:</c-> prop<c- p>.</c->Cid<c- p>(),</c->
    <c- p>}</c->

    miner<c- p>.</c->Sign<c- p>(</c->resp<c- p>)</c->

    miner<c- p>.</c->SetDealState<c- p>(</c->resp<c- p>)</c->

    <c- c1>// Make sure we are ready to receive the file (however it may come)</c->
    <c- c1>// TODO: potentially add in something to the protocol to allow</c->
    <c- c1>// clients to signal how the file will be transferred</c->
    miner<c- p>.</c->RegisterInboundFileTransfer<c- p>(</c->resp<c- p>)</c->

    CborRpc<c- p>.</c->Write<c- p>(</c->s<c- p>,</c-> resp<c- p>)</c->
<c- p>}</c->

<c- a>func</c-> ValidateInput<c- p>(</c->prop StorageDealProposal<c- p>)</c-> <c- p>{</c->
    <c- c1>// Note: Maybe this is unnecessary, and the payment info being valid suffices?</c->
    <c- k>if</c-> <c- p>!</c->ValidateSignature<c- p>(</c->prop<c- p>.</c->Signature<c- p>,</c-> prop<c- p>.</c->ClientAddress<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"invalid signature from client"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> <c- p>!</c->IsExistingAccount<c- p>(</c->prop<c- p>.</c->ClientAddress<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"proposal came from a fake account"</c-><c- p>)</c->
    <c- p>}</c->

    <c- k>if</c-> <c- p>!</c->ValidatePaymentInfo<c- p>(</c->prop<c- p>.</c->Payment<c- p>,</c-> prop<c- p>.</c->Duration<c- p>,</c-> prop<c- p>.</c->Size<c- p>)</c-> <c- p>{</c->
        Fatal<c- p>(</c-><c- s>"propsal had invalid payment information"</c-><c- p>)</c->
    <c- p>}</c->
<c- p>}</c->
</pre>
    <p>If <code>response.State</code> is <code>Accepted</code> then the client should proceed to transfer the data in question to the storage miner. This operation happens out of band from this protocol, and can be a simple bitswap transfer at first. Support for other more 'exotic' 'protocols' such as mailing hard drives is an explicit goal.</p>
    <p>Next, when the miner receives all the data and validates it, they set the deals state to <code>Staged</code>. When the sector gets sealed, and the commitment is posted on chain, the state gets set to <code>Complete</code> and the deals <code>PieceConfirmation</code> field should be set to the appropriate values.</p>
<pre class="language-go highlight"><c- a>func</c-> OnDataReceived<c- p>()</c-> <c- p>{</c->
    <c- c1>// TODO: document process for updating deal state and</c->
    <c- c1>// starting seal after data is received</c->
<c- p>}</c->
</pre>
    <p>Once the deal makes it to this state, the client should be able to query and get the <code>PieceConfirmation</code> that they need to complete their proofs of repair for the data.</p>
    <h3 class="heading settled" data-level="16.4" id="query"><span class="secno">16.4. </span><span class="content">Query</span><a class="self-link" href="#query"></a></h3>
    <p>Here we describe a basic protocol for querying the current state of a given storage deal. In the future we may want something more complex that is able to multiplex waiting for notifications about a large set of deals over a single stream simultaneously. Upgrading to that from this should be relatively simple, so for now, we do the simple thing.</p>
    <p>The libp2p protocol ID for this protocol is <code>/fil/storage/qry/1.0.0</code></p>
    <p>At any point, the client in this flow may query the miner for the state of a given proposal. To query, they send a 'StorageDealQuery' that looks like this:</p>
<pre class="language-go highlight"><c- a>type</c-> StorageDealQuery <c- a>struct</c-> <c- p>{</c->
    <c- c1>// ProposalCid is the cid of the proposal for the deal that we are querying</c->
    <c- c1>// the state of</c->
    ProposalCid <c- o>*</c->cid<c- p>.</c->Cid

    BaseState DealState
<c- p>}</c->
</pre>
    <p>If <code>BaseState</code> is <code>Unset</code> or a terminal state (<code>Complete</code>, <code>Rejected</code>, or <code>Failed</code>) then the current state of the deal in question is returned. If the <code>BaseState</code> is different than the current state of the deal, the current state of the deal is also returned immediately. In the case that the <code>BaseState</code> matches the current state of the deal, then the stream is held open until the state changes, at which point the new state of the deal is returned.</p>
    <h3 class="heading settled" data-level="16.5" id="retrieve-piece-for-free"><span class="secno">16.5. </span><span class="content">Retrieve Piece for Free</span><a class="self-link" href="#retrieve-piece-for-free"></a></h3>
    <p>The Retrieve Piece for Free protocol is used to coordinate the transfer of a piece from miner to client at no cost to the client.</p>
    <p>The client initiates the protocol by opening a libp2p stream to the miner using the <code>/fil/retrieval/free/0.0.0</code> protocol id. To find and connect to the miner, the <a href="lookup-service.md">address lookup service</a> should be used. Once connected, the client must send the miner a <code>RetrievePieceRequest</code> message using the [CBOR RPC] protocol format.</p>
    <p>The <code>RetrievePieceRequest</code> is specified as follows:</p>
<pre class="language-go highlight"><c- a>type</c-> RetrievePieceRequest <c- a>struct</c-> <c- p>{</c->
    <c- c1>// &lt;code data-opaque bs-autolink-syntax='`PieceRef`'>PieceRef&lt;/code> identifies a piece of user data, typically received from the</c->
    <c- c1>// client while consummating a storage deal.</c->
    PieceRef <c- o>*</c->cid<c- p>.</c->Cid
<c- p>}</c->
</pre>
    <p>When the miner receives the request, it responds with a <code>RetrievePieceResponse</code> message indicating that it has accepted or rejected the request.</p>
    <p>The <code>RetrievePieceResponse</code> message is specified as follows:</p>
<pre class="language-go highlight"><c- a>type</c-> RetrievePieceResponse <c- a>struct</c-> <c- p>{</c->
    <c- c1>// &lt;code data-opaque bs-autolink-syntax='`Status`'>Status&lt;/code> communicates the miner’s willingness to send a piece back to a</c->
    <c- c1>// client. The value of the &lt;code data-opaque bs-autolink-syntax='`Status`'>Status&lt;/code> field must be one of: &lt;code data-opaque bs-autolink-syntax='`Failure`'>Failure&lt;/code> or</c->
    <c- c1>// &lt;code data-opaque bs-autolink-syntax='`Success`'>Success&lt;/code>.</c->
    Status RetrievePieceStatus

    <c- c1>// If &lt;code data-opaque bs-autolink-syntax='`Status`'>Status&lt;/code> is &lt;code data-opaque bs-autolink-syntax='`Failure`'>Failure&lt;/code>, &lt;code data-opaque bs-autolink-syntax='`ErrorMessage`'>ErrorMessage&lt;/code> should contain a string</c->
    <c- c1>// explaining the cause for the rejection.</c->
    ErrorMessage <c- b>string</c->
<c- p>}</c->
</pre>
    <p>Legal values for <code>RetrievePieceStatus</code> are as follows:</p>
<pre class="language-go highlight"><c- a>const</c-> <c- p>(</c->
	<c- c1>// Unset implies a programmer error. This value should never appear in an</c->
	<c- c1>// actual message.</c->
	Unset <c- p>=</c-> RetrievePieceStatus<c- p>(</c-><c- kc>iota</c-><c- p>)</c->

	<c- c1>// Failure indicates that the piece can not be retrieved from the miner.</c->
	Failure

	<c- c1>// Success means that the piece can be retrieved from the miner.</c->
	Success
<c- p>)</c->
</pre>
    <p>If the miner does not accept the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Failure</code>. The miner should set the <code>ErrorMessage</code> field to indicate a reason for the request being rejected.</p>
    <p>If the miner accepts the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Success</code>. The miner then sends the client ordered <code>RetrievePieceChunk</code> messages until all of the piece’s data has been transferred, at which point the miner closes the stream.</p>
    <p class="note" role="note"><span>Note:</span> The client must be able to reconstruct a piece by concatenating the <code>Data</code>-bytes in the order that they were received.</p>
    <p class="note" role="note"><span>Note:</span> The miner divides the piece in to chunks containing a maximum of <code>256 &lt;&lt; 8</code> bytes due to a limitation in our software which caps the size of CBOR-encoded messages at <code>256 &lt;&lt; 10</code> bytes.</p>
    <p>The <code>RetrievePieceChunk</code> message is specified as follows:</p>
<pre class="language-go highlight"><c- a>type</c-> RetrievePieceChunk <c- a>struct</c-> <c- p>{</c->
    <c- c1>// The &lt;code data-opaque bs-autolink-syntax='`Data`'>Data&lt;/code> field contains a chunk of a piece. The length of &lt;code data-opaque bs-autolink-syntax='`Data`'>Data&lt;/code> must</c->
    <c- c1>// be > 0.</c->
    Data <c- p>[]</c-><c- b>byte</c->
<c- p>}</c->
</pre>
    <p>TODO: document the query deal interaction</p>
    <h3 class="heading settled" data-level="16.6" id="blocksync"><span class="secno">16.6. </span><span class="content">BlockSync</span><a class="self-link" href="#blocksync"></a></h3>
    <p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol with a protocol ID of <code>/fil/sync/blk/0.0.0</code>. It uses CBOR-RPC.</p>
<pre class="language-go highlight"><c- a>type</c-> BlockSyncRequest <c- a>struct</c-> <c- p>{</c->
    Start Cid
    RequestLength <c- b>uint64</c->
<c- p>}</c->
</pre>
    <p>The request requests a chain of a given length by the hash of its highest block.</p>
<pre class="language-go highlight"><c- a>type</c-> BlockSyncResponse <c- a>struct</c-> <c- p>{</c->
    Blocks <c- p>[]</c->Block

    Status <c- b>uint</c->
    Message <c- b>string</c->
<c- p>}</c->
</pre>
    <p>The response contains the chain of requested blocks, in reverse iteration order, the zero’th block should be the block referenced by <code>request.Start</code>, and the following N blocks should be its N parents, and so on. This is done to streamline validation.</p>
    <p>Possible error codes:</p>
<pre class="language-go highlight"><c- a>const</c-> <c- p>(</c->
	Success <c- p>=</c-> <c- mi>0</c->

    <c- c1>// Sent back fewer blocks than requested</c->
    PartialResponse <c- p>=</c-> <c- mi>101</c->

    <c- c1>// request.Start not found</c->
    BlockNotFound <c- p>=</c-> <c- mi>201</c->

    <c- c1>// requester is making too many requests</c->
    GoAway <c- p>=</c-> <c- mi>202</c->

    <c- c1>// Internal Error</c->
    InternalError <c- p>=</c-> <c- mi>203</c->
<c- p>)</c->
</pre>
    <h2 class="heading settled" data-level="17" id="filecoin-data-propagation"><span class="secno">17. </span><span class="content">Filecoin Data Propagation</span><a class="self-link" href="#filecoin-data-propagation"></a></h2>
    <p>The filecoin network needs to broadcast blocks and messages to all peers in the network. This document details how that process works.</p>
    <p>Both blocks and messages are propagated using the gossipsub libp2p pubsub router. The pubsub messages are authenticated. For blocks, the pubsub hop validation function is set to check that the block is valid before re-propagating. For messages, a similar validity check is run, the signature must be valid, and the account in question must have enough funds to cover the actions specified.</p>
    <h3 class="heading settled" data-level="17.1" id="links"><span class="secno">17.1. </span><span class="content">Links</span><a class="self-link" href="#links"></a></h3>
    <ul>
     <li data-md>
      <p><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">Gossipsub Spec</a></p>
     <li data-md>
      <p><a href="mining.md#chain-validation">Block Validity Check</a></p>
     <li data-md>
      <p>TODO: Link to message validity check function</p>
    </ul>
    <h3 class="heading settled" data-level="17.2" id="block-propagation"><span class="secno">17.2. </span><span class="content">Block Propagation</span><a class="self-link" href="#block-propagation"></a></h3>
    <p>Blocks are propagated over the libp2p pubsub channel <code>/fil/blocks</code>. The block is <a href="data-structures.md#block">serialized</a> and the raw bytes are sent as the content of the pubsub message. No messages, computed state, or other additional information is sent along with the block message.</p>
    <p>Each Filecoin node sets a 'validation function' for the blocks topic that checks that the block is properly constructed, its ticket is valid, the block signature is valid, the miner is a valid miner, and the block is a child of a known good tipset. (TODO: clarify which of these checks are needed, any slowness here impacts propagation time significantly, this is not a full validity check) If an invalid block is received, the peer it was received from should be marked as potentially bad (TODO: we could blacklist peers who send bad blocks, maybe need support from libp2p for this?)</p>
    <p>TODO: we should likely be smarter here and track which messages we could send along with each block to improve propagation time</p>
    <h3 class="heading settled" data-level="17.3" id="message-propagation"><span class="secno">17.3. </span><span class="content">Message Propagation</span><a class="self-link" href="#message-propagation"></a></h3>
    <p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. The message is <a href="data-structures.md#messages">serialized</a> and the raw bytes are sent as the content of the pubsub message.</p>
    <p>The pubsub validation function for messages checks that the content of each pubsub message on this topic is, first, under the maximum size limit for a message, and then that it is a properly constructed message. (TODO: discuss checking signatures and account balances, some tricky bits that need consideration). If an invalid message is received from a peer, that peer should be marked as potentially bad.</p>
    <h2 class="heading settled" data-level="18" id="data-structures"><span class="secno">18. </span><span class="content">Data Structures</span><a class="self-link" href="#data-structures"></a></h2>
    <p>This document serves as an entry point for understanding all of the data structures in filecoin.</p>
    <p>TODO: this should also include, or reference, how each data structure is serialized precisely.</p>
    <h3 class="heading settled" data-level="18.1" id="address"><span class="secno">18.1. </span><span class="content">Address</span><a class="self-link" href="#address"></a></h3>
    <p>An address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. An address encodes information about the network it belongs to, the type of data it contains, the data itself, and depending on the type, a checksum.</p>
<pre class="language-go highlight"><c- a>type</c-> Address <c- a>struct</c-> <c- p>{</c->

    <c- c1>// 0: ID</c->
    <c- c1>// 1: SECP256K1 Public Key</c->
    <c- c1>// 2: Actor</c->
    <c- c1>// 3: BLS Public Key</c->
    protocol <c- b>byte</c->

    <c- c1>// raw bytes containing the data associated with protocol</c->
    payload <c- p>[]</c-><c- b>byte</c->
<c- p>}</c->
</pre>
    To learn more, take a look at the <a href="https://github.com/filecoin-project/specs/blob/master/address.md">Address Spec</a>. 
    <h3 class="heading settled" data-level="18.2" id="cid"><span class="secno">18.2. </span><span class="content">CID</span><a class="self-link" href="#cid"></a></h3>
    <p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used. This is effectively a hash value, prefixed with its hash function (multihash) prepended with a few extra labels to inform applications about how to deserialize the given data. To learn more, take a look at the <a href="https://github.com/ipld/cid">CID Spec</a>.</p>
    <p>CIDs are serialized by applying binary multibase encoding, then encoding that as a CBOR byte array with a tag of 42.</p>
    <h3 class="heading settled" data-level="18.3" id="block"><span class="secno">18.3. </span><span class="content">Block</span><a class="self-link" href="#block"></a></h3>
    <p>A block represents an individual point in time that the network may achieve consensus on. It contains (via merkle links) the full state of the system, references to the previous state, and some notion of a 'weight' for deciding which block is the 'best'.</p>
<pre class="language-go highlight"><c- c1>// Block is a block in the blockchain.</c->
<c- a>type</c-> Block <c- a>struct</c-> <c- p>{</c->
	<c- c1>// Miner is the address of the miner actor that mined this block.</c->
	Miner Address

	<c- c1>// Tickets are the winning ticket that were submitted with this block.</c->
	Tickets <c- p>[]</c->Ticket

    <c- c1>// ElectionProof is a signature over the final ticket that proves this miner</c->
    <c- c1>// is the leader at this round</c->
    ElectionProof Signature

	<c- c1>// Parents is the set of parents this block was based on. Typically one,</c->
	<c- c1>// but can be several in the case where there were multiple winning ticket-</c->
	<c- c1>// holders for a round.</c->
	Parents <c- p>[]</c->Cid

	<c- c1>// ParentWeight is the aggregate chain weight of the parent set.</c->
	ParentWeight Integer

	<c- c1>// Height is the chain height of this block.</c->
	Height Uint64

    <c- c1>// StateRoot is a cid pointer to the state tree after application of the</c->
	<c- c1>// transactions state transitions.</c->
	StateRoot Cid

	<c- c1>// Messages is the set of messages included in this block</c->
	<c- c1>// TODO: should be a merkletree-ish thing</c->
	Messages <c- p>[]</c->SignedMessage

	<c- c1>// MessageReceipts is a set of receipts matching to the sending of the &lt;code data-opaque bs-autolink-syntax='`Messages`'>Messages&lt;/code>.</c->
    <c- c1>// TODO: should be the same type of merkletree-list thing that the messages are</c->
	MessageReceipts <c- p>[]</c->MessageReceipt
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.3.1" id="serialization"><span class="secno">18.3.1. </span><span class="content">Serialization</span><a class="self-link" href="#serialization"></a></h4>
    <p>Blocks are currently serialized simply by CBOR marshaling them, using lower-camel-cased field names.</p>
    <h3 class="heading settled" data-level="18.4" id="message"><span class="secno">18.4. </span><span class="content">Message</span><a class="self-link" href="#message"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> Message <c- a>struct</c-> <c- p>{</c->
	To   Address
	From Address

	<c- c1>// When receiving a message from a user account the nonce in</c->
	<c- c1>// the message must match the expected nonce in the from actor.</c->
	<c- c1>// This prevents replay attacks.</c->
	Nonce Integer

	Value Integer

    GasPrice Integer
    GasLimit Integer

	Method <c- b>string</c->
	Params <c- p>[]</c-><c- b>byte</c->
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.4.1" id="parameter-encoding"><span class="secno">18.4.1. </span><span class="content">Parameter Encoding</span><a class="self-link" href="#parameter-encoding"></a></h4>
    <p>Parameters to methods get encoded as described in the <a href="#basic-type-encodings">basic types</a> section below, and then put into a CBOR encoded array.</p>
    <h4 class="heading settled" data-level="18.4.2" id="signing"><span class="secno">18.4.2. </span><span class="content">Signing</span><a class="self-link" href="#signing"></a></h4>
    <p>A signed message is a wrapper type over the base message.</p>
<pre class="language-go highlight"><c- a>type</c-> SignedMessage <c- a>struct</c-> <c- p>{</c->
    Message Message
    Signature Signature
<c- p>}</c->
</pre>
    <p>The signature is a serialized signature over the serialized base message. For more details on how the signature itself is done, see the <a href="signatures.md">signatures spec</a>.</p>
    <h4 class="heading settled" data-level="18.4.3" id="serialization①"><span class="secno">18.4.3. </span><span class="content">Serialization</span><a class="self-link" href="#serialization①"></a></h4>
    <p>Messages and SignedMessages are currently serialized simply by CBOR marshaling them, using lower-camel-cased field names.</p>
    <h3 class="heading settled" data-level="18.5" id="message-receipt"><span class="secno">18.5. </span><span class="content">Message Receipt</span><a class="self-link" href="#message-receipt"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> MessageReceipt <c- a>struct</c-> <c- p>{</c->
    ExitCode <c- b>uint8</c->

    Return <c- p>[]</c-><c- b>byte</c->

    GasUsed Integer
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.5.1" id="serialization②"><span class="secno">18.5.1. </span><span class="content">Serialization</span><a class="self-link" href="#serialization②"></a></h4>
    <p>Message receipts are currently serialized simply by CBOR marshaling them, using lower-camel-cased field names.</p>
    <h3 class="heading settled" data-level="18.6" id="actor"><span class="secno">18.6. </span><span class="content">Actor</span><a class="self-link" href="#actor"></a></h3>
<pre class="language-go highlight"><c- a>type</c-> Actor <c- a>struct</c-> <c- p>{</c->
    <c- c1>// Code is a pointer to the code object for this actor</c->
	Code    Cid

    <c- c1>// Head is a pointer to the root of this actors state</c->
    Head    Cid

    <c- c1>// Nonce is a counter of the number of messages this actor has sent</c->
    Nonce   Integer

    <c- c1>// Balance is this actors current balance of filecoin</c->
    Balance AttoFIL
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.6.1" id="serialization③"><span class="secno">18.6.1. </span><span class="content">Serialization</span><a class="self-link" href="#serialization③"></a></h4>
    <p>Actors are currently serialized simply by CBOR marshaling them, using lower-camel-cased field names.</p>
    <h3 class="heading settled" data-level="18.7" id="state-tree"><span class="secno">18.7. </span><span class="content">State Tree</span><a class="self-link" href="#state-tree"></a></h3>
    <p>The state trie keeps track of all state in Filecoin. It is a map of addresses to <code>actors</code> in the system. It is implemented using a HAMT.</p>
    <h3 class="heading settled" data-level="18.8" id="hamt"><span class="secno">18.8. </span><span class="content">HAMT</span><a class="self-link" href="#hamt"></a></h3>
    <p>TODO: link to spec for our CHAMP HAMT</p>
    <h3 class="heading settled" data-level="18.9" id="basic-type-encodings"><span class="secno">18.9. </span><span class="content">Basic Type Encodings</span><a class="self-link" href="#basic-type-encodings"></a></h3>
    <p>Types that appear in messages or in state must be encoded as described here.</p>
    <h4 class="heading settled" data-level="18.9.1" id="publickey"><span class="secno">18.9.1. </span><span class="content"><code>PublicKey</code></span><a class="self-link" href="#publickey"></a></h4>
    <p>The public key type is simply an array of bytes. (TODO: discuss specific encoding of key types, for now just calling it bytes is sufficient)</p>
    <h4 class="heading settled" data-level="18.9.2" id="bytesamount"><span class="secno">18.9.2. </span><span class="content"><code>BytesAmount</code></span><a class="self-link" href="#bytesamount"></a></h4>
     BytesAmount is just a re-typed Integer. 
    <h4 class="heading settled" data-level="18.9.3" id="peerid"><span class="secno">18.9.3. </span><span class="content"><code>PeerID</code></span><a class="self-link" href="#peerid"></a></h4>
     PeerID is just the serialized bytes of a libp2p peer ID. 
    <p>Spec incomplete, take a look at this PR: https://github.com/libp2p/specs/pull/100</p>
    <h4 class="heading settled" data-level="18.9.4" id="integer"><span class="secno">18.9.4. </span><span class="content"><code>Integer</code></span><a class="self-link" href="#integer"></a></h4>
    <p>Integers are encoded as LEB128 signed integers.</p>
    <h4 class="heading settled" data-level="18.9.5" id="bitfield"><span class="secno">18.9.5. </span><span class="content"><code>BitField</code></span><a class="self-link" href="#bitfield"></a></h4>
    <p>Bitfields are a set of bits. Encoding still TBD, but it needs to be very compact. We can assume that most often, ranges of bits will be set, or not set, and use that to our advantage here. Some form of run length encoding may work well.</p>
    <h4 class="heading settled" data-level="18.9.6" id="sectorset"><span class="secno">18.9.6. </span><span class="content"><code>SectorSet</code></span><a class="self-link" href="#sectorset"></a></h4>
    <p>TODO</p>
    <h4 class="heading settled" data-level="18.9.7" id="faultset"><span class="secno">18.9.7. </span><span class="content"><code>FaultSet</code></span><a class="self-link" href="#faultset"></a></h4>
    <p>A fault set is a BitField and a block height, encoding TBD.</p>
    <h4 class="heading settled" data-level="18.9.8" id="blockheader"><span class="secno">18.9.8. </span><span class="content"><code>BlockHeader</code></span><a class="self-link" href="#blockheader"></a></h4>
    <p>BlockHeader is a serialized <code>Block</code>.</p>
    <h4 class="heading settled" data-level="18.9.9" id="sealproof"><span class="secno">18.9.9. </span><span class="content"><code>SealProof</code></span><a class="self-link" href="#sealproof"></a></h4>
    <p>SealProof is an array of bytes.</p>
    <h4 class="heading settled" data-level="18.9.10" id="tokenamount"><span class="secno">18.9.10. </span><span class="content"><code>TokenAmount</code></span><a class="self-link" href="#tokenamount"></a></h4>
    <p>TokenAmount is a re-typed Integer.</p>
    <h3 class="heading settled" data-level="18.10" id="leb128-encoding-reference"><span class="secno">18.10. </span><span class="content">LEB128 Encoding Reference</span><a class="self-link" href="#leb128-encoding-reference"></a></h3>
    <p>This is taken from the Dwarf Standard 4, Appendix C</p>
    <h4 class="heading settled" data-level="18.10.1" id="encode-unsigned-leb128"><span class="secno">18.10.1. </span><span class="content">Encode unsigned LEB128</span><a class="self-link" href="#encode-unsigned-leb128"></a></h4>
<pre class="language-c highlight"><c- k>do</c->
<c- p>{</c->
  <c- n>byte</c-> <c- o>=</c-> <c- n>low</c-> <c- n>order</c-> <c- mi>7</c-> <c- n>bits</c-> <c- n>of</c-> <c- n>value</c-><c- p>;</c->
  <c- n>value</c-> <c- o>>>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- k>if</c-> <c- p>(</c-><c- n>value</c-> <c- o>!=</c-> <c- mi>0</c-><c- p>)</c-> <c- d>/* more bytes to come */</c->
    <c- n>set</c-> <c- n>high</c-> <c- n>order</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-><c- p>;</c->
  <c- n>emit</c-> <c- n>byte</c-><c- p>;</c->
<c- p>}</c-> <c- k>while</c-> <c- p>(</c-><c- n>value</c-> <c- o>!=</c-> <c- mi>0</c-><c- p>);</c->
</pre>
    <h4 class="heading settled" data-level="18.10.2" id="encode-signed-leb128"><span class="secno">18.10.2. </span><span class="content">Encode signed LEB128</span><a class="self-link" href="#encode-signed-leb128"></a></h4>
<pre class="language-c highlight"><c- n>more</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
<c- n>negative</c-> <c- o>=</c-> <c- p>(</c-><c- n>value</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>);</c->
<c- n>size</c-> <c- o>=</c-> <c- n>no</c-><c- p>.</c-> <c- n>of</c-> <c- n>bits</c-> <c- n>in</c-> <c- b>signed</c-> <c- n>integer</c-><c- p>;</c->
<c- k>while</c-><c- p>(</c-><c- n>more</c-><c- p>)</c->
<c- p>{</c->
  <c- n>byte</c-> <c- o>=</c-> <c- n>low</c-> <c- n>order</c-> <c- mi>7</c-> <c- n>bits</c-> <c- n>of</c-> <c- n>value</c-><c- p>;</c->
  <c- n>value</c-> <c- o>>>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- d>/* the following is unnecessary if the</c->
<c- d>   * implementation of >>= uses an arithmetic rather</c->
<c- d>   * than logical shift for a signed left operand</c->
<c- d>   */</c->
  <c- k>if</c-> <c- p>(</c-><c- n>negative</c-><c- p>)</c->
    <c- d>/* sign extend */</c->
    <c- n>value</c-> <c- o>|=</c-> <c- o>-</c-> <c- p>(</c-><c- mi>1</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>size</c-> <c- o>-</c-> <c- mi>7</c-><c- p>));</c->
    <c- d>/* sign bit of byte is second high order bit (0x40) */</c->
  <c- k>if</c-> <c- p>((</c-><c- n>value</c-> <c- o>==</c->  <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>sign</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-> <c- n>is</c-> <c- n>clear</c-><c- p>)</c-> <c- o>||</c->
      <c- p>(</c-><c- n>value</c-> <c- o>==</c-> <c- o>-</c-><c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>sign</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-> <c- n>is</c-> <c- n>set</c-><c- p>))</c->
     <c- n>more</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
  <c- k>else</c->
    <c- n>set</c-> <c- n>high</c-> <c- n>order</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-><c- p>;</c->
  <c- n>emit</c-> <c- n>byte</c-><c- p>;</c->
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.10.3" id="decode-unsigned-leb128"><span class="secno">18.10.3. </span><span class="content">Decode unsigned LEB128</span><a class="self-link" href="#decode-unsigned-leb128"></a></h4>
<pre class="language-c highlight"><c- n>result</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
<c- n>shift</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
<c- k>while</c-><c- p>(</c->true<c- p>)</c->
<c- p>{</c->
  <c- n>byte</c-> <c- o>=</c-> <c- n>next</c-> <c- n>byte</c-> <c- n>in</c-> <c- n>input</c-><c- p>;</c->
  <c- n>result</c-> <c- o>|=</c-> <c- p>(</c-><c- n>low</c-> <c- n>order</c-> <c- mi>7</c-> <c- n>bits</c-> <c- n>of</c-> <c- n>byte</c-> <c- o>&lt;&lt;</c-> <c- n>shift</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- n>high</c-> <c- n>order</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-> <c- o>==</c-> <c- mi>0</c-><c- p>)</c->
    <c- k>break</c-><c- p>;</c->
  <c- n>shift</c-> <c- o>+=</c-> <c- mi>7</c-><c- p>;</c->
<c- p>}</c->
</pre>
    <h4 class="heading settled" data-level="18.10.4" id="decode-signed-leb128"><span class="secno">18.10.4. </span><span class="content">Decode signed LEB128</span><a class="self-link" href="#decode-signed-leb128"></a></h4>
<pre class="language-c highlight"><c- n>result</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
<c- n>shift</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
<c- n>size</c-> <c- o>=</c-> <c- n>number</c-> <c- n>of</c-> <c- n>bits</c-> <c- n>in</c-> <c- b>signed</c-> <c- n>integer</c-><c- p>;</c->
<c- k>while</c-><c- p>(</c->true<c- p>)</c->
<c- p>{</c->
  <c- n>byte</c-> <c- o>=</c-> <c- n>next</c-> <c- n>byte</c-> <c- n>in</c-> <c- n>input</c-><c- p>;</c->
  <c- n>result</c-> <c- o>|=</c-> <c- p>(</c-><c- n>low</c-> <c- n>order</c-> <c- mi>7</c-> <c- n>bits</c-> <c- n>of</c-> <c- n>byte</c-> <c- o>&lt;&lt;</c-> <c- n>shift</c-><c- p>);</c->
  <c- n>shift</c-> <c- o>+=</c-> <c- mi>7</c-><c- p>;</c->
  <c- d>/* sign bit of byte is second high order bit (0x40) */</c->
  <c- k>if</c-> <c- p>(</c-><c- n>high</c-> <c- n>order</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-> <c- o>==</c-> <c- mi>0</c-><c- p>)</c->
  <c- k>break</c-><c- p>;</c->
<c- p>}</c->
<c- k>if</c-> <c- p>((</c-><c- n>shift</c-> <c- o>&lt;</c-><c- n>size</c-><c- p>)</c-> <c- o>&amp;&amp;</c-> <c- p>(</c-><c- n>sign</c-> <c- n>bit</c-> <c- n>of</c-> <c- n>byte</c-> <c- n>is</c-> <c- n>set</c-><c- p>))</c->
  <c- d>/* sign extend */</c->
  <c- n>result</c-> <c- o>|=</c-> <c- o>-</c-> <c- p>(</c-><c- mi>1</c-> <c- o>&lt;&lt;</c-> <c- n>shift</c-><c- p>);</c->
</pre>
    <h2 class="heading settled" data-level="19" id="filecoin-node-local-storage"><span class="secno">19. </span><span class="content">Filecoin Node Local Storage</span><a class="self-link" href="#filecoin-node-local-storage"></a></h2>
    <p>A Filecoin node stores certain data locally. This section details what exactly gets stored (though exactly <em>how</em> things are stored is not dictated).</p>
    <h3 class="heading settled" data-level="19.1" id="chain-data"><span class="secno">19.1. </span><span class="content">Chain Data</span><a class="self-link" href="#chain-data"></a></h3>
    <h3 class="heading settled" data-level="19.2" id="private-keys"><span class="secno">19.2. </span><span class="content">Private Keys</span><a class="self-link" href="#private-keys"></a></h3>
    <h3 class="heading settled" data-level="19.3" id="sectors"><span class="secno">19.3. </span><span class="content">Sectors</span><a class="self-link" href="#sectors"></a></h3>
    <h3 class="heading settled" data-level="19.4" id="storage-deals"><span class="secno">19.4. </span><span class="content">Storage Deals</span><a class="self-link" href="#storage-deals"></a></h3>
    <p>​</p>
    <h2 class="heading settled" data-level="20" id="glossary"><span class="secno">20. </span><span class="content">Glossary</span><a class="self-link" href="#glossary"></a></h2>
    <h3 class="heading settled" data-level="20.1" id="updates-to-definitions"><span class="secno">20.1. </span><span class="content">Updates to definitions</span><a class="self-link" href="#updates-to-definitions"></a></h3>
    <p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p>
    <h3 class="heading settled" data-level="20.2" id="notes"><span class="secno">20.2. </span><span class="content">Notes</span><a class="self-link" href="#notes"></a></h3>
    <ul>
     <li data-md>
      <p>Want to split all repair stuff to separate doc</p>
     <li data-md>
      <p>Let’s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</p>
     <li data-md>
      <p>Asterisks indicate that the definition requires updating by any affected party.</p>
    </ul>
    <h3 class="heading settled" data-level="20.3" id="definitions"><span class="secno">20.3. </span><span class="content">Definitions</span><a class="self-link" href="#definitions"></a></h3>
    <h4 class="heading settled" data-level="20.3.1" id="actor①"><span class="secno">20.3.1. </span><span class="content">Actor</span><a class="self-link" href="#actor①"></a></h4>
    <p>An actor is an on-chain object with its own state and set of methods. An actors state is persisted on-chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p>
    <p>Actors are very similar to smart contracts in Ethereum.</p>
    <h4 class="heading settled" data-level="20.3.2" id="address①"><span class="secno">20.3.2. </span><span class="content">Address</span><a class="self-link" href="#address①"></a></h4>
    <p>An address is an identifier that refers to an actor in the Filecoin state.</p>
    <h4 class="heading settled" data-level="20.3.3" id="ask"><span class="secno">20.3.3. </span><span class="content">Ask</span><a class="self-link" href="#ask"></a></h4>
    <h4 class="heading settled" data-level="20.3.4" id="bid"><span class="secno">20.3.4. </span><span class="content">Bid</span><a class="self-link" href="#bid"></a></h4>
    <h4 class="heading settled" data-level="20.3.5" id="block①"><span class="secno">20.3.5. </span><span class="content">Block</span><a class="self-link" href="#block①"></a></h4>
    <p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p>
    <p>See [Data Structures]()</p>
    <h4 class="heading settled" data-level="20.3.6" id="bootstrapping"><span class="secno">20.3.6. </span><span class="content">Bootstrapping</span><a class="self-link" href="#bootstrapping"></a></h4>
    <h4 class="heading settled" data-level="20.3.7" id="chain-weight"><span class="secno">20.3.7. </span><span class="content">Chain weight</span><a class="self-link" href="#chain-weight"></a></h4>
    <h4 class="heading settled" data-level="20.3.8" id="challenge-sampling"><span class="secno">20.3.8. </span><span class="content">Challenge sampling</span><a class="self-link" href="#challenge-sampling"></a></h4>
    <h4 class="heading settled" data-level="20.3.9" id="cid①"><span class="secno">20.3.9. </span><span class="content">Cid</span><a class="self-link" href="#cid①"></a></h4>
    <p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>
    <h4 class="heading settled" data-level="20.3.10" id="client"><span class="secno">20.3.10. </span><span class="content">Client</span><a class="self-link" href="#client"></a></h4>
    <p>A client is any user with an account who wishes to store data with a miner. A client’s account is used to pay for the storage, and helps to prove the clients ability to pay.</p>
    <h4 class="heading settled" data-level="20.3.11" id="collateral"><span class="secno">20.3.11. </span><span class="content">Collateral</span><a class="self-link" href="#collateral"></a></h4>
    <p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p>
    <ul>
     <li data-md>
      <p>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</p>
     <li data-md>
      <p>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</p>
    </ul>
    <h4 class="heading settled" data-level="20.3.12" id="commitment"><span class="secno">20.3.12. </span><span class="content">Commitment</span><a class="self-link" href="#commitment"></a></h4>
    <p>See <a href="proofs.md">Filecoin Proofs</a></p>
    <h4 class="heading settled" data-level="20.3.13" id="confirmation"><span class="secno">20.3.13. </span><span class="content">Confirmation</span><a class="self-link" href="#confirmation"></a></h4>
    <h4 class="heading settled" data-level="20.3.14" id="consensus"><span class="secno">20.3.14. </span><span class="content">Consensus</span><a class="self-link" href="#consensus"></a></h4>
    <h4 class="heading settled" data-level="20.3.15" id="deal①"><span class="secno">20.3.15. </span><span class="content">Deal</span><a class="self-link" href="#deal①"></a></h4>
    <p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p>
    <h4 class="heading settled" data-level="20.3.16" id="erasure-coding"><span class="secno">20.3.16. </span><span class="content">Erasure coding</span><a class="self-link" href="#erasure-coding"></a></h4>
    <p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p>
    <p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p>
    <h4 class="heading settled" data-level="20.3.17" id="epoch"><span class="secno">20.3.17. </span><span class="content">Epoch</span><a class="self-link" href="#epoch"></a></h4>
    <p>An epoch refers to the period over which a given random seed is used in Expected Consensus. In the current Filecoin implementation, each round is an epoch.</p>
    <h4 class="heading settled" data-level="20.3.18" id="fault"><span class="secno">20.3.18. </span><span class="content">Fault</span><a class="self-link" href="#fault"></a></h4>
    <p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p>
    <h4 class="heading settled" data-level="20.3.19" id="fair"><span class="secno">20.3.19. </span><span class="content">Fair</span><a class="self-link" href="#fair"></a></h4>
    <h4 class="heading settled" data-level="20.3.20" id="file"><span class="secno">20.3.20. </span><span class="content">File</span><a class="self-link" href="#file"></a></h4>
    <p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p>
    <h4 class="heading settled" data-level="20.3.21" id="finality"><span class="secno">20.3.21. </span><span class="content">Finality</span><a class="self-link" href="#finality"></a></h4>
    <h4 class="heading settled" data-level="20.3.22" id="piece-inclusion-proof①"><span class="secno">20.3.22. </span><span class="content">Piece Inclusion Proof</span><a class="self-link" href="#piece-inclusion-proof①"></a></h4>
    <p>See <a href="proofs.md">Filecoin Proofs</a></p>
    <h4 class="heading settled" data-level="20.3.23" id="gas-fees-prices"><span class="secno">20.3.23. </span><span class="content">Gas, Fees, Prices</span><a class="self-link" href="#gas-fees-prices"></a></h4>
    <h4 class="heading settled" data-level="20.3.24" id="ghost"><span class="secno">20.3.24. </span><span class="content">GHOST</span><a class="self-link" href="#ghost"></a></h4>
    <h4 class="heading settled" data-level="20.3.25" id="leader"><span class="secno">20.3.25. </span><span class="content">Leader</span><a class="self-link" href="#leader"></a></h4>
    <p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p>
    <h4 class="heading settled" data-level="20.3.26" id="leader-election"><span class="secno">20.3.26. </span><span class="content">Leader election</span><a class="self-link" href="#leader-election"></a></h4>
    <p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p>
    <h4 class="heading settled" data-level="20.3.27" id="message①"><span class="secno">20.3.27. </span><span class="content">Message</span><a class="self-link" href="#message①"></a></h4>
    <p>A message is a call to an actor in the Filecoin VM.</p>
    <h4 class="heading settled" data-level="20.3.28" id="miner"><span class="secno">20.3.28. </span><span class="content">Miner</span><a class="self-link" href="#miner"></a></h4>
    <p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p>
    <p>There are multiple types of miners in Filecoin:</p>
    <ul>
     <li data-md>
      <p>Storage miners - storage miners</p>
     <li data-md>
      <p>Retrieval miners:</p>
     <li data-md>
      <p>Repair miners (to be split out):</p>
    </ul>
    <h4 class="heading settled" data-level="20.3.29" id="node"><span class="secno">20.3.29. </span><span class="content">Node</span><a class="self-link" href="#node"></a></h4>
    <p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p>
    <h4 class="heading settled" data-level="20.3.30" id="null-blocks"><span class="secno">20.3.30. </span><span class="content">Null Blocks</span><a class="self-link" href="#null-blocks"></a></h4>
    <p>A null block refers to a block with no content mined by default during an epoch in which no miner is elected leader.</p>
    <h4 class="heading settled" data-level="20.3.31" id="on-chain-off-chain"><span class="secno">20.3.31. </span><span class="content">On-chain/off-chain</span><a class="self-link" href="#on-chain-off-chain"></a></h4>
    <h4 class="heading settled" data-level="20.3.32" id="online-offline"><span class="secno">20.3.32. </span><span class="content">Online/offline</span><a class="self-link" href="#online-offline"></a></h4>
    <h4 class="heading settled" data-level="20.3.33" id="payment-channel"><span class="secno">20.3.33. </span><span class="content">Payment Channel</span><a class="self-link" href="#payment-channel"></a></h4>
    <p>A payment channel is set up between actors in the Filecoin system to enable off-chain payments with on-chain guarantees, making settlement more efficient.</p>
    <h4 class="heading settled" data-level="20.3.34" id="piece"><span class="secno">20.3.34. </span><span class="content">Piece</span><a class="self-link" href="#piece"></a></h4>
    <p>A piece is a portion of a file that gets fitted into a sector.</p>
    <h4 class="heading settled" data-level="20.3.35" id="pledge"><span class="secno">20.3.35. </span><span class="content">Pledge</span><a class="self-link" href="#pledge"></a></h4>
    <p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p>
    <h4 class="heading settled" data-level="20.3.36" id="power-table"><span class="secno">20.3.36. </span><span class="content">Power table</span><a class="self-link" href="#power-table"></a></h4>
    <p>The power table is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p>
    <h4 class="heading settled" data-level="20.3.37" id="protocol"><span class="secno">20.3.37. </span><span class="content">Protocol</span><a class="self-link" href="#protocol"></a></h4>
    <h4 class="heading settled" data-level="20.3.38" id="proving-period"><span class="secno">20.3.38. </span><span class="content">Proving Period</span><a class="self-link" href="#proving-period"></a></h4>
    <p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt.</p>
    <h4 class="heading settled" data-level="20.3.39" id="proving-set"><span class="secno">20.3.39. </span><span class="content">Proving Set</span><a class="self-link" href="#proving-set"></a></h4>
    <p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p>
    <p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p>
    <h4 class="heading settled" data-level="20.3.40" id="proof-of-replication①"><span class="secno">20.3.40. </span><span class="content">Proof of Replication</span><a class="self-link" href="#proof-of-replication①"></a></h4>
    <p>Proof that a unique encoding of data exists in physical storage.</p>
    <p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p>
    <h4 class="heading settled" data-level="20.3.41" id="proof-of-spacetime"><span class="secno">20.3.41. </span><span class="content">Proof of Spacetime</span><a class="self-link" href="#proof-of-spacetime"></a></h4>
    <p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p>
    <p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p>
    <h4 class="heading settled" data-level="20.3.42" id="random-ness"><span class="secno">20.3.42. </span><span class="content">Random(ness)</span><a class="self-link" href="#random-ness"></a></h4>
    <p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p>
    <p>TODO add a note to distinguish predictability from randomness</p>
    <h4 class="heading settled" data-level="20.3.43" id="repair"><span class="secno">20.3.43. </span><span class="content">Repair</span><a class="self-link" href="#repair"></a></h4>
    <p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re-constructed and re-added to the network.</p>
    <h4 class="heading settled" data-level="20.3.44" id="round"><span class="secno">20.3.44. </span><span class="content">Round</span><a class="self-link" href="#round"></a></h4>
    <p>A round refers to the period over which a new leader election occurs and a block is generated if a leader is found. Typically this means a new block will be mined at every round, though some rounds may see 0 or multiple blocks generated.</p>
    <h4 class="heading settled" data-level="20.3.45" id="seal-unseal"><span class="secno">20.3.45. </span><span class="content">SEAL/UNSEAL</span><a class="self-link" href="#seal-unseal"></a></h4>
    <p>See <a href="proofs.md">Filecoin Proofs</a></p>
    <h4 class="heading settled" data-level="20.3.46" id="sector"><span class="secno">20.3.46. </span><span class="content">Sector</span><a class="self-link" href="#sector"></a></h4>
    <p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p>
    <h4 class="heading settled" data-level="20.3.47" id="slashing①"><span class="secno">20.3.47. </span><span class="content">Slashing</span><a class="self-link" href="#slashing①"></a></h4>
    <h4 class="heading settled" data-level="20.3.48" id="smart-contracts"><span class="secno">20.3.48. </span><span class="content">Smart contracts</span><a class="self-link" href="#smart-contracts"></a></h4>
    <h4 class="heading settled" data-level="20.3.49" id="storage②"><span class="secno">20.3.49. </span><span class="content">Storage</span><a class="self-link" href="#storage②"></a></h4>
    <p>Storage widely refers to a place in which to store data in a given system.</p>
    <p>In the context of:</p>
    <ul>
     <li data-md>
      <p>The Filecoin miner: sotrage refers to disk sectors made available to the network.</p>
     <li data-md>
      <p>The Filecoin chain: storage refers to the way in which system state is tracked through time on-chain through blocks.</p>
     <li data-md>
      <p>Actor: the struct that defines an actor.</p>
    </ul>
    <h4 class="heading settled" data-level="20.3.50" id="state"><span class="secno">20.3.50. </span><span class="content">State</span><a class="self-link" href="#state"></a></h4>
    <p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p>
    <h4 class="heading settled" data-level="20.3.51" id="ticket"><span class="secno">20.3.51. </span><span class="content">Ticket</span><a class="self-link" href="#ticket"></a></h4>
    <p>Some unpredictable element generated by the system for two uses:</p>
    <ul>
     <li data-md>
      <p>as a random challenge to PoSTs.</p>
     <li data-md>
      <p>to elect a leader in Expected Consensus.</p>
    </ul>
    <p>See more on <a href="expected-consensus.md">Expected Consensus</a> and <a href="proofs.md">PoSTs</a>.</p>
    <h4 class="heading settled" data-level="20.3.52" id="tip-set"><span class="secno">20.3.52. </span><span class="content">Tip Set</span><a class="self-link" href="#tip-set"></a></h4>
    <p>A collection of blocks mined by different miners, each an elected leader of a given epoch. All tip sets have the same parent-set and epoch number (height). TODO add picture.</p>
    <h4 class="heading settled" data-level="20.3.53" id="verifiable"><span class="secno">20.3.53. </span><span class="content">Verifiable</span><a class="self-link" href="#verifiable"></a></h4>
    <p>Something that is verifiable can be checked for correctness by a third party.</p>
    <h4 class="heading settled" data-level="20.3.54" id="vm"><span class="secno">20.3.54. </span><span class="content">VM</span><a class="self-link" href="#vm"></a></h4>
    <p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system’s state. The VM takes messages as input, and outputs state.</p>
    <h4 class="heading settled" data-level="20.3.55" id="voucher"><span class="secno">20.3.55. </span><span class="content">Voucher</span><a class="self-link" href="#voucher"></a></h4>
    <p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p>
    <h4 class="heading settled" data-level="20.3.56" id="zksnark"><span class="secno">20.3.56. </span><span class="content">zkSNARK</span><a class="self-link" href="#zksnark"></a></h4>
    <p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small 'proof' that convinces a 'verifier' that some computation was done correctly.</p>
   </httpsU0003A>
  </main>
  <div data-fill-with="conformance">
   <h2 class="no-ref no-num heading settled" id="conformance"><span class="content"> Conformance</span><a class="self-link" href="#conformance"></a></h2>
   <p> Conformance requirements are expressed with a combination of descriptive assertions and RFC 2119 terminology.
            The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”
            in the normative parts of this document
            are to be interpreted as described in RFC 2119.
            However, for readability,
            these words do not appear in all uppercase letters in this specification. </p>
   <p> All of the text of this specification is normative
            except sections explicitly marked as non-normative, examples, and notes. <a data-link-type="biblio" href="#biblio-rfc2119">[RFC2119]</a> </p>
   <p> Examples in this specification are introduced with the words “for example”
            or are set apart from the normative text with <code>class="example"</code>, like this: </p>
   <div class="example" id="example-example"><a class="self-link" href="#example-example"></a> This is an example of an informative example. </div>
   <p> Informative notes begin with the word “Note”
            and are set apart from the normative text with <code>class="note"</code>, like this: </p>
   <p class="note" role="note"> Note, this is an informative note. </p>
  </div>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references①"><span class="content">References</span><a class="self-link" href="#references①"></a></h2>
  <h3 class="no-num no-ref heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
  <dl>
   <dt id="biblio-rfc2119">[RFC2119]
   <dd>S. Bradner. <a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>
  </dl>