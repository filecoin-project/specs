<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Data Structures
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f data-structures\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/proofs/">Proofs</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><strong>Proofs</strong></p>

<ul>
<li><a href="../../docs/zigzag-circuit/">ZigZag</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Data Structures
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="data-structures">Data Structures</h1>

<p>In this document, we give an introduction to each of the protocol data structures and then explain how to encode these data structures for use in other parts of Filecoin (e.g. network protocols and the blockchain).</p>

<h2 id="address">Address</h2>

<p>An address is an identifier that refers to an actor in the Filecoin state. All <a href="../actors">actors</a> (miner actors, the storage market actor, account actors) have an address. An address encodes information about:
- Network this address belongs to
- Type of data the address contains
- The data itself
- Checksum (depending on the type of address)</p>

<p>To learn more, take a look at the <a href="../address">address spec</a>.
For more detail about the different types of addresses and how they are structured and used, take a look at the <a href="../address">address spec</a>.</p>

<h2 id="block">Block</h2>

<p>A block header contains information relevant to a particular point in time over which the network may achieve consensus. The block header contains:</p>

<ul>
<li>The address of the miner that mined the block</li>
<li>An array of the tickets that led to this particular miner being selected as the leader for this round (see the <a href="../expected-consensus#secret-leader-election">Secret Leader Election portion of the Expected Consensus spec</a> for more) and a signature on the winning ticket</li>
<li>The set of parent blocks and aggregate <a href="../expected-consensus#chain-weighting">chain weight</a> of the parents</li>
<li>This block&rsquo;s height</li>
<li>Merkle root of the state tree (after applying the messages &ndash; state transitions &ndash; included in this block)</li>
<li>Merkle root of the messages (state transitions) in this block</li>
<li>Merkle root of the message receipts in this block</li>
<li>Timestamp</li>
</ul>

<div class="notices note" ><strong>Note:</strong> A block is functionally the same as a block header in the Filecoin protocol. While a block header contains Merkle links to the full system state, messages, and message receipts, a block can be thought of as the full set of this information (not just the Merkle roots, but rather the full data of the state tree, message tree, receipts tree, etc.). Because a full block is quite large, our chain consists of block headers rather than full blocks. We often use the terms <code>block</code> and <code>block header</code> interchangeably.</div>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockHeader struct <span class="o">{</span>
    <span class="c1">## Miner is the address of the miner actor that mined this block.</span>
    miner Address

    <span class="c1">## Tickets is a chain (possibly singleton) of tickets ending with a winning ticket submitted with this block.</span>
    tickets <span class="o">[</span>Ticket<span class="o">]</span>

    <span class="c1">## ElectionProof is a signature over the final ticket that proves this miner</span>
    <span class="c1">## is the leader at this round</span>
    electionProof Signature

    <span class="c1">## Parents is an array of distinct CIDs of parents on which this block was based.</span>
    <span class="c1">## Typically one, but can be several in the case where there were multiple winning ticket-</span>
    <span class="c1">## holders for a round.</span>
    <span class="c1">## The order of parent CIDs is not defined.</span>
    parents <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>

    <span class="c1">## ParentWeight is the aggregate chain weight of the parent set.</span>
    parentWeight UInt

    <span class="c1">## Height is the chain height of this block.</span>
    height UInt

    <span class="c1">## StateRoot is a cid pointer to the state tree after application of the</span>
    <span class="c1">## transactions state transitions.</span>
    stateRoot <span class="p">&amp;</span>StateTree

    <span class="c1">## Messages is the set of messages included in this block. This field is the Cid</span>
    <span class="c1">## of the root of a sharray of Messages.</span>
    messages <span class="p">&amp;</span><span class="o">[</span><span class="p">&amp;</span>Message<span class="o">]</span>&lt;Sharray&gt;

    <span class="c1">## BLSAggregate is an aggregated BLS signature for all the messages in this block that</span>
    <span class="c1">## were signed using BLS signatures</span>
    blsAggregate Signature

    <span class="c1">## MessageReceipts is a set of receipts matching to the sending of the `Messages`.</span>
    <span class="c1">## This field is the Cid of the root of a sharray of MessageReceipts.</span>
    messageReceipts <span class="p">&amp;</span><span class="o">[</span>MessageReceipt<span class="o">]</span>

    <span class="c1">## The block Timestamp is used to enforce a form of block delay by honest miners.</span>
    <span class="c1">## Unix time UTC timestamp (in seconds) stored as an unsigned integer.</span>
    timestamp Timestamp

    <span class="c1">## BlockSig is a signature over the hash of the entire block with the miners</span>
    <span class="c1">## worker key to ensure that it is not tampered with after creation</span>
    blockSig Signature
<span class="o">}</span> representation tuple</code></pre></div>
<h2 id="message">Message</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Message union <span class="o">{</span>
    <span class="p">|</span> UnsignedMessage <span class="m">0</span>
    <span class="p">|</span> SignedMessage <span class="m">1</span>
<span class="o">}</span> representation keyed</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UnsignedMessage struct <span class="o">{</span>
    to   Address
    from Address

    <span class="c1">## When receiving a message from a user account the nonce in the message must match the expected</span>
    <span class="c1">## nonce in the from actor. This prevents replay attacks.</span>
    nonce UInt

    value UInt

    gasPrice UInt
    gasLimit UInt

    method <span class="p">&amp;</span>ActorMethod
<span class="o">}</span> representation tuple</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SignedMessage struct <span class="o">{</span>
    message   UnsignedMessage
    signature Signature
<span class="o">}</span> representation tuple</code></pre></div>
<p>The signature is a serialized signature over the serialized base message. For more details on how the signature itself is done, see the <a href="../signatures">signatures spec</a>.</p>

<h2 id="state-tree">State Tree</h2>

<p>The state tree keeps track of all state in Filecoin. It is a map of addresses to <code>actors</code> in the system.
The <code>ActorState</code> is defined in the <a href="../actors">actors spec</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StateTree map <span class="o">{</span>ID:Actor<span class="o">}</span>&lt;Hamt&gt;</code></pre></div>
<h2 id="message-receipt">Message Receipt</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MessageReceipt struct <span class="o">{</span>
    exitCode UInt
    <span class="k">return</span> Bytes
    gasUsed UInt
<span class="o">}</span> representation tuple</code></pre></div>
<h2 id="actor">Actor</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Actor struct <span class="o">{</span>
    <span class="c1">## Cid of the code object for this actor.</span>
    code Cid

    <span class="c1">## Reference to the root of this actors state.</span>
    head <span class="p">&amp;</span>ActorState

    <span class="c1">## Counter of the number of messages this actor has sent.</span>
    nonce UInt

    <span class="c1">## Current balance of filecoin of this actor.</span>
    balance UInt
<span class="o">}</span></code></pre></div>
<h2 id="signature">Signature</h2>

<p>All signatures in Filecoin come with a type that signifies which key type was used to create the signature.</p>

<p>For more details on signature creation, see <a href="../signatures">the signatures spec</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Signature union <span class="o">{</span>
    <span class="p">|</span> Secp256k1Signature <span class="m">0</span>
    <span class="p">|</span> Bls12_381Signature <span class="m">1</span>
<span class="o">}</span> representation byteprefix

<span class="nb">type</span> Secp256k1Signature Bytes
<span class="nb">type</span> Bls12_381Signature Bytes</code></pre></div>
<h2 id="faultset">FaultSet</h2>

<p>FaultSets are used to denote which sectors failed at which block height.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> FaultSet struct <span class="o">{</span>
    index    UInt
    bitField BitField
<span class="o">}</span></code></pre></div>
<p>The <code>index</code> field is a block height offset from the start of the miners proving period (in order to make it more compact).</p>

<h2 id="basic-types">Basic Types</h2>

<h3 id="cid">CID</h3>

<p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used. This is effectively a hash value, prefixed with its hash function (multihash) prepended with a extra labels to inform applications about how to deserialize the given data. <a href="https://github.com/ipld/cid">CID Spec</a> contains the detailed spec.</p>

<h3 id="timestamp">Timestamp</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Timestamp UInt</code></pre></div>
<h3 id="publickey">PublicKey</h3>

<p>The public key type is simply an array of bytes.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PublicKey Bytes</code></pre></div>
<h3 id="bytesamount">BytesAmount</h3>

<p>BytesAmount is just a re-typed Integer.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BytesAmount UInt</code></pre></div>
<h3 id="peerid">PeerId</h3>

<p>The serialized bytes of a libp2p peer ID.</p>

<p>Spec incomplete, take a look at this PR: <a href="https://github.com/libp2p/specs/pull/100">https://github.com/libp2p/specs/pull/100</a></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PeerId Bytes</code></pre></div>
<h3 id="bitfield">Bitfield</h3>

<p>Bitfields are a set encoded using a custom run length encoding: RLE+.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Bitfield Bytes</code></pre></div>
<h3 id="sectorset">SectorSet</h3>

<div class="notices todo" >Define me</div>

<h3 id="sealproof">SealProof</h3>

<p>SealProof is an opaque, dynamically-sized array of bytes.</p>

<h3 id="postproof">PoStProof</h3>

<p>PoStProof is an opaque, dynamically-sized array of bytes.</p>

<h3 id="tokenamount">TokenAmount</h3>

<p>A type to represent an amount of filecoin tokens.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> TokenAmount UInt</code></pre></div>
<h2 id="rle-bitset-encoding">RLE+ Bitset Encoding</h2>

<p>RLE+ is a lossless compression format based on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>.
It&rsquo;s primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly,
while keeping the same level of compression for large sets of contiugous bits.</p>

<p>In tests it has shown to be more compact than RLE iteself, as well as <a href="https://arxiv.org/pdf/1004.0403.pdf">Concise</a> and <a href="https://roaringbitmap.org/">Roaring</a>.</p>

<h3 id="format">Format</h3>

<p>The format consists of a header, followed by a series of blocks, of which there are three different types.</p>

<p>The format can be expressed as the following <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> grammar.</p>

<pre><code>    &lt;encoding&gt; ::= &lt;header&gt; &lt;blocks&gt;
      &lt;header&gt; ::= &lt;version&gt; &lt;bit&gt;
     &lt;version&gt; ::= &quot;00&quot;
      &lt;blocks&gt; ::= &lt;block&gt; &lt;blocks&gt; | &quot;&quot;
       &lt;block&gt; ::= &lt;block_single&gt; | &lt;block_short&gt; | &lt;block_long&gt;
&lt;block_single&gt; ::= &quot;1&quot;
 &lt;block_short&gt; ::= &quot;01&quot; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
  &lt;block_long&gt; ::= &quot;00&quot; &lt;unsigned_varint&gt;
         &lt;bit&gt; ::= &quot;0&quot; | &quot;1&quot;
</code></pre>

<p>An <code>&lt;unsigned_varint&gt;</code> is defined as specified <a href="https://github.com/multiformats/unsigned-varint">here</a>.</p>

<h4 id="header">Header</h4>

<p>The header indiciates the very first bit of the bit vector to encode. This means the first bit is always
the same for the encoded and non encoded form.</p>

<h4 id="blocks">Blocks</h4>

<p>The blocks represent how many bits, of the current bit type there are. As <code>0</code> and <code>1</code> alternate in a bit vector
the inital bit, which is stored in the header, is enough to determine if a length is currently referencing
a set of <code>0</code>s, or <code>1</code>s.</p>

<h5 id="block-single">Block Single</h5>

<p>If the running length of the current bit is only <code>1</code>, it is encoded as a single set bit.</p>

<h5 id="block-short">Block Short</h5>

<p>If the running length is less than <code>16</code>, it can be encoded into up to four bits, which a short block
represents. The length is encoded into a 4 bits, and prefixed with <code>01</code>, to indicate a short block.</p>

<h5 id="block-long">Block Long</h5>

<p>If the running length is <code>16</code> or larger, it is encoded into a varint, and then prefixed with <code>00</code> to indicate
a long block.</p>

<blockquote>
<p><strong>Note:</strong> The encoding is unique, so no matter which algorithm for encoding is used, it should produce
the same encoding, given the same input.</p>
</blockquote>

<h5 id="bit-numbering">Bit Numbering</h5>

<p>For Filecoin, byte arrays representing RLE+ bitstreams are encoded using <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0</a> bit numbering.</p>

<h2 id="other-considerations">Other Considerations</h2>

<ul>
<li>The maximum size of an Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</li>
<li>Hashes should use a blake2b-256 multihash.</li>
</ul>

</article>

      
<div class="align-center book-git-footer justify-between">
  
  <div>
    
    <a href="https://github.com/filecoin-project/specs/commit/9dcf16da57ae5577304bbf442808d35563add0aa" title='Last modified May 11, 2019 by dignifiedquire' target="_blank" rel="noopener">
      <img src="../../svg/code-merge.svg" alt="Changed" /> May 11, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/data-structures.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#data-structures">Data Structures</a>
<ul>
<li><a href="#address">Address</a></li>
<li><a href="#block">Block</a></li>
<li><a href="#message">Message</a></li>
<li><a href="#state-tree">State Tree</a></li>
<li><a href="#message-receipt">Message Receipt</a></li>
<li><a href="#actor">Actor</a></li>
<li><a href="#signature">Signature</a></li>
<li><a href="#faultset">FaultSet</a></li>
<li><a href="#basic-types">Basic Types</a>
<ul>
<li><a href="#cid">CID</a></li>
<li><a href="#timestamp">Timestamp</a></li>
<li><a href="#publickey">PublicKey</a></li>
<li><a href="#bytesamount">BytesAmount</a></li>
<li><a href="#peerid">PeerId</a></li>
<li><a href="#bitfield">Bitfield</a></li>
<li><a href="#sectorset">SectorSet</a></li>
<li><a href="#sealproof">SealProof</a></li>
<li><a href="#postproof">PoStProof</a></li>
<li><a href="#tokenamount">TokenAmount</a></li>
</ul></li>
<li><a href="#rle-bitset-encoding">RLE+ Bitset Encoding</a>
<ul>
<li><a href="#format">Format</a>
<ul>
<li><a href="#header">Header</a></li>
<li><a href="#blocks">Blocks</a>
<ul>
<li><a href="#block-single">Block Single</a></li>
<li><a href="#block-short">Block Short</a></li>
<li><a href="#block-long">Block Long</a></li>
<li><a href="#bit-numbering">Bit Numbering</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#other-considerations">Other Considerations</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
