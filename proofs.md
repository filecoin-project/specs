# Filecoin Proofs

The Filecoin protocol requires a means of generating and verifying the following cryptographic proofs:

- __*Proof of Replication*__ proves that a unique copy of a given __*sector*__ has been created. The `Seal` operation creates this unique copy and generates a corresponding __*Proof of Replication*__. 
- __*Proof of Space-Time*__ proves that an arbitrary number of __*sealed sectors*__ existed over a specified period of time in their own dedicated storage — as opposed to being generated on-the-fly at proof time.
- __*Piece Inclusion Proof*__ proves that a given __*piece*__ is contained within a specified __*sealed sector*__.
- __*Proof of Retrievability*__ is a merkle proof that a given challenged leaf is present in an extant __*sealed 
sector*__.

Throughout this document, the following definitions are used:

 - __*sector:*__ a fixed-size block of data of `SECTOR_SIZE` bytes.
  - __*piece:*__ a block of data of at most `SECTOR_SIZE` bytes.
 - __*original data:*__ the concatenation of a __*sector's*__ constitutent pieces, all __*piece padding*__, and any __*terminal padding*__.
 - __*unsealed sector:*__ a concrete representation (on disk or in memory) of a sector's __*original data*__. 
 - __*sealed sector:*__ a concrete representation (on disk or in memory) of the unique replica generated by `Seal` from an __*unsealed sector*__. 
 - __*piece padding:*__ a block of zero or more 'zero bytes' inserted between __*pieces*__ to ensure they are positioned within the containing __*sector*__ in a way compatible with the __*Piece Inclusion Proof*__.
 - __*terminal padding:*__ a block of zero or more 'zero bytes' inserted after a __*sector's*__ final piece, ensuring that the length of the __*original data*__ is `SECTOR_BYTES`.
 - __*preprocessing:*__ a transformation applied to an __*unsealed sector*__ as the first stage of sealing and which may increase the size of the data.
 - __*preprocessed data:*__ the result of __*preprocessing*__ the __*original data*__.
 - __*preprocessed sector:*__ a concrete representation (on disk or in memory) of a __*sector's*__ __*preprocessed data*__.
 - __*SNARK proof:*__ a block of bytes which proves that the creator is in possession of a satisfying assignment to a quadratic arithmetic program (__*circuit*__).
 - __*merkle inclusion proof:*__ a proof (whose format is unspecified here) that a given leaf block is contained within a merkle tree whose root is the __*commitment*__ associated with the proof.
 - __*commitment:*__ an opaque block of data to which a prover 'commits', enabling subsequent proofs which cannot be validly constructed unless the __*commitment*__ itself was validly constructed. For example: the output of a suitable pseudorandom collision-resistant hash function may serve as a __*commitment*__ to the data which is the preimage of that hash. Publication of the __*commitment*__ proves that the creator was in possession of the preimage at the time the __*commitment*__ was generated.
 - __*prover:*__ the party who generates a proof.
 - __*verifier:*__ the party who verifies a proof generated by a __*prover*__.
 - __*sectors count:*__ the number of sectors over which a proof-of-spacetime is performed (`POST_SECTORS_COUNT`).

## Proof of Replication

__*Proof of Replication*__ generates a unique copy (__*sealed sector*__) of a __*sector's*__ __*original data*__, a __*SNARK proof*__, and a set of __*commitments*__ identifying the __*sealed sector*__ and linking it to the corresponding __*unsealed sector*__.

## Seal

`Seal` has the side effect of generating a __*sealed sector*__ from an __*unsealed sector*__,  and returns identifying __*commitments*__ and a __*SNARK proof*__. The proof returned is a __*SNARK proofs*__.

The commitments are used to verify that the correct __*original data*__ was sealed, and that the correct __*sealed data*__ is the subject of later __*Proofs of Space-Time*__, proving that this data is being stored continuously.

`Seal` operates by performing a slow encoding of the __*unsealed sector*__ — such that it is infeasible for a dishonest prover to computationally regenerate the __*sealed sector*__ quickly enough to satisfy subsequent required __*Proofs of Space-Time*__ — thus ensuring that the __*sealed sector*__ remains manifest as a unique, concrete representation of the __*original data*__. 

```
Seal
 (
  // request represents a request to seal a sector.
  proverID       [31]byte,    // uniquely identifies miner
  sealedAccess   string,      // identifier providing access to sealed sector-access
  sectorID       [31]byte,    // uniquely identifies sector
  storage        SectorStore, // used to manipulate sectors
  unsealedAccess string       // identifier providing access to unsealed sector-access
 ) err Error | (
  // response contains the commitments resulting from a successful Seal().
  commD          [32]byte,                       // data commitment: merkle root of original data
  commR          [32]byte,                       // replica commitment: merkle root of replicated data [will be removed in future iteration]
  commRStar      [32]byte,                       // a hash of intermediate layers
  proof          []byte, 
 )

```

### VerifySeal
`VerifySeal` is the functional counterpart to `Seal`'s proof component. It takes all of `Seal's` outputs, along with those of Seal's inputs which are required to uniquely identify the created __*sealed sector*__. This allows a __*verifier*__ to determine whether a given proof is valid.  All inputs are required because verification requires sufficient context to determine not only that a proof is *valid* but also that the proof indeed corresponds to what it purports to prove.

```

VerifySeal
 (
  // request represents a request to verify the output of a Seal() operation.
  commD     [32]byte,                       // returned from Seal
  commR     [32]byte,                       // returned from Seal [will be removed in future iteration] 
  commRStar [32]byte,                       // returned from Seal
  proof     []byte,                         // returned from Seal
  proverID  [31]byte,                       // uniquely identifies miner
  sectorID  [31]byte,                       // uniquely identifies sector
) err Error | 
  IsValid bool                              // true iff the provided proof-of-replication os valid

```
### Unseal

`Unseal` is the counterpart to `Seal`'s encoding side-effect. It reverses the 'slow encoding' and creates an __*unsealed sector*__ from a __*sealed sector*__ as a special case of its more general function. In general, it allows extraction of a range of bytes (specified in terms of the layout of the __*original data*__).
```
Unseal
 (
  // request represents a request to unseal a sector.
  numBytes      uint64,      // number of bytes to unseal (corresponds to contents of unsealed sector-file)
  outputAccess  string,      // identifier providing access to write unsealed file-bytes
  proverID      [31]byte,    // uniquely identifies miner
  sealedAccess  string,      // identifier providing access to sealed sector-file
  sectorID      [31]byte,    // uniquely identifies sector
  startOffset   uint64,      // zero-based byte offset in original, unsealed sector-file
  storage       SectorStore  // used to manipulate sectors
 ) err Error |
  NumBytesWritten uint64     // the number of bytes unsealed (and written) by Unseal()
```

### Security Notes

#### Guaranteeing sector uniqueness
Every sealed sector is unique, even if the unsealed data is identical. This prevents a malicious miner from storing the same sector twice without dedicating twice the amount of storage, or two malicious miners pretending to store the same sector, but only storing one copy. Sector uniqueness is guaranteed by having unique `proverId` and `sectorId`. Each miner has a unique `proverID`, and each sector has a unique `sectorID`within that miner's sectors. Taken together, `proverID` and `sectorID` are globally unique . Both the `proverId` and the `sectorId` are used to encode the sealed data.

The Filecoin node verifies that the correct `proverId` and `sectorId` is used when verifying the proof.

---
## Proof of Space-Time
__NOTE:__ __*Proof of Space-Time*__ is in transition. Current implementations are mocked, and the final design has not been implemented. Consumers may refer to the below for reference, but nothing should be implemented until the spec is updated and synchronized with what will be the canonical construction.

### GeneratePost

`GeneratePoSt` generates a __*Proof of Space-Time*__ over `POST_SECTORS_COUNT` __*sealed sectors*__ — identified by their `commR` commitments. This is accomplished by performing a series of merkle inclusion proofs (__*Proofs of Retrievability*__). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided `challengeSeed`. At each time step, a number of __*Proofs of Retrievability*__ are performed. The result of each such set of __*Proofs of Retrievability*__ is used to seed challenge generation for another iteration. Repeated and necessarily sequential generation of these __*Proofs of Retrievability*__ proves that the claimed __*sealed sectors*__ existed during the time required to generate them.

Since many __*sealed sectors*__ may be proved at once, it may be the case that one or more __*sealed sectors*__ has been lost, damaged, or otherwise become impossible to validly prove. In this case, a fault is recorded and returned in an array of faults. This allows provers to selectively default on individual __*sealed sector*__ proofs while still providing a verifiable proof of their aggregate __*Proof of Space-Time*__ claims.

```
GeneratePoSt
 (
  // request represents a request to generate a proof-of-spacetime.
  commRs         [POST_SECTORS_COUNT][32]byte,  // the commR commitments corresponding to the sealed sectors to prove
  challengeSeed  [32]byte,    // a pseudo-random value to be used in challenge generation
) err Error | (
  // response contains PoST proof and any faults that may have occurred.
  faults        []uint64,    // faults encountered while proving (by index of associated commR in the input) 
  proof         []byte
)
```
### VerifyPoSt

`VerifyPoSt` is the functional counterpart to `GeneratePoSt`. It takes all of `GeneratePoSt`'s output, along with those of `GeneratePost`'s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.

```
VerifyPoSt
 (
  // request represents a request to generate verify a proof-of-spacetime.
  commRs        [POST_SECTORS_COUNT][32]byte,        // the commRs provided to GeneratePoSt
  challengeSeed [32]byte,
  faults        []uint64
  proof         []byte,            // SNARK proof returned by GeneratePoSt 
 ) err Error | 
  isValid bool                     // true iff the provided Proof of Space-Time is valid
```

---
## Piece Inclusion Proof
### PieceInclusionProof
A `PieceInclusionProof` contains a merkle inclusion proof for the first and last node
of a piece. This ensures all 'edge' hashes necessary to generate a complete merkle
tree are available.

Depending on the position of the nodes, not every hash provided will actually be needed.
As a space optimization, and at the cost of greater complexity in the encoding, 'interior' nodes
of either path may be omitted –– provided that the implementation `InclusionProof` allows for this omission. 

```
struct PieceInclusionProof {
    FirstNodeProof  InclusionProof,
    LastNodeProof   InclusionProof,
}
```

### GeneratePieceInclusionProofs

`GeneratePieceInclusionProofs` takes a merkle tree and a slice of piece lengths, and returns
a vector of `PieceInclusionProofs` corresponding to the pieces. This assumes that the first
piece begins at offset 0, and that each piece begins directly after the previous piece ends.
For this method to work, the piece data used to validate pieces will need to be padded as necessary,
and pieces will need to be aligned (to 128-byte chunks due to details of __*preprocessing*__) when written.

```
GeneratePieceInclusionProofs
 (
  Tree MerkleTree,
  PieceLengths uint,
 ) []PieceInclusionProof
```

`GeneratePieceInclusionProof` takes a merkle tree and the index positions of the first and last nodes
of the piece whose inclusion should be proved. It returns a corresponding `PieceInclusionProof`.
For the resulting proof to be valid, first_node must be <= last_node.

```
GeneratePieceInclusionProof
 (
  tree       MerkleTree,
  firstNode  uint,
  lastNode   uint,
 ) err Error | proof PieceInclusionProof
```

`VerifyPieceInclusionProof` takes a merkle root and (pre-processed) piece data.
Iff it returns true, then `PieceInclusionProof` indeed proves that piece's
bytes were included in the merkle tree corresponding to root — and at the
position encoded in the proof.
```
VerifyPieceInclusionProof
 (
  proof PieceInclusionProof,
  root  [32]byte,
  piece []byte
 ) err Error | IsValid bool // true iff the provided PieceInclusionProof is valid.
```
