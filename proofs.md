# Proofs

## Overview

The Filecoin protocol uses cryptographic proofs to ensure the two following guarantees:

- **Storage Based Consensus**: Miners' power in the consensus is proportional to their amount of storage. Miner increase their power by proving that they are dedicating unique storage to the network.
- **Verifiable Storage Market**: Miners must be proving that they are dedicating unique physical space for each copy of the clients data through a period of time.

We briefly describe the three main Filecoin proofs:

- __*Proof-of-Replication (PoRep)*__ proves that a Storage Miner is dedicating unique dedicated storage for each ***sector***. Filecoin Storage Miners collect new clients' data in a sector, run a slow encoding process (called `Seal`) and generate a proof (`SealProof`) that the encoding was generated correctly.

  In Filecoin, PoRep provides two guarantees: (1) *space-hardness*: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) *replication*: Storage Miners are dedicating unique storage for each copy of their clients data. 

- __*Proof of Spacetime*__ proves that an arbitrary number of __*sealed sectors*__ existed over a specified period of time in their own dedicated storage — as opposed to being generated on-the-fly at proof generation time.

- __*Piece-Inclusion-Proof*__ proves that a given __*piece*__ is contained within a specified __*sealed sector*__.

## Glossary

Throughout this document, the following definitions are used:

- __*sector:*__ a fixed-size block of data of `SECTOR_SIZE` bytes which generally contains clients' data.
- __*piece:*__ a block of data of at most `SECTOR_SIZE` bytes which is generally is a client's file or part of.
- __*original data:*__ the concatenation of a __*sector's*__ constitutent pieces, all __*piece padding*__, and any __*terminal padding*__.
- __*unsealed sector:*__ a concrete representation (on disk or in memory) of a sector's __*original data*__. 
- __*sealed sector:*__ a concrete representation (on disk or in memory) of the unique replica generated by `Seal` from an __*unsealed sector*__. 
- __*piece padding:*__ a block of zero or more 'zero bytes' inserted between __*pieces*__ to ensure they are positioned within the containing __*sector*__ in a way compatible with the __*Piece Inclusion Proof*__.
- __*terminal padding:*__ a block of zero or more 'zero bytes' inserted after a __*sector's*__ final piece, ensuring that the length of the __*original data*__ is `SECTOR_BYTES`.
- __*preprocessing:*__ a transformation applied to an __*unsealed sector*__ as the first stage of sealing and which may increase the size of the data.
- __*preprocessed data:*__ the result of __*preprocessing*__ the __*original data*__.
- __*preprocessed sector:*__ a concrete representation (on disk or in memory) of a __*sector's*__ __*preprocessed data*__.
- __*SNARK proof:*__ a block of bytes which proves that the creator is in possession of a satisfying assignment to a quadratic arithmetic program (__*circuit*__).
- __*Multi-SNARK proof:*__ a block of one or more __*SNARK proofs*__, each proving partition of the total set of challenges to be proved.  
- __*Merkle inclusion proof:*__ a proof (whose format is unspecified here) that a given leaf block is contained within a merkle tree whose root is the __*commitment*__ associated with the proof.
- __*commitment:*__ an opaque block of data to which a prover 'commits', enabling subsequent proofs which cannot be validly constructed unless the __*commitment*__ itself was validly constructed. For example: the output of a suitable pseudorandom collision-resistant hash function may serve as a __*commitment*__ to the data which is the preimage of that hash. Publication of the __*commitment*__ proves that the creator was in possession of the preimage at the time the __*commitment*__ was generated.
- __*prover:*__ the party who generates a proof, in Filecoin it's always the Storage Miner.
- __*verifier:*__ the party who verifies a proof generated by a __*prover*__, in Filecoin it's a full node.
- __*sectors count:*__ the number of sectors over which a proof-of-spacetime is performed (`POST_SECTORS_COUNT`, `16 PiB / 64 GiB = 262144`).

## Proof-of-Replication Algorithms

__*Filecoin Proof of Replication*__ generates a unique copy (__*sealed sector*__) of a __*sector's*__ __*original data*__, a __*Multi-SNARK proof*__, and a set of __*commitments*__ identifying the __*sealed sector*__ and linking it to the corresponding __*unsealed sector*__.

### Seal

`Seal` has the side effect of generating a __*sealed sector*__ from an __*unsealed sector*__,  and returns identifying __*commitments*__ and a __*Multi-SNARK proof*__. The proof returned is a __*Multi-SNARK proof*__.

The commitments are used to verify that the correct __*original data*__ was sealed, and that the correct __*sealed data*__ is the subject of later __*Proofs of Spacetime*__, proving that this data is being stored continuously.

`Seal` operates by performing a slow encoding of the __*unsealed sector*__ — such that it is infeasible for a dishonest prover to computationally regenerate the __*sealed sector*__ quickly enough to satisfy subsequent required __*Proofs of Spacetime*__ — thus ensuring that the __*sealed sector*__ remains manifest as a unique, concrete representation of the __*original data*__. 

```
Seal
 (
  // request represents a request to seal a sector.
  partitions     uint64,      // influences the size of the output proof; using less partitions requires more hardware but produces shorter proofs
  sectorSize     uint64,      // the number of bytes in the sealed sector
  unsealedPath   string,      // path of unsealed sector (regular file, ramdisk, etc.) from which a unique replica will be created
  sealedPath     string,      // path to which sealed sector will be written
  proverID       [31]byte,    // uniquely identifies miner
  ticket         [32]byte,    // ticket to which miner commits when sealing begins
  sectorID       [31]byte,    // uniquely identifies sector
 ) err Error | (
  // response contains the commitments resulting from a successful Seal().
  commD          [32]byte,    // data commitment: merkle root of original data
  commR          [32]byte,    // replica commitment: merkle root of replicated data [will be removed in future iteration]
  commRStar      [32]byte,    // a hash of intermediate layers
  proof          []byte,
 )

```

### VerifySeal

`VerifySeal` is the functional counterpart to `Seal`'s proof component. It takes all of `Seal's` outputs, along with those of Seal's inputs which are required to uniquely identify the created __*sealed sector*__. This allows a __*verifier*__ to determine whether a given proof is valid.  All inputs are required because verification requires sufficient context to determine not only that a proof is *valid* but also that the proof indeed corresponds to what it purports to prove.

```
VerifySeal
 (
  // request represents a request to verify the output of a Seal() operation.
  commD       [32]byte, // returned from Seal
  commR       [32]byte, // returned from Seal [will be removed in future iteration]
  commRStar   [32]byte, // returned from Seal
  proof       []byte,   // returned from Seal
  proverID    [31]byte, // uniquely identifies miner
  ticket      [32]byte, // ticket to which miner committed when sealing began
  sectorID    [31]byte, // uniquely identifies sector
) err Error |
  IsValid bool          // true iff the provided proof-of-replication os valid

```

### Unseal

`Unseal` is the counterpart to `Seal`'s encoding side-effect. It reverses the 'slow encoding' and creates an __*unsealed sector*__ from a __*sealed sector*__ as a special case of its more general function. In general, it allows extraction of a range of bytes (specified in terms of the layout of the __*original data*__).

```
Unseal
 (
  // request represents a request to unseal a sector.
  sectorSize    uint64,   // the number of bytes in the sealed sector
  sealedPath    string,   // path from which sealed bytes will be read
  outputPath    string,   // path to which unsealed bytes will be written (regular file, ramdisk, etc.)
  proverID      [31]byte, // uniquely identifies miner
  sectorID      [31]byte, // uniquely identifies sector
  ticket        [32]byte, // ticket to which miner committed when sealing began
  startOffset   uint64,   // zero-based byte offset in original, unsealed sector-file
  numBytes      uint64,   // number of bytes to unseal (corresponds to contents of unsealed sector-file)
 ) err Error |
  NumBytesWritten uint64  // the number of bytes unsealed (and written) by Unseal()
```

### Security Notes

#### Guaranteeing sector uniqueness

Every sealed sector is unique, even if the unsealed data is identical. This prevents a malicious miner from storing the same sector twice without dedicating twice the amount of storage, or two malicious miners pretending to store the same sector, but only storing one copy. Sector uniqueness is guaranteed by having unique `proverId` and `sectorId`. Each miner has a unique `proverID`, and each sector has a unique `sectorID`within that miner's sectors. Taken together, `proverID` and `sectorID` are globally unique . Both the `proverId` and the `sectorId` are used to encode the sealed data.

The Filecoin node verifies that the correct `proverId` and `sectorId` is used when verifying the proof.

------

## Proof-of-Spacetime algorithms

__NOTE:__ __*Proof of Spacetime*__ is in transition. Current implementations are mocked, and the final design has not been implemented. Consumers may refer to the below for reference, but nothing should be implemented until the spec is updated and synchronized with what will be the canonical construction.

### GeneratePost

`GeneratePoSt` generates a __*Proof of Spacetime*__ over `POST_SECTORS_COUNT` __*sealed sectors*__ — identified by their `commR` commitments. This is accomplished by performing a series of merkle inclusion proofs (__*Proofs of Retrievability*__). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided `challengeSeed`. At each time step, a number of __*Proofs of Retrievability*__ are performed. The result of each such set of __*Proofs of Retrievability*__ is used to seed challenge generation for another iteration. Repeated and necessarily sequential generation of these __*Proofs of Retrievability*__ proves that the claimed __*sealed sectors*__ existed during the time required to generate them.

Since many __*sealed sectors*__ may be proved at once, it may be the case that one or more __*sealed sectors*__ has been lost, damaged, or otherwise become impossible to validly prove. In this case, a fault is recorded and returned in an array of faults. This allows provers to selectively default on individual __*sealed sector*__ proofs while still providing a verifiable proof of their aggregate __*Proof of Spacetime*__ claims.

```
GeneratePoSt
 (
  // request represents a request to generate a proof-of-spacetime.
  commRs         [POST_SECTORS_COUNT][32]byte,  // the commR commitments corresponding to the sealed sectors to prove
  challengeSeed  [32]byte,    // a pseudo-random value to be used in challenge generation
) err Error | (
  // response contains PoST proof and any faults that may have occurred.
  faults        []uint64,    // faults encountered while proving (by index of associated commR in the input)
  proof         []byte
)
```

### VerifyPoSt

`VerifyPoSt` is the functional counterpart to `GeneratePoSt`. It takes all of `GeneratePoSt`'s output, along with those of `GeneratePost`'s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.

```
VerifyPoSt
 (
  // request represents a request to generate verify a proof-of-spacetime.
  commRs        [POST_SECTORS_COUNT][32]byte,        // the commRs provided to GeneratePoSt
  challengeSeed [32]byte,
  faults        []uint64
  proof         []byte,            // Multi-SNARK proof returned by GeneratePoSt 
 ) err Error | 
  isValid bool                     // true iff the provided Proof of Spacetime is valid
```

------

## Piece Inclusion Proof

### PieceInclusionProof

A `PieceInclusionProof` contains a potentially complex merkle inclusion proof that all leaves included in `commP` (the piece commitment) are also included in `commD` (the sector data commitment).

```
struct PieceInclusionProof {
    Position uint,
    ProofElements [32]byte
}
```

### GeneratePieceInclusionProofs

`GeneratePieceInclusionProofs` takes a merkle tree and a slice of piece start positions and lengths (in nodes), and returns
a vector of `PieceInclusionProofs` corresponding to the pieces. For this method to work, the piece data used to validate pieces will need to be padded as necessary,
and pieces will need to be aligned (to 128-byte chunks due to details of __*preprocessing*__) when written. This assumes that pieces have been packed and padded according to the assumptions of the algorithm. For this reason, practical implementations should also provide a function to assist in correct packing of pieces.

```
GeneratePieceInclusionProofs
 (
  Tree MerkleTree,
  PieceStarts []uint
  PieceLengths uint,
 ) []PieceInclusionProof
```

`GeneratePieceInclusionProof` takes a merkle tree and the index positions of the first and last nodes
of the piece whose inclusion should be proved. It returns a corresponding `PieceInclusionProof`.
For the resulting proof to be valid, first_node must be <= last_node.

```
GeneratePieceInclusionProof
 (
  tree          MerkleTree,
  firstNode     uint,
  pieceLength   uint,
 ) err Error |  proof PieceInclusionProof
```

`VerifyPieceInclusionProof` takes a sector data commitment (`commD`), piece commitment (`commP`), sector size, and piece size.
Iff it returns true, then `PieceInclusionProof` indeed proves that all of piece's bytes were included in the merkle tree corresponding
to `commD` of a sector of `sectorSize`. The size inputs are necessary to prevent malicious provers from claiming to store the entire
piece but actually storing only the piece commitment. 

```
VerifyPieceInclusionProof
 (
  proof PieceInclusionProof,
  commD  [32]byte,
  commP [32]byte,
  sectorSize uint,
  pieceSize uint,
 ) err Error | IsValid bool // true iff the provided PieceInclusionProof is valid.
```
