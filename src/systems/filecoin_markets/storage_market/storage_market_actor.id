import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import deal "github.com/filecoin-project/specs/systems/filecoin_markets/deal"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"

type StorageParticipantBalance struct {
    Locked     actor.TokenAmount
    Available  actor.TokenAmount
}

type BalancesHAMT {addr.Address: StorageParticipantBalance}
type DealsAMT {deal.DealID: deal.OnChainDeal}

type StorageMarketActorState struct {
    Balances  BalancesHAMT
    Deals     DealsAMT

    _generateStorageDealID(rt Runtime, deal deal.StorageDeal) deal.DealID
    _isBalanceAvailable(rt Runtime, a addr.Address, amount actor.TokenAmount) bool
    _assertValidClientSignature(rt Runtime, dealP deal.StorageDealProposal)
    _assertDealStartAfterCurrEpoch(rt Runtime, p deal.StorageDealProposal)
    _assertDealNotYetExpired(rt Runtime, p deal.StorageDealProposal)
    _assertValidDealTimingAtPublish(rt Runtime, p deal.StorageDealProposal)
    _assertValidDealMinimum(rt Runtime, p deal.StorageDealProposal)
    _assertSufficientBalanceAvailForDeal(rt Runtime, p deal.StorageDealProposal)
    _assertDealExpireAfterMaxProveCommitWindow(rt Runtime, p deal.StorageDealProposal)

    // check if StorageDeal is signed before expiry
    // check if StorageDeal has the right signatures
    // check if minimum StoragePrice and StorageCollateral are met
    // check if provider and client have sufficient balances
    _validateNewStorageDeal(rt Runtime, deal deal.StorageDeal) bool

    _lockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _unlockBalance(rt Runtime, addr addr.Address, amount actor.TokenAmount)
    _transferBalance(
        rt           Runtime
        fromLocked   addr.Address
        toAvailable  addr.Address
        amount       actor.TokenAmount
    )
    _lockFundsForStorageDeal(rt Runtime, deal deal.StorageDeal)

    _safeGetOnChainDeal(rt Runtime, dealID deal.DealID) deal.OnChainDeal
    _safeGetBalance(rt Runtime, participant addr.Address) StorageParticipantBalance
    _assertPublishedDealState(rt Runtime, dealID deal.DealID)
    _assertActiveDealState(rt Runtime, dealID deal.DealID)
    _activateDeal(rt Runtime, deal deal.OnChainDeal) deal.OnChainDeal

    _getStorageFeeSinceLastPayment(
        rt               Runtime
        deal             deal.OnChainDeal
        newPaymentEpoch  block.ChainEpoch
    ) actor.TokenAmount

    _terminateDeal(rt Runtime, dealID deal.DealID) actor.TokenAmount
    _slashDealCollateral(
        rt      Runtime
        amount  actor.TokenAmount
    ) actor.TokenAmount
}

type StorageMarketActorCode struct {
    WithdrawBalance(rt Runtime, balance actor.TokenAmount)
    AddBalance(rt Runtime)  // amount is in the message

    // call by StorageMiningSubsystem before PreCommitSector
    // a StorageDeal is only published on chain when it passes _validateNewStorageDeal
    // _validateNewStorageDeal checks for the following:
    //     - deal did not start/expire when it is signed
    //     - deal hits the chain before its StartEpoch
    //     - client and provider address and signature are correct (TODO may be unnecessary)
    //     - client and provider have sufficient balances to lock up
    // a DealID will be assigned and stored in the mapping of DealID to StorageDeal
    // _lockBalance is then called after each _validateNewStorageDeal to lock up balances
    PublishStorageDeals(rt Runtime, deals [deal.StorageDeal]) [PublishStorageDealResponse]

    // Call by sm.PreCommitSector
    // Verify the following:
    //     - dealIDs have been registered in PublishedDeals
    //     - deals will not expire by the time ProveCommit hits
    //     - deals have not started
    // Fail PreCommit if any of above is not true and abort
    VerifyPublishedDealIDs(rt Runtime, dealIDs [deal.DealID])

    // Call by sm.ProveCommitSector
    // Verify the following:
    //     - dealIDs are in PublishedDeals
    //     - deals have not expired, OK if deals have started
    // Fail ProveCommit if any of the above is not true and abort
    // Move deals from PublishDeals to ActiveDeals if all deals satisfy the requirement
    ActivateDeals(rt Runtime, dealIDs [deal.DealID]) [deal.OnChainDeal]

    // call by StorageMinerActor
    // slash deal collateral depending on the faults (only TerminatedFault)
    ProcessDealSlash(
        rt         Runtime
        dealIDs    [deal.DealID]
        faultType  sector.StorageFaultType
    )

    // batch process storage deal payment
    // Note: if a sector enters into a Failing state but later recovers, client still pays miner as usual
    // client only stops paying when a sector gets cleared (expired or faulted)
    // Note: Clients stop paying when miners enter into Failing state
    // payment happens at next _onSuccessfulPoSt when miner recovers
    // If a miner did not recover, payment will stop at the first fault
    ProcessDealPayment(
        rt               Runtime
        dealIDs          [deal.DealID]
        newPaymentEpoch  block.ChainEpoch
    )

    // batch process storage deal expiration
    ProcessDealExpiration(rt Runtime, dealIDs [deal.DealID])

    GetPieceInfosForDealIDs(rt Runtime, dealIDs [deal.DealID]) [sector.PieceInfo]

    ClearInactiveDealIDs(rt Runtime, dealIDs [deal.DealID])
}
