import ipld "github.com/filecoin-project/specs/libraries/ipld"
import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import piece "github.com/filecoin-project/specs/systems/filecoin_files/piece"
import msg "github.com/filecoin-project/specs/systems/filecoin_vm/message"

type DealID UVarint
type DealIDs struct {
    Items [DealID]
}
type DealWeight int  // should be BigInt

type DealCID ipld.CID
type ProposalCID ipld.CID
type PayloadCID ipld.CID
type Signature struct {}  // TODO

// Note: Deal Collateral is only released and returned to clients and miners
// when the storage deal stops counting towards power. In the current iteration,
// it will be released when the sector containing the storage deals expires,
// even though some storage deals can expire earlier than the sector does.
// Collaterals are denominated in PerEpoch to incur a cost for self dealing or
// minimal deals that last for a long time.
// Note: ClientCollateralPerEpoch may not be needed and removed pending future confirmation.
// There will be a Minimum value for both client and provider deal collateral.
type StorageDealProposal struct {
    PieceCID                      piece.PieceCID  // 35 bytes CommP
    PieceSize                     piece.PieceSize
    Client                        addr.Address
    Provider                      addr.Address
    ClientSignature               Signature

    // Nominal start epoch. Deal payment is linear between StartEpoch and EndEpoch,
    // with total amount StoragePricePerEpoch * (EndEpoch - StartEpoch).
    // Storage deal must appear in a sealed (proven) sector no later than StartEpoch,
    // otherwise it is invalid.
    StartEpoch                    block.ChainEpoch
    EndEpoch                      block.ChainEpoch
    StoragePricePerEpoch          actor.TokenAmount

    ProviderCollateral            actor.TokenAmount
    ClientCollateral              actor.TokenAmount

    Duration()                    block.ChainEpoch   @(cached)  // EndEpoch - StartEpoch
    TotalStorageFee()             actor.TokenAmount  // StoragePricePerEpoch * Duration
    ClientBalanceRequirement()    actor.TokenAmount  // ClientCollateral + TotalStorageFee
    ProviderBalanceRequirement()  actor.TokenAmount  // ProviderCollateral

    CID()                         ProposalCID
}

// Everything in this struct will go on chain
// We are enforcing that StorageProvider calls PublishStorageDeal to get back a StorageDeal struct
// Provider's signature is implicit in the onchain call
type StorageDeal struct {
    Proposal()      StorageDealProposal  // can extract proposal from the message
    PublishMessage  msg.SignedMessage  // counter signature is implicit in the message

    CID()           DealCID
}

type OnChainDeal struct {
    ID                DealID
    Deal              StorageDeal
    SectorStartEpoch  block.ChainEpoch  // -1 if not yet included in proven sector
    LastUpdatedEpoch  block.ChainEpoch  // -1 if deal state never updated
    SlashEpoch        block.ChainEpoch  // -1 if deal never slashed
}

type RetrievalDealProposal struct {}  // TODO
type RetrievalDeal struct {
    Proposal          RetrievalDealProposal
    CounterSignature  Signature
}
