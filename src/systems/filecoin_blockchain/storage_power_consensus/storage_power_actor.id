import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import libp2p "github.com/filecoin-project/specs/libraries/libp2p"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import actor "github.com/filecoin-project/specs/systems/filecoin_vm/actor"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"

type PowerTableEntry struct {
    ActivePower             block.StoragePower
    InactivePower           block.StoragePower
    AvailableBalance        actor.TokenAmount
    LockedPledgeCollateral  actor.TokenAmount
}

type PowerReport struct {
    ActivePower    block.StoragePower  // set value
    InactivePower  block.StoragePower  // set value
}

// type PowerTableHAMT {actor.ActorID: PowerTableEntry}
type PowerTableHAMT {addr.Address: PowerTableEntry}  // TODO: convert address to ActorID

type StoragePowerActorState struct {
    // PowerTable is a mapping from MinerActorID to PowerTableEntry
    PowerTable  PowerTableHAMT
    EC          ExpectedConsensus

    _slashPledgeCollateral(rt Runtime, address addr.Address, amount actor.TokenAmount) actor.TokenAmount
    _lockPledgeCollateral(rt Runtime, address addr.Address, amount actor.TokenAmount)
    _unlockPledgeCollateral(rt Runtime, address addr.Address, amount actor.TokenAmount)
    _getPledgeCollateralReq(rt Runtime, newPower block.StoragePower) actor.TokenAmount
    _sampleMinersToSurprise(rt Runtime, challengeCount int, randomness util.Randomness) [addr.Address]
    _shouldChallenge(rt Runtime, networkPower block.StoragePower) bool

    _safeGetPowerEntry(rt Runtime, minerID addr.Address) PowerTableEntry
    _ensurePledgeCollateralSatisfied(rt Runtime) bool
    _getAffectedPledge(
        rt             Runtime
        minerID        addr.Address
        affectedPower  block.StoragePower
    ) actor.TokenAmount
    _getActivePower() block.StoragePower
    ActivePowerMeetsConsensusMinimum(minPower block.StoragePower) bool
}

type StoragePowerActorCode struct {
    AddBalance(rt Runtime)
    WithdrawBalance(rt Runtime, amount actor.TokenAmount)

    // call by StorageMiningSubsytem on miner creation
    CreateStorageMiner(
        // TODO: document differences in Addr, Key and ID accross spec
        rt          Runtime
        ownerAddr   addr.Address
        workerAddr  addr.Address
        peerId      libp2p.PeerID  // TODO: will be removed likely (see: https://github.com/filecoin-project/specs/pull/555#pullrequestreview-300991681)
    ) addr.Address

    RemoveStorageMiner(rt Runtime, addr addr.Address)

    // PowerTable Operations
    GetTotalPower(rt Runtime) block.StoragePower
    GetSectorPower(rt Runtime) block.StoragePower

    EnsurePledgeCollateralSatisfied(rt Runtime)

    ProcessPowerReport(rt Runtime, report PowerReport)
    SlashPledgeForStorageFault(
        rt             Runtime
        affectedPower  block.StoragePower
        faultType      sector.StorageFaultType
    )

    ReportConsensusFault(
        // slasherAddr  addr.Address TODO: fromActor
        rt         Runtime
        faultType  ConsensusFaultType
        proof      [block.Block]
    )

    Surprise(rt Runtime, ticket block.Ticket) [addr.Address]

    shouldChallenge(
        minerAddr            addr.Address
        currEpoch            block.ChainEpoch
        challengeFreePeriod  block.ChainEpoch
    ) bool

    PowerMeetsConsensusMinimum(rt Runtime, minerPower block.StoragePower)

    // this should call ReportConsensusFault, numSectors should be all sectors
    // ReportUncommittedPowerFault(cheaterAddr addr.Address, numSectors UVarint)
}
