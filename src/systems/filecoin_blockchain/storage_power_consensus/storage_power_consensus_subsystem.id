import addr "github.com/filecoin-project/specs/systems/filecoin_vm/actor/address"
import block "github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block"
import st "github.com/filecoin-project/specs/systems/filecoin_vm/state_tree"
import filcrypto "github.com/filecoin-project/specs/algorithms/crypto"
import sector "github.com/filecoin-project/specs/systems/filecoin_mining/sector"
import blockchain "github.com/filecoin-project/specs/systems/filecoin_blockchain"

type StoragePowerConsensusSubsystem struct {//(@mutable)
    // actor                StoragePowerActor
    associatedStateTree &st.StateTree  // TODO: remove this. should not store this here.

    GenerateElectionProof(tipset block.Tipset) block.ElectionProof
    ChooseTipsetToMine(tipsets [block.Tipset]) [block.Tipset]

    ec          ExpectedConsensus
    blockchain  blockchain.BlockchainSubsystem

    // call by BlockchainSubsystem during block reception
    ValidateBlock(block block.Block) error

    IsWinningPartialTicket(
        st                 st.StateTree
        partialTicket      sector.PartialTicket
        sectorUtilization  block.StoragePower
    ) bool

    _getStoragePowerActorState(stateTree st.StateTree) StoragePowerActorState

    validateTicket(
        tix             block.Ticket
        pk              filcrypto.VRFPublicKey
        minerActorAddr  addr.Address
    ) bool

    computeChainWeight(tipset block.Tipset) block.ChainWeight

    StoragePowerConsensusError() StoragePowerConsensusError

    // Randomness methods

    // call by StorageMiningSubsystem during block production
    GetTicketProductionRand(chain block.Chain, epoch block.ChainEpoch) util.Randomness

    // call by StorageMiningSubsystem during block production
    GetElectionProofRand(chain block.Chain, epoch block.ChainEpoch) util.Randomness

    // call by StorageMiningSubsystem in sealing sector
    GetSealRand(chain block.Chain, epoch block.ChainEpoch) util.Randomness

    // call by StorageMiningSubsystem after sealing
    GetPoStChallengeRand(chain block.Chain, epoch block.ChainEpoch) util.Randomness

    GetFinality()     block.ChainEpoch
    FinalizedEpoch()  block.ChainEpoch
}

type StoragePowerConsensusError struct {}
