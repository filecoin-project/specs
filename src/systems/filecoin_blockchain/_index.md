---
menuIcon: ðŸ“¦
title: "**Blockchain**"
entries:
- struct
- message_pool
- chainsync
- storage_power_consensus
---

{{< incTocMap "/docs/systems/filecoin_blockchain" 3 >}}


The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol.

It includes:

- A {{<sref message_pool>}} subsystem that nodes use to track and propagate messages related to the storage market throughout a gossip network.
- A {{<sref chainsync>}} susbystem that tracks and propagates validated message blocks, assembling them into subchains corresponding to versions of the system state.
- A {{<sref vm>}} subsystem used to interpret and execute messages in order to update system state.
- A {{<sref state_tree>}} subsystem which manages the creation and maintenance of state trees (the system state) deterministically generated by the vm from a given subchain.
- A {{<sref storage_power_consensus>}} subsystem which tracks {{<sref storage_mining_subsystem "storage">}} state for a given chain and helps the blockchain system choose subchains to extend and blocks to include in them.

At a high-level, the Filecoin blockchain grows through successive rounds of leader election in which a number of miners are elected to generate a block, whose inclusion in the chain will earn them block rewards.

Most of the functions of the Filecoin blockchain system are detailed in the code below. We focus here on particular points of interest.

## Storage Power

Filecoin's blockchain runs on storage power. That is, its consensus algorithm by which miners agree on which subchain to mine is predicated on the amount of storage backing that subchain. At a high-level, the {{<sref storage_power_consensus>}} subsystem maintains a _Power Table_ that tracks the amount of storage {{<sref storage_mining_subsystem "storage miner actors">}} have contributed to the network through _Sector commitments_ and _Proofs of Spacetime_.

## Leader Election and Expected Consensus

The leader election process is likewise handled by the {{<sref storage_power_consensus>}} subsystem (SPC). Using the _Power Table_ it maintains, this subsystem runs a Nakamoto-style leader election process called Expected Consensus at every round to elect miners who can extend the block chain by generating new blocks.

Beyond participating in the Storage Market (see the {{<sref storage_market>}} spec), participation in Filecoin's consensus is the other way storage miners can earn Filecoin tokens.

{{<sref expected_consensus>}} has two main components: a leader election process and a chain selection algorithm dependent on a weight function.

## Tipsets

EC can elect multiple leaders in a given round meaning Filecoin chains can contain multiple blocks at each height (one per winning miner). This greatly increases chain throughput by allowing blocks to propagate through the network of nodes more efficiently but also means miners should coordinate how they select messages for inclusion in their blocks in order to avoid duplicates and maximize their earnings from transaction fees (see {{<sref message_pool>}}).

Accordingly, blocks from a given round are assembled into Tipsets according to certain rules (they must share the same parents and have been mined at the same height). The Filecoin state tree is modified by the execution of all messages in a given Tipset. Different miners may mine on different Tipsets because of network propagation delay.

Due to this fact, adding new blocks to the chain actually validate those blocks' parent Tipsets, that is: executing the messages of a new block, a miner cannot know exactly what state tree this will yield. That state tree is only known once all messages in that block's Tipset have been executed. Accordingly, it is in the next round (and based on the number of blocks mined on a given Tipset) that a miner will be able to choose which state tree to extend.

## Tipsets

All valid blocks generated in a round form a `Tipset` that participants will attempt to mine off of in the subsequent round (see above). Tipsets are valid so long as:

- All blocks in a Tipset have the same parent Tipset
- All blocks in a Tipset have the same number of tickets in their `Tickets` array

These conditions imply that all blocks in a Tipset were mined at the same height. This rule is key to helping ensure that EC converges over time. While multiple new blocks can be mined in a round, subsequent blocks all mine off of a Tipset bringing these blocks together. The second rule means blocks in a Tipset are mined in a same round.

The blocks in a tipset have no defined order in representation. During state computation, blocks in a tipset are processed in order of block ticket, breaking ties with the block CID bytes.

Due to network propagation delay, it is possible for a miner in round N+1 to omit valid blocks mined at round N from their Tipset. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol as defined by EC's {{<sref chain_selection>}} function.

## TODO -- reorder this

The Filecoin blockchain is the main interface linking various actors in the Filecoin system. It ensures that the system's state is verifiably updated over time and dictates how nodes are meant to extend the network through block reception and validation and extend it through block propagation.

Its components include the:

- {{ <sref chainsync> }} -- which receives and propagates blocks, maintaining sets of candidate chains on which the miner may mine and running syntactic validation on incoming blocks.
- {{ <sref chain_manager> }} -- which maintains a given chain's state, providing facilities to other blockchain subsystems which will query state about the latest chain in order to run, and ensuring incoming blocks are semantically validated before inclusion into the chain.
- {{ <sref block_producer> }} -- which is called in the event of a successful leader election in order to produce a new block that will extend the current heaviest chain before forwarding it to the syncer for propagation.
