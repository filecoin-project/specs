<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Filecoin Specification on Filecoin Spec</title>
    <link>/</link>
    <description>Recent content in Filecoin Specification on Filecoin Spec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>/docs/actors/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/actors/contributing/</guid>
      <description>Contributing Please read the spec process. Please file PRs on github with fixes.</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/orient/viz/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/orient/viz/readme/</guid>
      <description>Ubercalc visualizations Install  Install orient Install obs  Usage # Run these commands from the root folder of the spec repo on two different terminals $ ORIENT_CACHE_DIR=/absolute/path/to/cache ./orient/bin/orient web --system=src/orient/rational-calc.orient --port=8000 $ obs serve 8081 src/orient/viz </description>
    </item>
    
    <item>
      <title>About this specification</title>
      <link>/docs/intro/process/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/about/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>AccountActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/account_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/account_actor/</guid>
      <description> package account import ( addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; builtin &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin&amp;#34; vmr &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime&amp;#34; cid &amp;#34;github.com/ipfs/go-cid&amp;#34; ) type InvocOutput = vmr.InvocOutput type AccountActor struct{} func (a *AccountActor) Constructor(rt vmr.Runtime) InvocOutput { // Nothing. intentionally left blank. 	rt.ValidateImmediateCallerIs(builtin.SystemActorAddr) return rt.SuccessReturn() } type AccountActorState struct { Address addr.Address } func (AccountActorState) CID() cid.Cid { panic(&amp;#34;TODO&amp;#34;) }  </description>
    </item>
    
    <item>
      <title>Address</title>
      <link>/docs/appendix/address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/address/</guid>
      <description>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</description>
    </item>
    
    <item>
      <title>Architecture Diagrams</title>
      <link>/docs/intro/arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/arch/</guid>
      <description>Filecoin Systems Status Legend:
 üõë Bare - Very incomplete at this time.  Implementors: This is far from ready for you.   ‚ö†Ô∏è Rough &amp;ndash; work in progress, heavy changes coming, as we put in place key functionality.  Implementors: This will be ready for you soon.   üîÅ Refining - Key functionality is there, some small things expected to change. Some big things may change.  Implementors: Almost ready for you.</description>
    </item>
    
    <item>
      <title>BitSwap</title>
      <link>/docs/libraries/ipfs/bitswap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/bitswap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Block Reception</title>
      <link>/docs/algorithms/block_reception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_reception/</guid>
      <description>func (g *BlockValidationGraph_I) ConsiderBlock(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;) // g.UnconnectedBlocks.AddBlock(block) // g.tryConnectBlockToFringe(block) }
func (g *BlockValidationGraph_I) tryConnectBlockToFringe(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;)
// try to connect the block, and then try connecting its descendents. // // this algorithm should be breadth-first because we need to process the fringe // in order. Depth-first search may consider blocks whose parents are still // yet to be added // blocks := Queue &amp;lt; Block &amp;gt; // blocks.</description>
    </item>
    
    <item>
      <title>BlockSync</title>
      <link>/docs/algorithms/block_sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_sync/</guid>
      <description>Name: Block Sync Protocol ID: /fil/sync/blk/0.0.1  The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.
The request requests a chain of a given length by the hash of its highest block. The Options allow the requester to specify whether or not blocks and messages to be included.
The response contains the requested chain in reverse iteration order.</description>
    </item>
    
    <item>
      <title>Chain Verifier Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/verifier_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/verifier_node/</guid>
      <description>type ChainVerifierNode interface { FilecoinNode systems.Blockchain } </description>
    </item>
    
    <item>
      <title>CIDs - Content IDentifiers</title>
      <link>/docs/libraries/ipld/cid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/cid/</guid>
      <description>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used. Any pointer inclusions in the Filecoin spec id files (e.g. &amp;amp;Object) denotes the CID of said object. Some objects explicitly name a CID field. The spec treats these notations interchangeably. This is effectively a hash value, prefixed with its hash function (multihash) as well as extra labels to inform applications about how to deserialize the given data.</description>
    </item>
    
    <item>
      <title>Client Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/client_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/client_node/</guid>
      <description>type ClientNode struct { FilecoinNode systems.Blockchain markets.StorageMarketClient markets.RetrievalMarketClient markets.MarketOrderBook markets.DataTransfers } </description>
    </item>
    
    <item>
      <title>Components</title>
      <link>/docs/listings/system_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/system_map/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Contributing to the Filecoin spec</title>
      <link>/docs/intro/process/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/contributing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>CronActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/cron_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/cron_actor/</guid>
      <description>package cron import ( addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; builtin &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin&amp;#34; vmr &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime&amp;#34; ) type CronActorState struct{} type CronActor struct { // TODO move Entries into the CronActorState struct 	Entries []CronTableEntry } type CronTableEntry struct { ToAddr addr.Address MethodNum abi.MethodNum } func (a *CronActor) Constructor(rt vmr.Runtime) vmr.InvocOutput { // Nothing. intentionally left blank. 	rt.ValidateImmediateCallerIs(builtin.SystemActorAddr) return rt.SuccessReturn() } func (a *CronActor) EpochTick(rt vmr.Runtime) vmr.InvocOutput { rt.ValidateImmediateCallerIs(builtin.SystemActorAddr) // a.Entries is basically a static registry for now, loaded 	// in the interpreter static registry.</description>
    </item>
    
    <item>
      <title>Data Model</title>
      <link>/docs/libraries/ipld/datamodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/datamodel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data Structures</title>
      <link>/docs/listings/data_structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/data_structures/</guid>
      <description>RLE+ Bitset Encoding RLE+ is a lossless compression format based on RLE. Its primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly, while keeping the same level of compression for large sets of contiugous bits.
In tests it has shown to be more compact than RLE itself, as well as Concise and Roaring.
Format The format consists of a header, followed by a series of blocks, of which there are three different types.</description>
    </item>
    
    <item>
      <title>Data Transfer Protocol</title>
      <link>/docs/listings/libp2p_protocols/data_transfer_protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/libp2p_protocols/data_transfer_protocol/</guid>
      <description> Name: Data Transfer Protocol Protocol ID: /fil/data-transfer/0.0.1  Message Protobuf
 message DataTransferMessage { message Request { int32 transferID = 1 bool isPull = 2 bytes voucher = 3 bytes pieceID = 4 bytes selector = 5 bool isPartial = 6 bool isCancel = 7 } message Response { int32 transferID = 1 boolean accepted = 2 } bool isResponse = 1 Request request = 2 Response response = 3 } </description>
    </item>
    
    <item>
      <title>Election PoSt</title>
      <link>/docs/algorithms/post/election_post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/election_post/</guid>
      <description>This document describes Election-PoSt, the Proof-of-Spacetime used in Filecoin.
At a high-level it marries ElectionPoSt with a SurprisePoSt fallback:
 By coupling leader election and PoSt, ElectionPoSt ensures that miners must do the work to prove their sectors at every round in order to earn block rewards. Small miners may not win on a regular basis however, SurprisePoSt thus comes in as a lower-bound to how often miners must PoSt and helps ensure the Power Table does not grow stale for its long-tail of smaller miners.</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>/docs/systems/filecoin_nodes/node_types/node_types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node_types/</guid>
      <description>There are many kinds of Filecoin Nodes &amp;hellip;
This section should contain:
 what all nodes must have, and why examples of using different systems  </description>
    </item>
    
    <item>
      <title>Faults</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_deal/faults/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_deal/faults/</guid>
      <description>There are two main categories of faults in the Filecoin network.
 ConsensusFaults StorageDealFaults  ConsensusFaults are faults that impact network consensus and StorageDealFaults are faults where data in a StorageDeal is not maintained by the providers pursuant to deal terms.
Pledge Collateral is slashed for ConsensusFaults and Storage Deal Collateral for StorageDealFaults.
Any misbehavior may result in more than one fault thus lead to slashing on both collaterals. For example, missing a PoStProof will incur a penalty on both PledgeCollateral and StorageDealCollateral given it impacts both a given StorageDeal and power derived from the sector commitments in Storage Power Consensus.</description>
    </item>
    
    <item>
      <title>FIL Wallet</title>
      <link>/docs/systems/filecoin_token/wallets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/wallets/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin libp2p Nodes</title>
      <link>/docs/libraries/libp2p/fil_libp2p_nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/fil_libp2p_nodes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/network_params/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/network_params/</guid>
      <description>Some of these parameters are used around the code in the Filecoin subsystems and abi. Others are used as part of the proofs libraries.
Most are generated/finalized using the orient framework. It is used to modelize the Filecoin network.
Code parameters package node_base import ( addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; ) // Parameters for on-chain calculations are in actors/builtin/network_params.go  ///////////////////////////////////////////////////////////// // Global /////////////////////////////////////////////////////////////  const NETWORK = addr.Testnet // how many sectors should be challenged in surprise post (if miner has fewer, will get dup challenges) const SURPRISE_CHALLENGE_COUNT = 200 // placeholder  const EPOST_SAMPLE_RATE_NUM = 1 // placeholder const EPOST_SAMPLE_RATE_DENOM = 25 // placeholder const SPOST_SAMPLE_RATE_NUM = 1 // placeholder const SPOST_SAMPLE_RATE_DENOM = 50 // placeholder  ///////////////////////////////////////////////////////////// // Consensus /////////////////////////////////////////////////////////////  const FINALITY = 500 // placeholder const SPC_LOOKBACK_TICKET = 1 // we chain blocks together one after the other  Orient parameters    LAMBDA SPACEGAP BLOCK-SIZE-KIB SECTOR-SIZE-GIB     10 0.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/orient/</guid>
      <description>(asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  All Parameters  (let ((result-tuple (extract (solve-for *filecoin* &amp;#39;() *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/content/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/appendix/orient/</guid>
      <description>All Parameters    Parameter Type Value Description     ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.   ALL-POST-MESSAGES-PER-YEAR  122557560.0    ALL-SEAL-MESSAGES-PER-YEAR  335544320    ALL-SEAL-SIZE-PER-YEAR  335544320    AVG-POSTS-MESSAGES-PER-BLOCK  11.650845    AVG-PROOFS-MESSAGES-PER-BLOCK  43.</description>
    </item>
    
    <item>
      <title>Filecoin VM</title>
      <link>/docs/intro/filecoin_vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/filecoin_vm/</guid>
      <description>The majority of Filecoin&amp;rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &amp;lsquo;chain&amp;rsquo; of blocks is the correct one. Each block contains a series of state transitions called messages, and a checkpoint of the current global state after the application of those messages.
The global state here consists of a set of actors, each with their own private state.</description>
    </item>
    
    <item>
      <title>Filecoin VM Actors</title>
      <link>/docs/listings/actors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/actors/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>FileStore - Local Storage for Files</title>
      <link>/docs/systems/filecoin_files/file/filestore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/file/filestore/</guid>
      <description>The FileStore is an abstraction used to refer to any underlying system or device that Filecoin will store its data to. It is based on Unix filesystem semantics, and includes the notion of Paths. This abstraction is here in order to make sure Filecoin implementations make it easy for end-users to replace the underlying storage system with whatever suits their needs. The simplest version of FileStore is just the host operating system&amp;rsquo;s file system.</description>
    </item>
    
    <item>
      <title>FIPs - Filecoin Improvement Proposals</title>
      <link>/docs/intro/process/fip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/fip/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>GossipSub</title>
      <link>/docs/algorithms/gossip_sub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/gossip_sub/</guid>
      <description>Messages and block headers along side the message references are propagated using the gossipsub libp2p pubsub router. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be syntactically validated before being propagated further.
Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.</description>
    </item>
    
    <item>
      <title>Gossipsub for broadcasts</title>
      <link>/docs/libraries/libp2p/gossipsub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/gossipsub/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GraphSync</title>
      <link>/docs/libraries/ipfs/graphsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/graphsync/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Implementing Systems</title>
      <link>/docs/intro/system/impl_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/impl_systems/</guid>
      <description>System Requirements In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes a set of functionality available to all systems. This functionality can be achieved by implementations in a variety of ways, and should take the guidance here as a recommendation (SHOULD).
All Systems, as defined in this document, require the following:
 Repository:  Local IpldStore. Some amount of persistent local storage for data structures (small structured objects).</description>
    </item>
    
    <item>
      <title>InitActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/init_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/init_actor/</guid>
      <description>package init import ( &amp;#34;bytes&amp;#34; addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; actor &amp;#34;github.com/filecoin-project/specs-actors/actors&amp;#34; abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; builtin &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin&amp;#34; vmr &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime&amp;#34; autil &amp;#34;github.com/filecoin-project/specs-actors/actors/util&amp;#34; cid &amp;#34;github.com/ipfs/go-cid&amp;#34; ) type InvocOutput = vmr.InvocOutput type Runtime = vmr.Runtime type Bytes = abi.Bytes var AssertMsg = autil.AssertMsg type InitActorState struct { // responsible for create new actors 	AddressMap map[addr.Address]abi.ActorID NextID abi.ActorID NetworkName string } func (s *InitActorState) ResolveAddress(address addr.Address) addr.Address { actorID, ok := s.AddressMap[address] if ok { idAddr, err := addr.</description>
    </item>
    
    <item>
      <title>Kademlia DHT for Peer Routing</title>
      <link>/docs/libraries/libp2p/kad_dht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/kad_dht/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Key Concepts</title>
      <link>/docs/intro/concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/concepts/</guid>
      <description>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:
  Data structures are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).
  Functions are computational procedures that do not depend on external state (i.e., mathematical functions, or programming language functions that do not refer to global variables).
  Components are sets of functionality that are intended to be represented as single software units in the implementation structure.</description>
    </item>
    
    <item>
      <title>Message Storage</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_storage/</guid>
      <description> TODO:
 give sample algorithm for miner message selection in block production (to avoid dups) give sample algorithm for message storage caching/purging policies.  </description>
    </item>
    
    <item>
      <title>Message Syncer</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</guid>
      <description>TODO:
 explain message syncer works include the message syncer code  Message Propagation Messages are propagated over the libp2p pubsub channel /fil/messages. On this channel, every serialised SignedMessage is announced (see Message).
Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</description>
    </item>
    
    <item>
      <title>Multisig Actor</title>
      <link>/docs/systems/filecoin_token/multisig/multisig_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/multisig/multisig_actor/</guid>
      <description>package multisig import ( addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; actor &amp;#34;github.com/filecoin-project/specs-actors/actors&amp;#34; abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; builtin &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin&amp;#34; vmr &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime&amp;#34; autil &amp;#34;github.com/filecoin-project/specs-actors/actors/util&amp;#34; cid &amp;#34;github.com/ipfs/go-cid&amp;#34; ) type InvocOutput = vmr.InvocOutput type Runtime = vmr.Runtime var AssertMsg = autil.AssertMsg var IMPL_FINISH = autil.IMPL_FINISH var IMPL_TODO = autil.IMPL_TODO var TODO = autil.TODO type TxnID int64 type MultiSigTransaction struct { Proposer addr.Address Expiration abi.ChainEpoch To addr.Address Method abi.MethodNum Params abi.MethodParams Value abi.TokenAmount } func (txn *MultiSigTransaction) Equals(MultiSigTransaction) bool { IMPL_FINISH() panic(&amp;#34;&amp;#34;) } type MultiSigTransactionHAMT map[TxnID]MultiSigTransaction type MultiSigApprovalSetHAMT map[TxnID]autil.</description>
    </item>
    
    <item>
      <title>Network tooling</title>
      <link>/docs/intro/process/related_resources/network_tooling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/network_tooling/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Node Interface</title>
      <link>/docs/systems/filecoin_nodes/node_types/node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node/</guid>
      <description> import repo &amp;#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&amp;#34; import filestore &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; import clock &amp;#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&amp;#34; import libp2p &amp;#34;github.com/filecoin-project/specs/libraries/libp2p&amp;#34; import message_pool &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/message_pool&amp;#34; type FilecoinNode struct { Node libp2p.Node Repository repo.Repository FileStore filestore.FileStore Clock clock.UTCClock MessagePool message_pool.MessagePoolSubsystem }  </description>
    </item>
    
    <item>
      <title>Payment Channel Actor</title>
      <link>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</guid>
      <description>Something&#39;s not right. The payment_channel_actor.id file was not found.</description>
    </item>
    
    <item>
      <title>Payment Channels</title>
      <link>/docs/algorithms/payment_channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/payment_channels/</guid>
      <description>Payment Channels In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.
The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &amp;ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>PieceStore - storing and indexing pieces</title>
      <link>/docs/systems/filecoin_files/piece/piece_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/piece/piece_store/</guid>
      <description>A PieceStore is an object that can store and retrieve pieces from some local storage. The PieceStore additionally keeps an index of pieces.
import ipld &amp;#34;github.com/filecoin-project/specs/libraries/ipld&amp;#34; type PieceID UVarint // PieceStore is an object that stores pieces into some local storage. // it is internally backed by an IpldStore. type PieceStore struct { Store ipld.GraphStore Index {PieceID: Piece} Get(i PieceID) struct {p Piece, e error} Put(p Piece) error Delete(i PieceID) error }  </description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin. (asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  (let ((result-tuple (extract (ask *filecoin* &amp;#39;(post-challenge-blocks post-challenge-hours post-proving-period) *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started.</description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/content/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
   Parameter Type Value Description     POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.   POST-CHALLENGE-HOURS HOURS 2 PoSt challenge time (see POST_CHALLENGE_BLOCKS).   POST-PROVING-PERIOD BLOCKS 5760 The time interval in which a PoSt has to be submitted    </description>
    </item>
    
    <item>
      <title>Randomness</title>
      <link>/docs/algorithms/crypto/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/randomness/</guid>
      <description>Randomness is used throughout the protocol in order to generate values and extend the blockchain. Random values are drawn from the Ticket Chain and appropriately formatted for usage. We describe this formatting below.
Encoding On-chain data for randomness Any randomness derived from on-chain values uses the following encodings to represent these values as bytes:
 Bytes: Bytes Ints: Big-endian uint64 representation Strings: ASCII Objects: Their specified Serialization, currently CBOR-based serialization defined on algebraic datatypes  Domain Separation Tags For Signatures as well as Verifiable Random Function usage in the protocol, we define Domain Separation Tags with which we prepend random inputs.</description>
    </item>
    
    <item>
      <title>Relayer Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/relayer_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/relayer_node/</guid>
      <description>type RelayerNode interface { FilecoinNode blockchain.MessagePool markets.MarketOrderBook } </description>
    </item>
    
    <item>
      <title>Research portal</title>
      <link>/docs/intro/process/related_resources/research_portal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/research_portal/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Reserved Ranges</title>
      <link>/docs/listings/reserved_ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/reserved_ranges/</guid>
      <description>Actor ID Reserved Ranges    Actor ID     SystemActor 0   InitActor 1   RewardActor 2   CronActor 3   StoragePowerActor 4   StorageMarketActor 5   BurntFundsActor 99    All values below 100 are reserved for singleton actors. The first non-singleton actor starts at 100.
Method Reserved Ranges    Method ID     value send 0   constructor 1    All other positive values are free for actors to use.</description>
    </item>
    
    <item>
      <title>Retrieval Client</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</guid>
      <description>Client Dependencies The Retrieval Client Depends On The Following Dependencies
 Host: A libp2p host (set setup the libp2p protocols) Filecoin Node: A node implementation to query the chain for pieces and to setup and manage payment channels BlockStore: Same as one used by data transfer module Data Transfer: V1 only &amp;ndash;Module used for transferring payload. Writes to the blockstore.  API import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; import addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; import peer &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Retrieval Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</guid>
      <description>type RetrievalMinerNode interface { FilecoinNode blockchain.Blockchain markets.RetrievalMarketProvider markets.MarketOrderBook markets.DataTransfers } </description>
    </item>
    
    <item>
      <title>Retrieval Peer Resolver</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_peer_resolver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_peer_resolver/</guid>
      <description>The peer resolver is a content routing interface to discover retrieval miners that have a given Piece.
It can be backed by both a local store of previous storage deals or by querying the chain.
import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; type RetrievalPeerResolver struct { GetPeers(PieceCID abi.PieceCID) [RetrievalPeer] }  </description>
    </item>
    
    <item>
      <title>Retrieval Protocols</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_protocols/</guid>
      <description>The retrieval market will initially be implemented as two libp2p services.
 Name: Query Protocol Protocol ID V0: /fil/&amp;lt;network-name&amp;gt;/retrieval/qry/0.0.1 Protocol ID V1: /fil/&amp;lt;network-name&amp;gt;/retrieval/qry/1.0.0  Request: CBOR Encoded RetrievalQuery Data Structure Response: CBOR Encoded RetrievalQueryResponse Data Structure
 Name: Retrieval Protocol Protocol ID V0: /fil/&amp;lt;network-name&amp;gt;/retrieval/0.0.1  V0: Request: CBOR Encoded RetrievalDealProposal Data Structure Response: CBOR Encoded RetrievalDealResponse Data Structure &amp;ndash; Following Request: CBOR Encoded RetrievalPayment Data Structure Response: CBOR Encoded RetrievalDealResponse Data Structure w/ Blocks</description>
    </item>
    
    <item>
      <title>Retrieval Provider (Miner)</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</guid>
      <description>Provider Dependencies The Retrieval Provider Depends On The Following Dependencies
 Host: A libp2p host (set setup the libp2p protocols) Filecoin Node: A node implementation to query the chain for pieces and to setup and manage payment channels StorageMining Subsystem: For unsealing sectors BlockStore: Same as one used by data transfer module Data Transfer: V1 only &amp;ndash; Module used for transferring payload. Reads from the blockstore.  API import abi &amp;#34;github.</description>
    </item>
    
    <item>
      <title>RewardActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/reward_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/reward_actor/</guid>
      <description>RewardActor is where unminted Filecoin tokens are kept. RewardActor contains a RewardMap which is a mapping from owner addresses to Reward structs.
Reward struct is created to preserve the flexibility of introducing block reward vesting into the protocol. MintReward creates a new Reward struct and adds it to the RewardMap.
A Reward struct contains a StartEpoch that keeps track of when this Reward is created, Value that represents the total number of tokens rewarded, and EndEpoch which is when the reward will be fully vested.</description>
    </item>
    
    <item>
      <title>Sector Builder</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_builder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_builder/</guid>
      <description>import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import smarkact &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&amp;#34; // SectorBuilder accumulates deals, keeping track of their // sector configuration requirements and the piece sizes. // Once there is a sector ready to be sealed, NextSector // will return a sector.  type StageDealResponse struct { SectorID abi.SectorID } type SectorBuilder struct { // DealsToSeal keeps a set of StorageDeal objects.  // These include the info for the relevant pieces.</description>
    </item>
    
    <item>
      <title>Sector PoSting</title>
      <link>/docs/systems/filecoin_mining/sector/posting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/posting/</guid>
      <description> //import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34;  // type PoStWitness struct { // Candidates [abi.PoStCandidate] // }  </description>
    </item>
    
    <item>
      <title>Sector Sealer</title>
      <link>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</guid>
      <description>Sector Sealer
Something&#39;s not right. The sector_sealer.id file was not found.</description>
    </item>
    
    <item>
      <title>Sector Sealing</title>
      <link>/docs/systems/filecoin_mining/sector/sealing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sealing/</guid>
      <description>import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; type Path struct {} // TODO  // SealSeed is unique to each Sector // SealSeed is: // SealSeedHash(MinerID, SectorNumber, SealRandomness, abi.UnsealedSectorCID) type SealSeed Bytes // SealCommitment is the information kept in the state tree about a sector. // SealCommitment is a subset of OnChainSealVerifyInfo. type SealCommitment struct { SealedCID abi.SealedSectorCID // CommR  DealIDs abi.DealIDs Expiration abi.ChainEpoch } // PersistentProofAux is meta data required to generate certain proofs // for a sector, for example PoSt.</description>
    </item>
    
    <item>
      <title>Sector Set</title>
      <link>/docs/systems/filecoin_mining/sector/sectorset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sectorset/</guid>
      <description> import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; // sector sets type SectorSet [abi.SectorID] type UnsealedSectorSet SectorSet type SealedSectorSet SectorSet // compact sector sets type Bitfield Bytes type RLEpBitfield Bitfield type CompactSectorSet RLEpBitfield  </description>
    </item>
    
    <item>
      <title>SectorStore</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_store/</guid>
      <description>import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import piece &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&amp;#34; import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; type SectorStore struct { // FileStore stores all the unsealed and sealed sectors.  FileStore file.FileStore // PieceStore is shared with DataTransfer, and is a way to store or read  // pieces temporarily. This may or may not be backed by the FileStore above.  PieceStore piece.PieceStore // GetSectorFile returns the file for a given sector id.</description>
    </item>
    
    <item>
      <title>Selectors - IPLD Query Language</title>
      <link>/docs/libraries/ipld/selectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/selectors/</guid>
      <description>// This is a compression of the IPLD Selector Spec // Full spec: https://github.com/ipld/specs/blob/master/selectors/selectors.md  type Selector union { Matcher ExploreAll ExploreFields ExploreIndex ExploreRange ExploreRecursive ExploreUnion ExploreConditional ExploreRecursiveEdge } // ExploreAll is similar to a `*` -- it traverses all elements of an array, // or all entries in a map, and applies a next selector to the reached nodes. type ExploreAll struct { next Selector } // ExploreFields traverses named fields in a map (or equivalently, struct, if // traversing on typed/schema nodes) and applies a next selector to the // reached nodes.</description>
    </item>
    
    <item>
      <title>Sharded IPLD Array</title>
      <link>/docs/appendix/sharray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/sharray/</guid>
      <description>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.
IPLD Representation Each sharray node is represented by an IPLD node of the following schema:
type Node struct { height Int items [Item] } representation tuple Item may be either a direct value, if height == 0, or the Cid of a child node if height &amp;gt; 0.</description>
    </item>
    
    <item>
      <title>Signatures</title>
      <link>/docs/algorithms/crypto/signatures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/signatures/</guid>
      <description>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages with the assurance that each message was generated by a specific entity. In other words, it is infeasible for an entity i to generate a signed message that appears to have been generated by j, with j != i.
Filecoin uses signatures to associate an action to a given party.</description>
    </item>
    
    <item>
      <title>Stacked DRG - Offline PoRep Circuit Spec</title>
      <link>/docs/algorithms/porep/stacked_drg_circuit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/stacked_drg_circuit/</guid>
      <description>Stacked DRG Overview Stacked DRG PoRep is based on layering DRG graphs LAYERS times. The data represented in each DRG layer is a labeling based on previously labeled nodes. The final labeled layer is the SDR key, and the &amp;lsquo;final layer&amp;rsquo; of replication the replica, an encoding of the original data using the generated key.
 ReplicaId is a unique replica identifier (see the Filecoin Proofs spec for details). CommD is the Merkle tree root hash of the input data to the first layer.</description>
    </item>
    
    <item>
      <title>Stacked DRG Commitments</title>
      <link>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</guid>
      <description>(ql:quickload :orient)     :ORIENT     This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in Tight PoS - ZigZag. Graph  (defparameter *layers* 4) (defparameter *nodes* 8) (defparameter *regenerate-sdr-graph* nil) (defparameter *dumped-sdr-graph* &amp;#39;(:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)) (defparameter *sdr-graph* (if *regenerate-sdr-graph* (make-sdr-graph *nodes* *layers*) (load-from-plist *dumped-sdr-graph*))) (let ((lg (first (sdr-graph-layer-graphs *sdr-graph*)))) (defparameter *comm-d-graph* (make-comm-d-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph*)) (defparameter *replica-graph* (make-replica-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph* :layers *layers*))) (dump *sdr-graph*)  (:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)  (emit-legend nil)   In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only to illustrate the nature of the SDR commitment scheme.</description>
    </item>
    
    <item>
      <title>Stacked DRG Commitments</title>
      <link>/docs/content/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</guid>
      <description>This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in Tight PoS - ZigZag.
Graph In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent selection algorithm.</description>
    </item>
    
    <item>
      <title>Stacked DRG PoRep</title>
      <link>/docs/algorithms/porep/stacked_drg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/stacked_drg/</guid>
      <description>This section describes Stacked DRG PoRep (SDR), the specific Proof-of-Replication (PoRep) used in Filecoin. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.
SDR has been presented by Ben Fisch at EUROCRYPT19.
Introduction Background on Proof-of-Replication Proof-of-Replication enables a prover P to convince a verifier V that P is storing a replica R, a physically independent copy of some data D, unique to P.</description>
    </item>
    
    <item>
      <title>Storage Client</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_client/</guid>
      <description>The StorageClient is a module that discovers miners, determines their asks, and proposes deals to StorageProviders. It also tracks deals as they move through the deal flow. Note that any address registered as a StorageMarketParticipant with the StorageMarketActor can be used with the StorageClient. A single participant can be a client, provider, or both at the same time.
&amp;ndash;
import abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; import addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; import message &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&amp;#34; import peer &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Storage Deal Flow</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_deal/storage_deal_flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_deal/storage_deal_flow/</guid>
      <description>Deal Flow Sequence Diagram (open in new tab)  Add Storage Deal and Power    StorageClient and StorageProvider call StorageMarketActor.AddBalance to deposit funds into Storage Market.   StorageClient and StorageProvider can call WithdrawBalance before any deal is made.    StorageClient and StorageProvider negotiate a deal off chain. StorageClient sends a StorageDealProposal to a StorageProvider.   StorageProvider verifies the StorageDeal by checking address and signature of StorageClient, checking the proposal&amp;rsquo;s StartEpoch is after the current Epoch, checking StorageClient did not call withdraw in the last X Epoch (WithdrawBalance should take at least X Epoch), checking both StorageProvider and StorageClient have sufficient available balances in StorageMarketActor.</description>
    </item>
    
    <item>
      <title>Storage Deal States</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_deal/storage_deal_states/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_deal/storage_deal_states/</guid>
      <description>All on-chain economic activities in Filecoin start with the deal. This section aims to explain different states of a deal and their relationship with other concepts in the protocol such as Power, Payment, and Collaterals.
A deal has the following states:
 Unpublished: the deal has yet to be posted on chain. Published: the deal has been published and accepted by the chain but is not yet active as the sector containing the deal has not been proven.</description>
    </item>
    
    <item>
      <title>Storage Market Actor</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</guid>
      <description>StorageMarketActor is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of StorageDealID to StorageDeal and keeps track of locked balances of StorageClient and StorageProvider. When a deal is posted on chain through the StorageMarketActor, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain.</description>
    </item>
    
    <item>
      <title>Storage Miner Actor</title>
      <link>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</guid>
      <description>StorageMinerActorState implementation package storage_miner import ( &amp;#34;math/big&amp;#34; addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; indices &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&amp;#34; autil &amp;#34;github.com/filecoin-project/specs-actors/actors/util&amp;#34; cid &amp;#34;github.com/ipfs/go-cid&amp;#34; peer &amp;#34;github.com/libp2p/go-libp2p-core/peer&amp;#34; ) // Balance of a StorageMinerActor should equal exactly the sum of PreCommit deposits // that are not yet returned or burned. type StorageMinerActorState struct { Sectors SectorsAMT PoStState MinerPoStState ProvingSet SectorNumberSetHAMT Info MinerInfo } type MinerPoStState struct { // Epoch of the last succesful PoSt, either election post or surprise post.</description>
    </item>
    
    <item>
      <title>Storage Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</guid>
      <description>type StorageMinerNode interface { FilecoinNode systems.Blockchain systems.Mining markets.StorageMarketProvider markets.MarketOrderBook markets.DataTransfers } </description>
    </item>
    
    <item>
      <title>Storage Mining Cycle</title>
      <link>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</guid>
      <description>Block miners should constantly be performing Proofs of SpaceTime using Election PoSt, and checking the outputted partial tickets to run Secret Leader Election and determine whether they can propose a block at each epoch. Epochs are currently set to take around X seconds, in order to account for election PoSt and network propagation around the world. The details of the mining cycle are defined here.
Active Miner Mining Cycle In order to mine blocks on the Filecoin blockchain a miner must be running Block Validation at all times, keeping track of recent blocks received and the heaviest current chain (based on Expected Consensus).</description>
    </item>
    
    <item>
      <title>Storage Power Actor</title>
      <link>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</guid>
      <description>StoragePowerActorState implementation package storage_power import ( &amp;#34;sort&amp;#34; addr &amp;#34;github.com/filecoin-project/go-address&amp;#34; abi &amp;#34;github.com/filecoin-project/specs-actors/actors/abi&amp;#34; builtin &amp;#34;github.com/filecoin-project/specs-actors/actors/builtin&amp;#34; crypto &amp;#34;github.com/filecoin-project/specs-actors/actors/crypto&amp;#34; indices &amp;#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&amp;#34; autil &amp;#34;github.com/filecoin-project/specs-actors/actors/util&amp;#34; cid &amp;#34;github.com/ipfs/go-cid&amp;#34; ) // TODO: HAMT type PowerTableHAMT map[addr.Address]abi.StoragePower // TODO: convert address to ActorID  // TODO: HAMT type MinerEventsHAMT map[abi.ChainEpoch]autil.MinerEventSetHAMT type StoragePowerActorState struct { TotalNetworkPower abi.StoragePower PowerTable PowerTableHAMT EscrowTable autil.BalanceTableHAMT // Metadata cached for efficient processing of sector/challenge events. 	CachedDeferredCronEvents MinerEventsHAMT PoStDetectedFaultMiners autil.MinerSetHAMT ClaimedPower PowerTableHAMT NominalPower PowerTableHAMT NumMinersMeetingMinPower int } func (st *StoragePowerActorState) CID() cid.</description>
    </item>
    
    <item>
      <title>Storage Provider</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_provider/</guid>
      <description>The StorageProvider is a module that handles incoming queries for Asks and proposals for Deals from a StorageClient. It also tracks deals as they move through the deal flow, handling off chain actions during the negotiation phases of the deal and ultimately telling the StorageMarketActor to publish on chain. The StorageProvider&#39;s last action is to handoff a published deal for storage and sealing to the Storage Mining Subsystem. Note that any address registered as a StorageMarketParticipant with the StorageMarketActor can be used with the StorageClient.</description>
    </item>
    
    <item>
      <title>Testing and implementation compliance</title>
      <link>/docs/intro/process/related_resources/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/testing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>UnixFS</title>
      <link>/docs/libraries/ipfs/unixfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/unixfs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Verifiable Random Function</title>
      <link>/docs/algorithms/crypto/vrf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/vrf/</guid>
      <description>Filecoin uses the notion of a Verifiable Random Function (VRF). A VRF uses a private key to produce a digest of an arbitrary message such that the output is unique per signer and per message. Any third party in possession of the corresponding public key, the message and the VRF output can verify if the digest has been computed correctly and from the correct signer. Using a VRF in the ticket generation process allows anyone to verify if a block comes from an eligible block producer (see Ticket Generation for more details).</description>
    </item>
    
    <item>
      <title>VM Interpreter</title>
      <link>/docs/systems/filecoin_vm/interpreter/vm_interpreter_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/interpreter/vm_interpreter_old/</guid>
      <description>VM Interpreter Sending Funds As all messages carry a method ID, the method ID &amp;lsquo;0&amp;rsquo; is reserved for simple transfers of funds. Funds specified by the value field are always transferred, but specifying a method ID of &amp;lsquo;0&amp;rsquo; ensures that no other side effects occur.
State Representation The global state is modeled as a map of actor IDs to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &amp;lsquo;key&amp;rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the InitActor), and the value is an Actor object with the actors information.</description>
    </item>
    
    <item>
      <title>What are Systems? How do they work?</title>
      <link>/docs/intro/system/why_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/why_systems/</guid>
      <description>Filecoin decouples and modularizes functionality into loosely-joined systems. Each system adds significant functionality, usually to achieve a set of important and tightly related goals.
For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</description>
    </item>
    
  </channel>
</rss>